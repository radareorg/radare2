diff --git a/smallz4cat.c b/smallz4cat.c
index db3778b..b0a0107 100644
--- a/smallz4cat.c
+++ b/smallz4cat.c
@@ -52,7 +52,6 @@ static void unlz4error(const char* msg)
   fputs("ERROR: ", stderr);
   fputs(msg,       stderr);
   fputc('\n',      stderr);
-  exit(1);
 }
 
 
@@ -64,6 +63,8 @@ typedef unsigned char (*GET_BYTE)  (void* userPtr);
 // write several bytes,      see sendBytesToOut() for a basic implementation
 typedef void          (*SEND_BYTES)(const unsigned char*, unsigned int, void* userPtr);
 
+int unlz4Block_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, void* userPtr, unsigned int blockSize, unsigned int* position, unsigned char* hist);
+
 struct UserPtr
 {
   // file handles
@@ -109,7 +110,7 @@ static void sendBytesToOut(const unsigned char* data, unsigned int numBytes, voi
 
 
 /// decompress everything in input stream (accessed via getByte) and write to output stream (via sendBytes)
-void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionary, void* userPtr)
+int unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionary, void* userPtr)
 {
   // signature
   unsigned char signature1 = getByte(userPtr);
@@ -120,7 +121,10 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
   unsigned char isModern   = (signature == 0x184D2204);
   unsigned char isLegacy   = (signature == 0x184C2102);
   if (!isModern && !isLegacy)
+  {
     unlz4error("invalid signature");
+    return -1;
+  }
 
   unsigned char hasBlockChecksum   = FALSE;
   unsigned char hasContentSize     = FALSE;
@@ -138,7 +142,10 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
     // only version 1 file format
     unsigned char version = flags >> 6;
     if (version != 1)
+    {
       unlz4error("only LZ4 file format version 1 supported");
+      return -1;
+    }
 
     // ignore blocksize
     char numIgnore = 1;
@@ -170,8 +177,10 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
   {
     // open dictionary
     FILE* dict = fopen(dictionary, "rb");
-    if (!dict)
+    if (!dict) {
       unlz4error("cannot open dictionary");
+      return -1;
+    }
 
     // get dictionary's filesize
     fseek(dict, 0, SEEK_END);
@@ -207,6 +216,64 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
     if (isCompressed)
     {
       // decompress block
+
+      int numWritten = unlz4Block_userPtr(getByte, sendBytes, userPtr, blockSize, &pos, history);
+
+      // all legacy blocks must be completely filled - except for the last one
+      if (isLegacy && numWritten + pos < 8*1024*1024)
+        break;
+    }
+    else
+    {
+      // copy uncompressed data and add to history, too (if next block is compressed and some matches refer to this block)
+      while (blockSize-- > 0)
+      {
+        // copy a byte ...
+        history[pos++] = getByte(userPtr);
+        // ... until buffer is full => send to output
+        if (pos == HISTORY_SIZE)
+        {
+          sendBytes(history, HISTORY_SIZE, userPtr);
+          pos = 0;
+        }
+      }
+    }
+
+    if (hasBlockChecksum)
+    {
+      // ignore checksum, skip 4 bytes
+      getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
+    }
+  }
+
+  if (hasContentChecksum)
+  {
+    // ignore checksum, skip 4 bytes
+    getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
+  }
+
+  // flush output buffer
+  sendBytes(history, pos, userPtr);
+  return 0;
+}
+
+/// decompress an lz4 block
+int unlz4Block_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, void* userPtr, unsigned int blockSize, unsigned int* position, unsigned char* hist)
+{
+
+  // contains the latest decoded data
+  unsigned char history[HISTORY_SIZE];
+  // next free position in history[]
+  unsigned int  pos = 0;
+
+  // better way to do this?
+  if (position != NULL && hist != NULL)
+  {
+      pos = *position;
+      memcpy(history, hist, pos);
+  }
+
+      // decompress block
       unsigned int blockOffset = 0;
       unsigned int numWritten  = 0;
       while (blockOffset < blockSize)
@@ -263,8 +330,10 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
         unsigned int delta = getByte(userPtr);
         delta |= (unsigned int)getByte(userPtr) << 8;
         // zero isn't allowed
-        if (delta == 0)
+        if (delta == 0) {
           unlz4error("invalid offset");
+          return -1;
+        }
         blockOffset += 2;
 
         // match length (always >= 4, therefore length is stored minus 4)
@@ -322,41 +391,22 @@ void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, const char* dictionar
         }
       }
 
-      // all legacy blocks must be completely filled - except for the last one
-      if (isLegacy && numWritten + pos < 8*1024*1024)
-        break;
-    }
-    else
-    {
-      // copy uncompressed data and add to history, too (if next block is compressed and some matches refer to this block)
-      while (blockSize-- > 0)
+      // flush output buffer
+      if (pos > 0)
       {
-        // copy a byte ...
-        history[pos++] = getByte(userPtr);
-        // ... until buffer is full => send to output
-        if (pos == HISTORY_SIZE)
-        {
-          sendBytes(history, HISTORY_SIZE, userPtr);
+          sendBytes(history, pos, userPtr);
+          numWritten += pos;
           pos = 0;
-        }
       }
-    }
-
-    if (hasBlockChecksum)
-    {
-      // ignore checksum, skip 4 bytes
-      getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
-    }
-  }
 
-  if (hasContentChecksum)
-  {
-    // ignore checksum, skip 4 bytes
-    getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
-  }
-
-  // flush output buffer
-  sendBytes(history, pos, userPtr);
+      // If we flushed everything, it's normal that position = 0
+      // and nothing gets copied back into history.
+      if (position != NULL && hist != NULL)
+      {
+          *position = pos;
+          memcpy(hist, history, pos);
+      }
+      return numWritten;
 }
 
 /// old interface where getByte and sendBytes use global file handles
