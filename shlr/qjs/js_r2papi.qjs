"use strict";
// shell utilities on top of r2pipe
Object.defineProperty(exports, "__esModule", { value: true });
exports.R2Shell = void 0;
/**
 * Provides a way to script the interactions with different language models using javascript from inside radare2.
 *
 * @typedef R2Shell
 */
class R2Shell {
    /**
     * Create a new instance of the R2Shell
     *
     * @param {R2Papi} take the R2Papi intance to used as backend to run the commands
     * @returns {R2Shell} instance of the shell api
     */
    constructor(papi) {
        this.rp = papi;
    }
    /**
     * Create a new directory in the host system, if the opational recursive argument is set to
     * true it will create all the necessary subdirectories instead of just the specified one.
     *
     * @param {string} text path to the new directory to be created
     * @param {boolean?} disabled by default, but if it's true, it will create subdirectories recursively if necessary
     * @returns {boolean} true if successful
     */
    mkdir(file, recursive) {
        if (recursive === true) {
            this.rp.call(`mkdir -p ${file}`);
        }
        else {
            this.rp.call(`mkdir ${file}`);
        }
        return true;
    }
    /**
     * Deletes a file
     *
     * @param {string} path to the file to remove
     * @returns {boolean} true if successful
     */
    unlink(file) {
        this.rp.call(`rm ${file}`);
        return true;
    }
    /**
     * Change current directory
     *
     * @param {string} path to the directory
     * @returns {boolean} true if successful
     */
    chdir(path) {
        this.rp.call(`cd ${path}`);
        return true;
    }
    /**
     * List files in the current directory
     *
     * @returns {string[]} array of file names
     */
    ls() {
        const files = this.rp.call(`ls -q`);
        return files.trim().split("\n");
    }
    /**
     * TODO: Checks if a file exists (not implemented)
     *
     * @returns {boolean} true if the file exists, false if it does not
     */
    fileExists(path) {
        // TODO
        return false;
    }
    /**
     * Opens an URL or application
     * Execute `xdg-open` on linux, `start` on windows, `open` on Mac
     *
     * @param {string} URI or file to open by the system
     */
    open(arg) {
        this.rp.call(`open ${arg}`);
    }
    /**
     * Run a system command and get the return code
     *
     * @param {string} system command to be executed
     * @returns {number} return code (0 is success)
     */
    system(cmd) {
        this.rp.call(`!${cmd}`);
        return 0;
    }
    /**
     * Mount the given offset on the specified path using the filesytem.
     * This is not a system-level mountpoint, it's using the internal filesystem abstraction of radare2.
     *
     * @param {string} filesystem type name (see .
     * @param {string} system command to be executed
     * @param {string|number}
     * @returns {number} return code (0 is success)
     */
    mount(fstype, path, offset) {
        if (!offset) {
            offset = 0;
        }
        this.rp.call(`m ${fstype} ${path} ${offset}`);
        return true;
    }
    /**
     * Unmount the mountpoint associated with the given path.
     *
     * @param {string} path to the mounted filesystem
     * @returns {void} TODO: should return boolean
     */
    umount(path) {
        this.rp.call(`m-${path}`);
    }
    /**
     * Change current directory on the internal radare2 filesystem
     *
     * @param {string} path name to change to
     * @returns {void} TODO: should return boolean
     */
    chdir2(path) {
        this.rp.call(`mdq ${path}`);
    }
    /**
     * List the files contained in the given path within the virtual radare2 filesystem.
     *
     * @param {string} path name to change to
     * @returns {void} TODO: should return boolean
     */
    ls2(path) {
        const files = this.rp.call(`mdq ${path}`);
        return files.trim().split("\n");
    }
    /**
     * Enumerate all the mountpoints set in the internal virtual filesystem of radare2
     * @returns {any[]} array of mount
     */
    enumerateFilesystemTypes() {
        return this.rp.cmdj("mLj");
    }
    /**
     * Enumerate all the mountpoints set in the internal virtual filesystem of radare2
     * @returns {any[]} array of mount
     */
    enumerateMountpoints() {
        const output = this.rp.cmdj("mj");
        return output["mountpoints"];
    }
    /**
     * TODO: not implemented
     */
    isSymlink(file) {
        return false;
    }
    /**
     * TODO: not implemented
     */
    isDirectory(file) {
        return false;
    }
}
exports.R2Shell = R2Shell;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EsilParser = exports.EsilNode = exports.EsilToken = void 0;
// ("this is just a comment"), -- comments are also part of the runtime
/*
=("//", {
    =(obj, {}())
    =([obj, comment], 32)
    if(eq([obj,comment], 32),
        ret()
    )
    ret(obj)
})
*/
class EsilToken {
    constructor(text = "", position = 0) {
        this.label = "";
        this.comment = "";
        this.text = "";
        this.addr = "0"; // for ut64 we use strings for numbers :<
        this.position = 0;
        this.text = text;
        this.position = position;
    }
    toString() {
        return this.text;
    }
}
exports.EsilToken = EsilToken;
class EsilNode {
    constructor(token = new EsilToken(), type = "none") {
        this.type = "none";
        this.token = token;
        this.children = [];
    }
    setSides(lhs, rhs) {
        this.lhs = lhs;
        this.rhs = rhs;
    }
    addChildren(ths, fhs) {
        if (ths !== undefined) {
            this.children.push(ths);
        }
        if (fhs !== undefined) {
            this.children.push(fhs);
        }
    }
    toEsil() {
        if (this.lhs !== undefined && this.rhs !== undefined) {
            // XXX handle ?{ }{ }
            let left = this.lhs.toEsil();
            if (left !== "") {
                left += ",";
            }
            const right = this.rhs.toEsil();
            return `${right},${left}${this.token}`;
        }
        return ""; // this.token.text;
    }
    toString() {
        let str = "";
        if (this.token.label !== "") {
            str += this.token.label + ":\n";
        }
        if (this.token.addr !== "0") {
            // str += "//  @ " + this.token.addr + "\n";
        }
        if (this.token.comment !== "") {
            str += "/*" + this.token.comment + "*/\n";
        }
        if (this.token.toString() === "GOTO") {
            if (this.children.length > 0) {
                const children = this.children[0];
                str += "goto label_" + children.token.position + ";\n";
            }
            else {
                // console.log(JSON.stringify(this,null, 2));
                const pos = 0;
                str += `goto label_${pos};\n`;
            }
        }
        if (this.children.length > 0) {
            str += `  (if (${this.rhs})\n`;
            for (const children of this.children) {
                if (children !== null) {
                    const x = children.toString();
                    if (x != "") {
                        str += `  ${x}\n`;
                    }
                }
            }
            str += "  )\n";
        }
        if (this.lhs !== undefined && this.rhs !== undefined) {
            return str + `    ( ${this.lhs} ${this.token} ${this.rhs} )`;
            // return str + `${this.lhs} ${this.token} ${this.rhs}`;
        }
        return str + this.token.toString();
    }
}
exports.EsilNode = EsilNode;
class EsilParser {
    constructor(r2) {
        this.cur = 0;
        this.r2 = r2;
        this.cur = 0;
        this.stack = [];
        this.nodes = [];
        this.tokens = [];
        this.root = new EsilNode(new EsilToken("function", 0), "block");
    }
    toJSON() {
        if (this.stack.length > 0) {
            // return JSON.stringify (this.stack, null, 2);
            throw new Error("The ESIL stack is not empty");
        }
        return JSON.stringify(this.root, null, 2);
    }
    toEsil() {
        return this.nodes.map((x) => x.toEsil()).join(",");
    }
    optimizeFlags(node) {
        if (node.rhs !== undefined) {
            this.optimizeFlags(node.rhs);
        }
        if (node.lhs !== undefined) {
            this.optimizeFlags(node.lhs);
        }
        for (let i = 0; i < node.children.length; i++) {
            this.optimizeFlags(node.children[i]);
        }
        const addr = node.toString();
        if (+addr > 4096) {
            const cname = r2.cmd(`fd.@ ${addr}`);
            const fname = cname.trim().split("\n")[0].trim();
            if (fname != "" && fname.indexOf("+") === -1) {
                node.token.text = fname;
            }
        }
    }
    optimize(options) {
        if (options.indexOf("flag") != -1) {
            this.optimizeFlags(this.root);
        }
    }
    toString() {
        return this.root.children.map((x) => x.toString()).join(";\n");
    }
    reset() {
        this.nodes = [];
        this.stack = [];
        this.tokens = [];
        this.cur = 0;
        this.root = new EsilNode(new EsilToken("function", 0), "block");
    }
    parseRange(from, to) {
        let pos = from;
        while (pos < this.tokens.length && pos < to) {
            const token = this.peek(pos);
            if (!token) {
                // console.log("BREAK");
                break;
            }
            // console.log(pos, token);
            this.cur = pos;
            this.pushToken(token);
            pos = this.cur;
            pos++;
        }
        // console.log("done");
    }
    parseFunction(addr) {
        const ep = this;
        function parseAmount(n) {
            // console.log("PDQ "+n);
            const output = r2.cmd("pie " + n + " @e:scr.color=0");
            const lines = output.trim().split("\n");
            for (const line of lines) {
                if (line.length === 0) {
                    console.log("Empty");
                    continue;
                }
                // console.log("parse", r2.cmd("?v:$$"));
                const kv = line.split(" ");
                if (kv.length > 1) {
                    // line != "") {
                    // console.log("// @ " + kv[0]);
                    //ep.reset ();
                    r2.cmd(`s ${kv[0]}`);
                    ep.parse(kv[1], kv[0]);
                    ep.optimize("flags,labels");
                    //console.log(ep.toString());
                }
            }
            // console.log(ep.toString());
        }
        const oaddr = (r2.cmd("?v $$")).trim();
        // const func = r2.cmdj("pdrj"); // XXX this command changes the current seek
        if (addr === undefined) {
            addr = oaddr;
        }
        const bbs = r2.cmdj(`afbj@${addr}`); // XXX this command changes the current seek
        for (const bb of bbs) {
            // console.log("bb_" + bb.addr + ":");
            r2.cmd(`s ${bb.addr}`);
            parseAmount(bb.ninstr);
        }
        r2.cmd(`s ${oaddr}`);
    }
    parse(expr, addr) {
        const tokens = expr
            .trim()
            .split(",")
            .map((x) => x.trim());
        const from = this.tokens.length;
        for (const tok of tokens) {
            const token = new EsilToken(tok, this.tokens.length);
            if (addr !== undefined) {
                token.addr = addr;
            }
            this.tokens.push(token);
        }
        const to = this.tokens.length;
        this.parseRange(from, to);
    }
    peek(a) {
        return this.tokens[a];
    }
    pushToken(tok) {
        if (this.isNumber(tok)) {
            const node = new EsilNode(tok, "number");
            this.stack.push(node);
            this.nodes.push(node);
        }
        else if (this.isInternal(tok)) {
            const node = new EsilNode(tok, "flag");
            this.stack.push(node);
            this.nodes.push(node);
        }
        else if (this.isOperation(tok)) {
            // run the operation login
        }
        else {
            // assume it's a register, so just push the string
            const node = new EsilNode(tok, "register");
            this.stack.push(node);
            this.nodes.push(node);
        }
        // we need a list of register names to do this check properly
        // throw new Error ("Unknown token");
    }
    isNumber(expr) {
        if (expr.toString().startsWith("0")) {
            return true;
        }
        return +expr > 0;
    }
    isInternal(expr) {
        const text = expr.toString();
        return text.startsWith("$") && text.length > 1;
    }
    parseUntil(start) {
        const from = start + 1;
        let pos = from;
        const origStack = [];
        const this_nodes_length = this.nodes.length;
        this.stack.forEach((x) => origStack.push(x));
        while (pos < this.tokens.length) {
            const token = this.peek(pos);
            if (!token) {
                break;
            }
            if (token.toString() === "}") {
                break;
            }
            if (token.toString() === "}{") {
                // return token;
                break;
            }
            // console.log("peek ", this.tokens[pos]);
            pos++;
        }
        this.stack = origStack;
        const to = pos;
        this.parseRange(from, to);
        const same = this.nodes.length == this_nodes_length;
        // console.log("BLOCK ("+ ep.toString());
        if (same) {
            return null;
        }
        return this.nodes[this.nodes.length - 1]; // this.tokens.length - 1];
    }
    getNodeFor(index) {
        const tok = this.peek(index);
        if (tok === undefined) {
            return null;
        }
        for (const node of this.nodes) {
            if (node.token.position === index) {
                return node;
            }
        }
        this.nodes.push(new EsilNode(new EsilToken("label", index), "label"));
        return null;
    }
    findNodeFor(index) {
        for (const node of this.nodes) {
            if (node.token.position === index) {
                return node;
            }
        }
        return null;
    }
    isOperation(expr) {
        switch (expr.toString()) {
            // 1pop1push
            case "[1]":
            case "[2]":
            case "[4]":
            case "[8]":
                if (this.stack.length >= 1) {
                    const i1 = this.stack.pop();
                    // TODO: MemoryReferenceNode(i1));
                    const mn = new EsilNode(i1.token, "operation"); // expr.toString());
                    this.stack.push(i1); // mn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 1pop1push
            case "!":
                if (this.stack.length >= 1) {
                    const i0 = new EsilNode(new EsilToken("", expr.position), "none");
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    this.stack.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            case "":
            case "}":
            case "}{":
                // no pops or nothing, just does nothing
                return true;
            case "DUP":
                if (this.stack.length < 1) {
                    throw new Error("goto cant pop");
                }
                else {
                    const destNode = this.stack.pop();
                    this.stack.push(destNode);
                    this.stack.push(destNode);
                }
                return true;
            case "GOTO":
                // take previous statement which should be const and add a label
                {
                    const prev = this.peek(expr.position - 1);
                    if (prev !== null) {
                        // TODO: check stack
                        if (this.stack.length < 1) {
                            throw new Error("goto cant pop");
                        }
                        const destNode = this.stack.pop();
                        if (destNode !== null) {
                            const value = 0 | +destNode.toString();
                            if (value > 0) {
                                const destToken = this.peek(value);
                                if (destToken !== undefined) {
                                    destToken.label = "label_" + value;
                                    destToken.comment = "hehe";
                                    const nn = new EsilNode(expr, "goto");
                                    const gn = this.getNodeFor(destToken.position);
                                    if (gn != null) {
                                        nn.children.push(gn);
                                    }
                                    this.root.children.push(nn);
                                }
                                else {
                                    console.error("Cannot find goto node");
                                }
                            }
                            else {
                                console.error("Cannot find dest node for goto");
                            }
                        }
                    }
                }
                return true;
            // controlflow
            case "?{": // ESIL_TOKEN_IF
                if (this.stack.length >= 1) {
                    const i0 = new EsilNode(new EsilToken("if", expr.position), "none");
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1); // left side can be ignored for now.. but we can express this somehow
                    const trueBlock = this.parseUntil(expr.position);
                    let falseBlock = null;
                    // nn.addChildren(trueBlock, falseBlock);
                    if (trueBlock !== null) {
                        nn.children.push(trueBlock);
                        this.nodes.push(trueBlock);
                        falseBlock = this.parseUntil(trueBlock.token.position + 1);
                        if (falseBlock !== null) {
                            nn.children.push(falseBlock);
                            this.nodes.push(falseBlock);
                        }
                    }
                    // console.log("true", trueBlock);
                    // console.log("false", falseBlock);
                    // this.stack.push(nn);
                    this.nodes.push(nn);
                    this.root.children.push(nn);
                    if (falseBlock !== null) {
                        this.cur = falseBlock.token.position;
                    }
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            case "-":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        //	this.root.children.push(nn);
                    }
                    this.stack.push(nn);
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 2pop1push
            case "<":
            case ">":
            case "^":
            case "&":
            case "|":
            case "+":
            case "*":
            case "/":
            case ">>=":
            case "<<=":
            case ">>>=":
            case "<<<=":
            case ">>>>=":
            case "<<<<=":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        //	this.root.children.push(nn);
                    }
                    this.stack.push(nn);
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
            // 2pop0push
            case "=":
            case ":=":
            case "-=":
            case "+=":
            case "==":
            case "=[1]":
            case "=[2]":
            case "=[4]":
            case "=[8]":
                if (this.stack.length >= 2) {
                    const i0 = this.stack.pop();
                    const i1 = this.stack.pop();
                    const nn = new EsilNode(expr, "operation");
                    nn.setSides(i0, i1);
                    if (this.stack.length === 0) {
                        this.root.children.push(nn);
                    }
                    this.nodes.push(nn);
                }
                else {
                    throw new Error("Stack needs more items");
                }
                return true;
        }
        return false;
    }
}
exports.EsilParser = EsilParser;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64 = void 0;
class Base64 {
    /**
     * Encode the given input string using base64
     *
     * @param {string} input string to encode
     * @returns {string} base64 encoded string
     */
    static encode(input) {
        return (0, exports.b64)(input);
    }
    /**
     * Decode the given base64 string into plain text
     *
     * @param {string} input string encoded in base64 format
     * @returns {string} base64 decoded string
     */
    static decode(input) {
        return (0, exports.b64)(input, true);
    }
}
exports.Base64 = Base64;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newAsyncR2PipeFromSync = exports.R2PipeSyncFromSync = void 0;
class R2PipeSyncFromSync {
    constructor(r2p) {
        this.r2p = r2p;
    }
    /**
     * Run a command in the associated instance of radare2 and return the output as a string
     *
     * @param {string} command to be executed inside radare2.
     * @returns {string} The output of the command execution
     */
    cmd(command) {
        return this.r2p.cmd(command);
    }
    cmdAt(command, address) {
        return this.r2p.cmdAt(command, address);
    }
    cmdj(cmd) {
        return this.r2p.cmdj(cmd);
    }
    call(command) {
        return this.r2p.call(command);
    }
    callj(cmd) {
        return this.r2p.cmdj(cmd);
    }
    callAt(command, address) {
        return this.r2p.cmdAt(command, address);
    }
    log(msg) {
        return this.r2p.log(msg);
    }
    plugin(type, maker) {
        return this.r2p.plugin(type, maker);
    }
    unload(type, name) {
        return this.r2p.unload(type, name);
    }
}
exports.R2PipeSyncFromSync = R2PipeSyncFromSync;
function newAsyncR2PipeFromSync(r2p) {
    const asyncR2Pipe = new R2PipeSyncFromSync(r2p);
    return asyncR2Pipe;
}
exports.newAsyncR2PipeFromSync = newAsyncR2PipeFromSync;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.R2AI = void 0;
/**
 * Provides a way to script the interactions with different language models using javascript from inside radare2.
 *
 * @typedef R2AI
 */
class R2AI {
    constructor(r2, num, model) {
        /**
         * Instance variable that informs if the `r2ai` plugin is loaded, must be true in order to use the rest of the methods of this class.
         *
         * @type {boolean}
         */
        this.available = false;
        /**
         * Name of the model instantiated to be used for the subsequent calls.
         *
         * @type {string}
         */
        this.model = "";
        this.r2 = r2;
        this.available = false;
    }
    checkAvailability() {
        if (this.available) {
            return true;
        }
        this.available = r2pipe_js_1.r2.cmd("r2ai -h").trim() !== "";
        /*
        if (this.available) {
            if (num) {
                r2.call(`r2ai -n ${num}`)
            }
            // r2.call('r2ai -e DEBUG=1')
            if (model) {
                this.model = model;
            }
        }
        */
        return this.available;
    }
    /**
     * Reset conversation messages
     */
    reset() {
        this.checkAvailability();
        if (this.available) {
            r2pipe_js_1.r2.call("r2ai -R");
        }
    }
    /**
     * Set the role (system prompt) message for the language model to obey.
     *
     * @param {string} text containing the system prompt
     * @returns {boolean} true if successful
     */
    setRole(msg) {
        if (this.available) {
            r2pipe_js_1.r2.call(`r2ai -r ${msg}`);
            return true;
        }
        return false;
    }
    /**
     * Set the Model name or path to the GGUF file to use.
     *
     * @param {string} model name or path to GGUF file
     * @returns {boolean} true if successful
     */
    setModel(modelName) {
        if (this.available) {
            r2pipe_js_1.r2.call(`r2ai -m ${this.model}`);
            return true;
        }
        return false;
    }
    /**
     * Get the current selected model name.
     *
     * @returns {boolean} model name
     */
    getModel() {
        if (this.available) {
            this.model = r2pipe_js_1.r2.call("r2ai -m").trim();
        }
        return this.model;
    }
    /**
     * Get a list of suggestions for model names to use.
     *
     * @returns {string[]} array of strings containing the model names known to work
     */
    listModels() {
        if (this.available) {
            const models = r2pipe_js_1.r2.call("r2ai -M");
            return models
                .replace(/-m /, "")
                .trim()
                .split(/\n/g)
                .filter((x) => x.indexOf(":") !== -1);
        }
        return [];
    }
    /**
     * Send message to the language model to be appended to the current conversation (see `.reset()`)
     *
     * @param {string} text sent from the user to the language model
     * @returns {string} response from the language model
     */
    query(msg) {
        if (!this.available || msg == "") {
            return "";
        }
        const fmsg = msg.trim().replace(/\n/g, ".");
        const response = r2pipe_js_1.r2.call(`r2ai ${fmsg}`);
        return response.trim();
    }
}
exports.R2AI = R2AI;
"use strict";
// main r2papi file
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativePointer = exports.NativeCallback = exports.NativeFunction = exports.R2PapiSync = exports.Assembler = exports.ProcessClass = exports.ModuleClass = exports.ThreadClass = void 0;
class ThreadClass {
    constructor(r2) {
        this.api = null;
        this.api = r2;
    }
    backtrace() {
        return r2pipe_js_1.r2.call("dbtj");
    }
    sleep(seconds) {
        return r2pipe_js_1.r2.call("sleep " + seconds);
    }
}
exports.ThreadClass = ThreadClass;
class ModuleClass {
    constructor(r2) {
        this.api = null;
        this.api = r2;
    }
    fileName() {
        return this.api.call("dpe").trim();
    }
    name() {
        return "Module";
    }
    findBaseAddress() {
        return "TODO";
    }
    getBaseAddress(name) {
        return "TODO";
    }
    getExportByName(name) {
        const res = r2pipe_js_1.r2.call("iE,name/eq/" + name + ",vaddr/cols,:quiet");
        return ptr(res);
    }
    findExportByName(name) {
        return this.getExportByName(name);
    }
    enumerateExports() {
        // TODO: adjust to be the same output as Frida
        return r2pipe_js_1.r2.callj("iEj");
    }
    enumerateImports() {
        // TODO: adjust to be the same output as Frida
        return r2pipe_js_1.r2.callj("iij");
    }
    enumerateSymbols() {
        // TODO: adjust to be the same output as Frida
        return r2pipe_js_1.r2.callj("isj");
    }
    enumerateEntrypoints() {
        // TODO: adjust to be the same output as Frida
        return r2pipe_js_1.r2.callj("iej");
    }
    enumerateRanges() {
        // TODO: adjust to be the same output as Frida
        return r2pipe_js_1.r2.callj("omj");
    }
}
exports.ModuleClass = ModuleClass;
class ProcessClass {
    constructor(r2) {
        this.r2 = null;
        this.r2 = r2;
    }
    enumerateMallocRanges() { }
    enumerateSystemRanges() { }
    enumerateRanges() { }
    enumerateThreads() {
        return r2pipe_js_1.r2.callj("dptj");
    }
    enumerateModules() {
        r2pipe_js_1.r2.call("cfg.json.num=string"); // to handle 64bit values properly
        if (r2pipe_js_1.r2.callj("e cfg.debug")) {
            const modules = r2pipe_js_1.r2.callj("dmmj");
            const res = [];
            for (const mod of modules) {
                const entry = {
                    base: new NativePointer(mod.addr),
                    size: new NativePointer(mod.addr_end).sub(mod.addr),
                    path: mod.file,
                    name: mod.name
                };
                res.push(entry);
            }
            return res;
        }
        else {
            const fname = (x) => {
                const y = x.split("/");
                return y[y.length - 1];
            };
            const bobjs = r2pipe_js_1.r2.callj("obj");
            const res = [];
            for (const obj of bobjs) {
                const entry = {
                    base: new NativePointer(obj.addr),
                    size: obj.size,
                    path: obj.file,
                    name: fname(obj.file)
                };
                res.push(entry);
            }
            const libs = r2pipe_js_1.r2.callj("ilj");
            for (const lib of libs) {
                const entry = {
                    base: 0,
                    size: 0,
                    path: lib,
                    name: fname(lib)
                };
                res.push(entry);
            }
            return res;
        }
    }
    getModuleByAddress(addr) { }
    getModuleByName(moduleName) { }
    codeSigningPolicy() {
        return "optional";
    }
    getTmpDir() {
        return this.r2.call("e dir.tmp").trim();
    }
    getHomeDir() {
        return this.r2.call("e dir.home").trim();
    }
    platform() {
        return this.r2.call("e asm.os").trim();
    }
    getCurrentDir() {
        return this.r2.call("pwd").trim();
    }
    getCurrentThreadId() {
        return +this.r2.call("dpq");
    }
    pageSize() {
        if (this.r2.callj("e asm.bits") === 64 &&
            this.r2.call("e asm.arch").startsWith("arm")) {
            return 16384;
        }
        return 4096;
    }
    isDebuggerAttached() {
        return this.r2.callj("e cfg.debug");
    }
    setExceptionHandler() {
        // do nothing
    }
    id() {
        //
        return this.r2.callj("dpq").trim();
    }
    pointerSize() {
        return r2pipe_js_1.r2.callj("e asm.bits") / 8;
    }
}
exports.ProcessClass = ProcessClass;
/**
 * Assembler and disassembler facilities to decode and encode instructions
 *
 * @typedef Assembler
 */
class Assembler {
    constructor(myr2) {
        this.program = "";
        this.labels = {};
        this.endian = false;
        this.pc = ptr(0);
        if (myr2 === undefined) {
            this.r2 = (0, r2pipe_js_1.newAsyncR2PipeFromSync)(r2pipe_js_1.r2);
        }
        else {
            this.r2 = myr2;
        }
        this.program = "";
        this.labels = {};
    }
    /**
     * Change the address of the program counter, some instructions need to know where
     * are they located before being encoded or decoded.
     *
     * @param {NativePointerValue}
     */
    setProgramCounter(pc) {
        this.pc = pc;
    }
    setEndian(big) {
        this.endian = big;
    }
    toString() {
        return this.program;
    }
    append(x) {
        // append text
        this.pc = this.pc.add(x.length / 2);
        this.program += x;
    }
    // api
    label(s) {
        const pos = this.pc; // this.#program.length / 4;
        this.labels[s] = this.pc;
        return pos;
    }
    /**
     * Encode (assemble) an instruction by taking the string representation.
     *
     * @param {string} the string representation of the instruction to assemble
     * @returns {string} the hexpairs that represent the assembled instruciton
     */
    encode(s) {
        const output = this.r2.call(`pa ${s}`);
        return output.trim();
    }
    /**
     * Decode (disassemble) an instruction by taking the hexpairs string as input.
     * TODO: should take an array of bytes too
     *
     * @param {string} the hexadecimal pairs of bytes to decode as an instruction
     * @returns {string} the mnemonic and operands of the resulting decoding
     */
    decode(s) {
        const output = this.r2.call(`pad ${s}`);
        return output.trim();
    }
}
exports.Assembler = Assembler;
/**
 * High level abstraction on top of the r2 command interface provided by r2pipe.
 *
 * @typedef R2Papi
 */
class R2PapiSync {
    /**
     * Create a new instance of the R2Papi class, taking an r2pipe interface as reference.
     *
     * @param {R2PipeSync} the r2pipe instance to use as backend.
     * @returns {R2Papi} instance
     */
    constructor(r2) {
        this.r2 = r2;
    }
    toString() {
        return "[object R2Papi]";
    }
    toJSON() {
        return this.toString();
    }
    /**
     * Get the base address used by the current loaded binary
     *
     * @returns {NativePointer} address of the base of the binary
     */
    getBaseAddress() {
        return new NativePointer(this.cmd("e bin.baddr"));
    }
    jsonToTypescript(name, a) {
        let str = `interface ${name} {\n`;
        if (a.length && a.length > 0) {
            a = a[0];
        }
        for (const k of Object.keys(a)) {
            const typ = typeof a[k];
            const nam = k;
            str += `    ${nam}: ${typ};\n`;
        }
        return `${str}}\n`;
    }
    /**
     * Get the general purpose register size of the targize architecture in bits
     *
     * @returns {number} the regsize
     */
    getBits() {
        return +this.cmd("-b");
    }
    /**
     * Get the name of the arch plugin selected, which tends to be the same target architecture.
     * Note that on some situations, this info will be stored protected bby the AirForce.
     * When using the r2ghidra arch plugin the underlying arch is in `asm.cpu`:
     *
     * @returns {string} the name of the target architecture.
     */
    getArch() {
        return this.cmdTrim("-a");
    }
    callTrim(x) {
        const res = this.call(x);
        return res.trim();
    }
    cmdTrim(x) {
        const res = this.cmd(x);
        return res.trim();
    }
    /**
     * Get the name of the selected CPU for the current selected architecture.
     *
     * @returns {string} the value of asm.cpu
     */
    getCpu() {
        // return this.cmd('-c');
        return this.cmdTrim("-e asm.cpu"); // use arch.cpu
    }
    // TODO: setEndian, setCpu, ...
    setArch(arch, bits) {
        this.cmd("-a " + arch);
        if (bits !== undefined) {
            this.cmd("-b " + bits);
        }
    }
    setFlagSpace(name) {
        this.cmd("fs " + name);
    }
    demangleSymbol(lang, mangledName) {
        return this.cmdTrim("iD " + lang + " " + mangledName);
    }
    setLogLevel(level) {
        this.cmd("e log.level=" + level);
    }
    /**
     * should return the id for the new map using the given file descriptor
     */
    // rename to createMap or mapFile?
    newMap(fd, vaddr, size, paddr, perm, name = "") {
        this.cmd(`om ${fd} ${vaddr} ${size} ${paddr} ${perm} ${name}`);
    }
    at(a) {
        return new NativePointer(a);
    }
    getShell() {
        return new shell_js_1.R2Shell(this);
    }
    // Radare/Frida
    version() {
        const v = this.r2.cmd("?Vq");
        return v.trim();
    }
    // Process
    platform() {
        const output = this.r2.cmd("uname");
        return output.trim();
    }
    arch() {
        const output = this.r2.cmd("uname -a");
        return output.trim();
    }
    bits() {
        const output = this.r2.cmd("uname -b");
        return output.trim();
    }
    id() {
        // getpid();
        return +this.r2.cmd("?vi:$p");
    }
    // Other stuff
    printAt(msg, x, y) {
        // see pg, but pg is obrken :D
    }
    clearScreen() {
        this.r2.cmd("!clear");
        return this;
    }
    getConfig(key) {
        if (key === "") {
            return new Error("Empty key");
        }
        const exist = this.r2.cmd(`e~^${key} =`);
        if (exist.trim() === "") {
            return new Error("Config key does not exist");
        }
        const value = this.r2.call("e " + key);
        return value.trim();
    }
    setConfig(key, val) {
        this.r2.call("e " + key + "=" + val);
        return this;
    }
    getRegisterStateForEsil() {
        const dre = this.cmdj("dre");
        return this.cmdj("dre");
    }
    getRegisters() {
        // this.r2.log("winrar" + JSON.stringify(JSON.parse(this.r2.cmd("drj")),null, 2) );
        return this.cmdj("drj");
    }
    resizeFile(newSize) {
        this.cmd(`r ${newSize}`);
        return this;
    }
    insertNullBytes(newSize, at) {
        if (at === undefined) {
            at = "$$";
        }
        this.cmd(`r+${newSize}@${at}`);
        return this;
    }
    removeBytes(newSize, at) {
        if (at === undefined) {
            at = "$$";
        }
        this.cmd(`r-${newSize}@${at}`);
        return this;
    }
    seek(addr) {
        this.cmd(`s ${addr}`);
        return this;
    }
    currentSeek() {
        return new NativePointer("$$");
    }
    seekToRelativeOpcode(nth) {
        this.cmd(`so ${nth}`);
        return this.currentSeek();
    }
    getBlockSize() {
        return +this.cmd("b");
    }
    setBlockSize(a) {
        this.cmd(`b ${a}`);
        return this;
    }
    countFlags() {
        return Number(this.cmd("f~?"));
    }
    countFunctions() {
        return Number(this.cmd("aflc"));
    }
    analyzeFunctionsWithEsil(depth) {
        this.cmd("aaef");
    }
    analyzeProgramWithEsil(depth) {
        this.cmd("aae");
    }
    analyzeProgram(depth) {
        if (depth === undefined) {
            depth = 0;
        }
        switch (depth) {
            case 0:
                this.cmd("aa");
                break;
            case 1:
                this.cmd("aaa");
                break;
            case 2:
                this.cmd("aaaa");
                break;
            case 3:
                this.cmd("aaaaa");
                break;
        }
        return this;
    }
    enumerateThreads() {
        // TODO: use apt/dpt to list threads at iterate over them to get the registers
        const regs0 = this.cmdj("drj");
        const thread0 = {
            context: regs0,
            id: 0,
            state: "waiting",
            selected: true
        };
        return [thread0];
    }
    currentThreadId() {
        if (+this.cmd("e cfg.debug")) {
            return +this.cmd("dpt.");
        }
        return this.id();
    }
    setRegisters(obj) {
        for (const r of Object.keys(obj)) {
            const v = obj[r];
            this.r2.cmd("dr " + r + "=" + v);
        }
    }
    hex(s) {
        const output = this.r2.cmd("?v " + s);
        return output.trim();
    }
    step() {
        this.r2.cmd("ds");
        return this;
    }
    stepOver() {
        this.r2.cmd("dso");
        return this;
    }
    math(expr) {
        return +this.r2.cmd("?v " + expr);
    }
    stepUntil(dst) {
        this.cmd(`dsu ${dst}`);
    }
    enumerateXrefsTo(s) {
        const output = this.call("axtq " + s);
        return output.trim().split(/\n/);
    }
    // TODO: rename to searchXrefsTo ?
    findXrefsTo(s, use_esil) {
        if (use_esil) {
            this.call("/r " + s);
        }
        else {
            this.call("/re " + s);
        }
    }
    analyzeFunctionsFromCalls() {
        this.call("aac");
        return this;
    }
    autonameAllFunctions() {
        this.call("aan");
        return this;
    }
    analyzeFunctionsWithPreludes() {
        this.call("aap");
        return this;
    }
    analyzeObjCReferences() {
        this.cmd("aao");
        return this;
    }
    analyzeImports() {
        this.cmd("af @ sym.imp.*");
        return this;
    }
    searchDisasm(s) {
        const res = this.callj("/ad " + s);
        return res;
    }
    searchString(s) {
        const res = this.cmdj("/j " + s);
        return res;
    }
    searchBytes(data) {
        function num2hex(data) {
            return (data & 0xff).toString(16);
        }
        const s = data.map(num2hex).join("");
        const res = this.cmdj("/xj " + s);
        return res;
    }
    binInfo() {
        try {
            return this.cmdj("ij~{bin}");
        }
        catch (e) {
            return {};
        }
    }
    // TODO: take a BinFile as argument instead of number
    selectBinary(id) {
        this.call(`ob ${id}`);
    }
    openFile(name) {
        const ofd = this.call("oqq");
        this.call(`o ${name}`);
        const nfd = this.call("oqq");
        if (ofd.trim() === nfd.trim()) {
            return new Error("Cannot open file");
        }
        return parseInt(nfd);
    }
    openFileNomap(name) {
        const ofd = this.call("oqq");
        this.call(`of ${name}`);
        const nfd = this.call("oqq");
        if (ofd.trim() === nfd.trim()) {
            return new Error("Cannot open file");
        }
        return parseInt(nfd);
    }
    currentFile(name) {
        return (this.call("o.")).trim();
    }
    enumeratePlugins(type) {
        switch (type) {
            case "bin":
                return this.callj("Lij");
            case "io":
                return this.callj("Loj");
            case "core":
                return this.callj("Lcj");
            case "arch":
                return this.callj("LAj");
            case "anal":
                return this.callj("Laj");
            case "lang":
                return this.callj("Llj");
        }
        return [];
    }
    enumerateModules() {
        return this.callj("dmmj");
    }
    enumerateFiles() {
        return this.callj("oj");
    }
    enumerateBinaries() {
        return this.callj("obj");
    }
    enumerateMaps() {
        return this.callj("omj");
    }
    enumerateClasses() {
        return this.callj("icj");
    }
    enumerateSymbols() {
        return this.callj("isj");
    }
    enumerateExports() {
        return this.callj("iEj");
    }
    enumerateImports() {
        return this.callj("iij");
    }
    enumerateLibraries() {
        return this.callj("ilj");
    }
    enumerateSections() {
        return this.callj("iSj");
    }
    enumerateSegments() {
        return this.callj("iSSj");
    }
    enumerateEntrypoints() {
        return this.callj("iej");
    }
    enumerateRelocations() {
        return this.callj("irj");
    }
    enumerateFunctions() {
        return this.cmdj("aflj");
    }
    enumerateFlags() {
        return this.cmdj("fj");
    }
    skip() {
        this.r2.cmd("dss");
    }
    ptr(s) {
        return new NativePointer(s, this);
    }
    call(s) {
        return this.r2.call(s);
    }
    callj(s) {
        return JSON.parse(this.call(s));
    }
    cmd(s) {
        return this.r2.cmd(s);
    }
    cmdj(s) {
        return JSON.parse(this.cmd(s));
    }
    log(s) {
        return this.r2.log(s);
    }
    clippy(msg) {
        this.r2.log(this.r2.cmd("?E " + msg));
    }
    ascii(msg) {
        this.r2.log(this.r2.cmd("?ea " + msg));
    }
}
exports.R2PapiSync = R2PapiSync;
// useful to call functions via dxc and to define and describe function signatures
class NativeFunction {
    constructor() { }
}
exports.NativeFunction = NativeFunction;
// uhm not sure how to map this into r2 yet
class NativeCallback {
    constructor() { }
}
exports.NativeCallback = NativeCallback;
/**
 * Class providing a way to work with 64bit pointers from Javascript, this API mimics the same
 * well-known promitive available in Frida, but it's baked by the current session of r2.
 *
 * It is also possible to use this class via the global `ptr` function.
 *
 * @typedef NativePointer
 */
class NativePointer {
    constructor(s, api) {
        this.api = api ?? exports.R;
        this.addr = ("" + s).trim();
    }
    /**
     * Filter a string to be used as a valid flag name
     *
     * @param {string} name of the symbol name
     * @returns {string} filtered name to be used as a flag
     */
    filterFlag(name) {
        return this.api.call(`fD ${name}`);
    }
    /**
     * Set a flag (name) at the offset pointed
     *
     * @param {string} name of the flag to set
     * @returns {string} base64 decoded string
     */
    setFlag(name) {
        this.api.call(`f ${name}=${this.addr}`);
    }
    /**
     * Remove the flag in the current offset
     *
     */
    unsetFlag() {
        this.api.call(`f-${this.addr}`);
    }
    /**
     * Render an hexadecimal dump of the bytes contained in the range starting
     * in the current pointer and given length.
     *
     * @param {number} length optional amount of bytes to dump, using blocksize
     * @returns {string} string containing the hexadecimal dump of memory
     */
    hexdump(length) {
        const len = length === undefined ? "" : "" + length;
        return this.api.cmd(`x${len}@${this.addr}`);
    }
    functionGraph(format) {
        if (format === "dot") {
            return this.api.cmd(`agfd@ ${this.addr}`);
        }
        if (format === "json") {
            return this.api.cmd(`agfj@${this.addr}`);
        }
        if (format === "mermaid") {
            return this.api.cmd(`agfm@${this.addr}`);
        }
        return this.api.cmd(`agf@${this.addr}`);
    }
    readByteArray(len) {
        return JSON.parse(this.api.cmd(`p8j ${len}@${this.addr}`));
    }
    readHexString(len) {
        return (this.api.cmd(`p8 ${len}@${this.addr}`)).trim();
    }
    and(a) {
        const addr = this.api.call(`?v ${this.addr} & ${a}`);
        return new NativePointer(addr.trim());
    }
    or(a) {
        const addr = this.api.call(`?v ${this.addr} | ${a}`);
        return new NativePointer(addr.trim());
    }
    add(a) {
        const addr = this.api.call(`?v ${this.addr}+${a}`);
        return new NativePointer(addr);
    }
    sub(a) {
        const addr = this.api.call(`?v ${this.addr}-${a}`);
        return new NativePointer(addr);
    }
    writeByteArray(data) {
        this.api.cmd("wx " + data.join(""));
        return this;
    }
    writeAssembly(instruction) {
        this.api.cmd(`wa ${instruction} @ ${this.addr}`);
        return this;
    }
    writeCString(s) {
        this.api.call("w " + s);
        return this;
    }
    writeWideString(s) {
        this.api.call("ww " + s);
        return this;
    }
    /**
     * Check if it's a pointer to the address zero. Also known as null pointer.
     *
     * @returns {boolean} true if null
     */
    isNull() {
        return (this.toNumber()) == 0;
    }
    /**
     * Compare current pointer with the passed one, and return -1, 0 or 1.
     *
     * * if (this < arg) return -1;
     * * if (this > arg) return 1;
     * * if (this == arg) return 0;
     *
     * @returns {number} returns -1, 0 or 1 depending on the comparison of the pointers
     */
    compare(a) {
        const bv = typeof a === "string" || typeof a === "number"
            ? new NativePointer(a)
            : a;
        const dist = r2pipe_js_1.r2.call(`?vi ${this.addr} - ${bv.addr}`);
        if (dist[0] === "-") {
            return -1;
        }
        if (dist[0] === "0") {
            return 0;
        }
        return 1;
    }
    /**
     * Check if it's a pointer to the address zero. Also known as null pointer.
     *
     * @returns {boolean} true if null
     */
    pointsToNull() {
        const value = this.readPointer();
        return (value.compare(0)) == 0;
    }
    toJSON() {
        const output = this.api.cmd("?vi " + this.addr.trim());
        return output.trim();
    }
    toString() {
        return (this.api.cmd("?v " + this.addr.trim())).trim();
    }
    toNumber() {
        return parseInt(this.toString());
    }
    writePointer(p) {
    }
    readRelativePointer() {
        return this.add(this.readS32());
    }
    readPointer() {
        const address = this.api.call("pvp@" + this.addr);
        return new NativePointer(address);
    }
    readS8() {
        return parseInt(this.api.cmd(`pv1d@${this.addr}`));
    }
    readU8() {
        return parseInt(this.api.cmd(`pv1u@${this.addr}`));
    }
    readU16() {
        return parseInt(this.api.cmd(`pv2d@${this.addr}`));
    }
    readU16le() {
    }
    readU16be() {
    }
    readS16() {
    }
    readS16le() {
    }
    readS16be() {
    }
    readS32() {
        // same as readInt32()
    }
    readU32() {
    }
    readU32le() {
    }
    readU32be() {
    }
    readU64() {
        // XXX: use bignum or string here
        return parseInt(this.api.cmd(`pv8u@${this.addr}`));
    }
    readU64le() {
    }
    readU64be() {
    }
    writeInt(n) {
        return this.writeU32(n);
    }
    /**
     * Write a byte in the current offset, the value must be between 0 and 255
     *
     * @param {string} n number to write in the pointed byte in the current address
     * @returns {boolean} false if the operation failed
     */
    writeU8(n) {
        this.api.cmd(`wv1 ${n}@${this.addr}`);
        return true;
    }
    writeU16(n) {
        this.api.cmd(`wv2 ${n}@${this.addr}`);
        return true;
    }
    writeU16be(n) {
        this.api.cmd(`wv2 ${n}@${this.addr}@e:cfg.bigendian=true`);
        return true;
    }
    writeU16le(n) {
        this.api.cmd(`wv2 ${n}@${this.addr}@e:cfg.bigendian=false`);
        return true;
    }
    writeU32(n) {
        this.api.cmd(`wv4 ${n}@${this.addr}`);
        return true;
    }
    writeU32be(n) {
        this.api.cmd(`wv4 ${n}@${this.addr}@e:cfg.bigendian=true`);
        return true;
    }
    writeU32le(n) {
        this.api.cmd(`wv4 ${n}@${this.addr}@e:cfg.bigendian=false`);
        return true;
    }
    writeU64(n) {
        this.api.cmd(`wv8 ${n}@${this.addr}`);
        return true;
    }
    writeU64be(n) {
        this.api.cmd(`wv8 ${n}@${this.addr}@e:cfg.bigendian=true`);
        return true;
    }
    writeU64le(n) {
        this.api.cmd(`wv8 ${n}@${this.addr}@e:cfg.bigendian=false`);
        return true;
    }
    readInt32() {
        return this.readU32();
    }
    readCString() {
        const output = this.api.cmd(`pszj@${this.addr}`);
        return JSON.parse(output).string;
    }
    readWideString() {
        const output = this.api.cmd(`pswj@${this.addr}`);
        return JSON.parse(output).string;
    }
    readPascalString() {
        const output = this.api.cmd(`pspj@${this.addr}`);
        return JSON.parse(output).string;
    }
    instruction() {
        const output = this.api.cmdj(`aoj@${this.addr}`);
        return output[0];
    }
    disassemble(length) {
        const len = length === undefined ? "" : "" + length;
        return this.api.cmd(`pd ${len}@${this.addr}`);
    }
    analyzeFunction() {
        this.api.cmd("af@" + this.addr);
        return this;
    }
    analyzeFunctionRecursively() {
        this.api.cmd("afr@" + this.addr);
        return this;
    }
    name() {
        return (this.api.cmd("fd " + this.addr)).trim();
    }
    methodName() {
        // TODO: @ should be optional here, as addr should be passable as argument imho
        return (this.api.cmd("ic.@" + this.addr)).trim();
    }
    symbolName() {
        // TODO: @ should be optional here, as addr should be passable as argument imho
        const name = this.api.cmd("isj.@" + this.addr);
        return name.trim();
    }
    getFunction() {
        return this.api.cmdj("afij@" + this.addr);
    }
    basicBlock() {
        return this.api.cmdj("abj@" + this.addr);
    }
    functionBasicBlocks() {
        return this.api.cmdj("afbj@" + this.addr);
    }
    xrefs() {
        return this.api.cmdj("axtj@" + this.addr);
    }
}
exports.NativePointer = NativePointer;
var R2Papi=R2PapiSync;
