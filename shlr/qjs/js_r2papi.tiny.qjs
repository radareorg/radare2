var G={};
Object.defineProperty(G, "__esModule", { value: true });
G.Base64 = G.EsilParser = G.EsilNode = G.ThreadClass = G.NativePointer = G.R = G.R2AI = void 0;
var ai_js_1 = G;//"./ai.js");
Object.defineProperty(G, "R2AI", { enumerable: true, get: function () { return ai_js_1.R2AI; } });
var r2papi_js_1 = G;//"./r2papi.js");
Object.defineProperty(G, "R", { enumerable: true, get: function () { return r2papi_js_1.R; } });
Object.defineProperty(G, "NativePointer", { enumerable: true, get: function () { return r2papi_js_1.NativePointer; } });
Object.defineProperty(G, "ThreadClass", { enumerable: true, get: function () { return r2papi_js_1.ThreadClass; } });
var esil_js_1 = G;//"./esil.js");
Object.defineProperty(G, "EsilNode", { enumerable: true, get: function () { return esil_js_1.EsilNode; } });
Object.defineProperty(G, "EsilParser", { enumerable: true, get: function () { return esil_js_1.EsilParser; } });
var base64_js_1 = G;//"./base64.js");
Object.defineProperty(G, "Base64", { enumerable: true, get: function () { return base64_js_1.Base64; } });
// main r2papi file
Object.defineProperty(G, "__esModule", { value: true });
G.NativePointer = G.NativeCallback = G.NativeFunction = G.R2PapiSync = G.Assembler = G.ProcessClass = G.ModuleClass = G.ThreadClass = void 0;
const shell_js_1 = G;//"./shell.js");
class ThreadClass {
 constructor(r2) {
 this.api = null;
 this.api = r2;
 }
 backtrace() {
 return r2pipe_js_1.r2.call("dbtj");
 }
 sleep(seconds) {
 return r2pipe_js_1.r2.call("sleep " + seconds);
 }
}
G.ThreadClass = ThreadClass;
class ModuleClass {
 constructor(r2) {
 this.api = null;
 this.api = r2;
 }
 fileName() {
 return this.api.call("dpe").trim();
 }
 name() {
 return "Module";
 }
 findBaseAddress() {
 return "TODO";
 }
 getBaseAddress(name) {
 return "TODO";
 }
 getExportByName(name) {
 const res = r2pipe_js_1.r2.call("iE,name/eq/" + name + ",vaddr/cols,:quiet");
 return ptr(res);
 }
 findExportByName(name) {
 return this.getExportByName(name);
 }
 enumerateExports() {
 // TODO: adjust to be the same output as Frida
 return r2pipe_js_1.r2.callj("iEj");
 }
 enumerateImports() {
 // TODO: adjust to be the same output as Frida
 return r2pipe_js_1.r2.callj("iij");
 }
 enumerateSymbols() {
 // TODO: adjust to be the same output as Frida
 return r2pipe_js_1.r2.callj("isj");
 }
 enumerateEntrypoints() {
 // TODO: adjust to be the same output as Frida
 return r2pipe_js_1.r2.callj("iej");
 }
 enumerateRanges() {
 // TODO: adjust to be the same output as Frida
 return r2pipe_js_1.r2.callj("omj");
 }
}
G.ModuleClass = ModuleClass;
class ProcessClass {
 constructor(r2) {
 this.r2 = null;
 this.r2 = r2;
 }
 enumerateMallocRanges() { }
 enumerateSystemRanges() { }
 enumerateRanges() { }
 enumerateThreads() {
 return r2pipe_js_1.r2.callj("dptj");
 }
 enumerateModules() {
 r2pipe_js_1.r2.call("cfg.json.num=string"); // to handle 64bit values properly
 if (r2pipe_js_1.r2.callj("e cfg.debug")) {
 const modules = r2pipe_js_1.r2.callj("dmmj");
 const res = [];
 for (const mod of modules) {
 const entry = {
 base: new NativePointer(mod.addr),
 size: new NativePointer(mod.addr_end).sub(mod.addr),
 path: mod.file,
 name: mod.name
 };
 res.push(entry);
 }
 return res;
 }
 else {
 const fname = (x) => {
 const y = x.split("/");
 return y[y.length - 1];
 };
 const bobjs = r2pipe_js_1.r2.callj("obj");
 const res = [];
 for (const obj of bobjs) {
 const entry = {
 base: new NativePointer(obj.addr),
 size: obj.size,
 path: obj.file,
 name: fname(obj.file)
 };
 res.push(entry);
 }
 const libs = r2pipe_js_1.r2.callj("ilj");
 for (const lib of libs) {
 const entry = {
 base: 0,
 size: 0,
 path: lib,
 name: fname(lib)
 };
 res.push(entry);
 }
 return res;
 }
 }
 getModuleByAddress(addr) { }
 getModuleByName(moduleName) { }
 codeSigningPolicy() {
 return "optional";
 }
 getTmpDir() {
 return this.r2.call("e dir.tmp").trim();
 }
 getHomeDir() {
 return this.r2.call("e dir.home").trim();
 }
 platform() {
 return this.r2.call("e asm.os").trim();
 }
 getCurrentDir() {
 return this.r2.call("pwd").trim();
 }
 getCurrentThreadId() {
 return +this.r2.call("dpq");
 }
 pageSize() {
 if (this.r2.callj("e asm.bits") === 64 &&
 this.r2.call("e asm.arch").startsWith("arm")) {
 return 16384;
 }
 return 4096;
 }
 isDebuggerAttached() {
 return this.r2.callj("e cfg.debug");
 }
 setExceptionHandler() {
 // do nothing
 }
 id() {
 //
 return this.r2.callj("dpq").trim();
 }
 pointerSize() {
 return r2pipe_js_1.r2.callj("e asm.bits") / 8;
 }
}
G.ProcessClass = ProcessClass;
/**
 * Assembler and disassembler facilities to decode and encode instructions
 *
 * @typedef Assembler
 */
class Assembler {
 constructor(myr2) {
 this.program = "";
 this.labels = {};
 this.endian = false;
 this.pc = ptr(0);
 if (myr2 === undefined) {
 this.r2 = (0, r2pipe_js_1.newAsyncR2PipeFromSync)(r2pipe_js_1.r2);
 }
 else {
 this.r2 = myr2;
 }
 this.program = "";
 this.labels = {};
 }
 /**
 * Change the address of the program counter, some instructions need to know where
 * are they located before being encoded or decoded.
 *
 * @param {NativePointerValue}
 */
 setProgramCounter(pc) {
 this.pc = pc;
 }
 setEndian(big) {
 this.endian = big;
 }
 toString() {
 return this.program;
 }
 append(x) {
 // append text
 this.pc = this.pc.add(x.length / 2);
 this.program += x;
 }
 // api
 label(s) {
 const pos = this.pc; // this.#program.length / 4;
 this.labels[s] = this.pc;
 return pos;
 }
 /**
 * Encode (assemble) an instruction by taking the string representation.
 *
 * @param {string} the string representation of the instruction to assemble
 * @returns {string} the hexpairs that represent the assembled instruciton
 */
 encode(s) {
 const output = this.r2.call(`pa ${s}`);
 return output.trim();
 }
 /**
 * Decode (disassemble) an instruction by taking the hexpairs string as input.
 * TODO: should take an array of bytes too
 *
 * @param {string} the hexadecimal pairs of bytes to decode as an instruction
 * @returns {string} the mnemonic and operands of the resulting decoding
 */
 decode(s) {
 const output = this.r2.call(`pad ${s}`);
 return output.trim();
 }
}
G.Assembler = Assembler;
/**
 * High level abstraction on top of the r2 command interface provided by r2pipe.
 *
 * @typedef R2Papi
 */
class R2PapiSync {
 /**
 * Create a new instance of the R2Papi class, taking an r2pipe interface as reference.
 *
 * @param {R2PipeSync} the r2pipe instance to use as backend.
 * @returns {R2Papi} instance
 */
 constructor(r2) {
 this.r2 = r2;
 }
 toString() {
 return "[object R2Papi]";
 }
 toJSON() {
 return this.toString();
 }
 /**
 * Get the base address used by the current loaded binary
 *
 * @returns {NativePointer} address of the base of the binary
 */
 getBaseAddress() {
 return new NativePointer(this.cmd("e bin.baddr"));
 }
 jsonToTypescript(name, a) {
 let str = `interface ${name} {\n`;
 if (a.length && a.length > 0) {
 a = a[0];
 }
 for (const k of Object.keys(a)) {
 const typ = typeof a[k];
 const nam = k;
 str += ` ${nam}: ${typ};\n`;
 }
 return `${str}}\n`;
 }
 /**
 * Get the general purpose register size of the targize architecture in bits
 *
 * @returns {number} the regsize
 */
 getBits() {
 return +this.cmd("-b");
 }
 /**
 * Get the name of the arch plugin selected, which tends to be the same target architecture.
 * Note that on some situations, this info will be stored protected bby the AirForce.
 * When using the r2ghidra arch plugin the underlying arch is in `asm.cpu`:
 *
 * @returns {string} the name of the target architecture.
 */
 getArch() {
 return this.cmdTrim("-a");
 }
 callTrim(x) {
 const res = this.call(x);
 return res.trim();
 }
 cmdTrim(x) {
 const res = this.cmd(x);
 return res.trim();
 }
 /**
 * Get the name of the selected CPU for the current selected architecture.
 *
 * @returns {string} the value of asm.cpu
 */
 getCpu() {
 // return this.cmd('-c');
 return this.cmdTrim("-e asm.cpu"); // use arch.cpu
 }
 // TODO: setEndian, setCpu, ...
 setArch(arch, bits) {
 this.cmd("-a " + arch);
 if (bits !== undefined) {
 this.cmd("-b " + bits);
 }
 }
 setFlagSpace(name) {
 this.cmd("fs " + name);
 }
 demangleSymbol(lang, mangledName) {
 return this.cmdTrim("iD " + lang + " " + mangledName);
 }
 setLogLevel(level) {
 this.cmd("e log.level=" + level);
 }
 /**
 * should return the id for the new map using the given file descriptor
 */
 // rename to createMap or mapFile?
 newMap(fd, vaddr, size, paddr, perm, name = "") {
 this.cmd(`om ${fd} ${vaddr} ${size} ${paddr} ${perm} ${name}`);
 }
 at(a) {
 return new NativePointer(a);
 }
 getShell() {
 return new shell_js_1.R2Shell(this);
 }
 // Radare/Frida
 version() {
 const v = this.r2.cmd("?Vq");
 return v.trim();
 }
 // Process
 platform() {
 const output = this.r2.cmd("uname");
 return output.trim();
 }
 arch() {
 const output = this.r2.cmd("uname -a");
 return output.trim();
 }
 bits() {
 const output = this.r2.cmd("uname -b");
 return output.trim();
 }
 id() {
 // getpid();
 return +this.r2.cmd("?vi:$p");
 }
 // Other stuff
 printAt(msg, x, y) {
 // see pg, but pg is obrken :D
 }
 clearScreen() {
 this.r2.cmd("!clear");
 return this;
 }
 getConfig(key) {
 if (key === "") {
 return new Error("Empty key");
 }
 const exist = this.r2.cmd(`e~^${key} =`);
 if (exist.trim() === "") {
 return new Error("Config key does not exist");
 }
 const value = this.r2.call("e " + key);
 return value.trim();
 }
 setConfig(key, val) {
 this.r2.call("e " + key + "=" + val);
 return this;
 }
 getRegisterStateForEsil() {
 const dre = this.cmdj("dre");
 return this.cmdj("dre");
 }
 getRegisters() {
 // this.r2.log("winrar" + JSON.stringify(JSON.parse(this.r2.cmd("drj")),null, 2) );
 return this.cmdj("drj");
 }
 resizeFile(newSize) {
 this.cmd(`r ${newSize}`);
 return this;
 }
 insertNullBytes(newSize, at) {
 if (at === undefined) {
 at = "$$";
 }
 this.cmd(`r+${newSize}@${at}`);
 return this;
 }
 removeBytes(newSize, at) {
 if (at === undefined) {
 at = "$$";
 }
 this.cmd(`r-${newSize}@${at}`);
 return this;
 }
 seek(addr) {
 this.cmd(`s ${addr}`);
 return this;
 }
 currentSeek() {
 return new NativePointer("$$");
 }
 seekToRelativeOpcode(nth) {
 this.cmd(`so ${nth}`);
 return this.currentSeek();
 }
 getBlockSize() {
 return +this.cmd("b");
 }
 setBlockSize(a) {
 this.cmd(`b ${a}`);
 return this;
 }
 countFlags() {
 return Number(this.cmd("f~?"));
 }
 countFunctions() {
 return Number(this.cmd("aflc"));
 }
 analyzeFunctionsWithEsil(depth) {
 this.cmd("aaef");
 }
 analyzeProgramWithEsil(depth) {
 this.cmd("aae");
 }
 analyzeProgram(depth) {
 if (depth === undefined) {
 depth = 0;
 }
 switch (depth) {
 case 0:
 this.cmd("aa");
 break;
 case 1:
 this.cmd("aaa");
 break;
 case 2:
 this.cmd("aaaa");
 break;
 case 3:
 this.cmd("aaaaa");
 break;
 }
 return this;
 }
 enumerateThreads() {
 // TODO: use apt/dpt to list threads at iterate over them to get the registers
 const regs0 = this.cmdj("drj");
 const thread0 = {
 context: regs0,
 id: 0,
 state: "waiting",
 selected: true
 };
 return [thread0];
 }
 currentThreadId() {
 if (+this.cmd("e cfg.debug")) {
 return +this.cmd("dpt.");
 }
 return this.id();
 }
 setRegisters(obj) {
 for (const r of Object.keys(obj)) {
 const v = obj[r];
 this.r2.cmd("dr " + r + "=" + v);
 }
 }
 hex(s) {
 const output = this.r2.cmd("?v " + s);
 return output.trim();
 }
 step() {
 this.r2.cmd("ds");
 return this;
 }
 stepOver() {
 this.r2.cmd("dso");
 return this;
 }
 math(expr) {
 return +this.r2.cmd("?v " + expr);
 }
 stepUntil(dst) {
 this.cmd(`dsu ${dst}`);
 }
 enumerateXrefsTo(s) {
 const output = this.call("axtq " + s);
 return output.trim().split(/\n/);
 }
 // TODO: rename to searchXrefsTo ?
 findXrefsTo(s, use_esil) {
 if (use_esil) {
 this.call("/r " + s);
 }
 else {
 this.call("/re " + s);
 }
 }
 analyzeFunctionsFromCalls() {
 this.call("aac");
 return this;
 }
 autonameAllFunctions() {
 this.call("aan");
 return this;
 }
 analyzeFunctionsWithPreludes() {
 this.call("aap");
 return this;
 }
 analyzeObjCReferences() {
 this.cmd("aao");
 return this;
 }
 analyzeImports() {
 this.cmd("af @ sym.imp.*");
 return this;
 }
 searchDisasm(s) {
 const res = this.callj("/ad " + s);
 return res;
 }
 searchString(s) {
 const res = this.cmdj("/j " + s);
 return res;
 }
 searchBytes(data) {
 function num2hex(data) {
 return (data & 0xff).toString(16);
 }
 const s = data.map(num2hex).join("");
 const res = this.cmdj("/xj " + s);
 return res;
 }
 binInfo() {
 try {
 return this.cmdj("ij~{bin}");
 }
 catch (e) {
 return {};
 }
 }
 // TODO: take a BinFile as argument instead of number
 selectBinary(id) {
 this.call(`ob ${id}`);
 }
 openFile(name) {
 const ofd = this.call("oqq");
 this.call(`o ${name}`);
 const nfd = this.call("oqq");
 if (ofd.trim() === nfd.trim()) {
 return new Error("Cannot open file");
 }
 return parseInt(nfd);
 }
 openFileNomap(name) {
 const ofd = this.call("oqq");
 this.call(`of ${name}`);
 const nfd = this.call("oqq");
 if (ofd.trim() === nfd.trim()) {
 return new Error("Cannot open file");
 }
 return parseInt(nfd);
 }
 currentFile(name) {
 return (this.call("o.")).trim();
 }
 enumeratePlugins(type) {
 switch (type) {
 case "bin":
 return this.callj("Lij");
 case "io":
 return this.callj("Loj");
 case "core":
 return this.callj("Lcj");
 case "arch":
 return this.callj("LAj");
 case "anal":
 return this.callj("Laj");
 case "lang":
 return this.callj("Llj");
 }
 return [];
 }
 enumerateModules() {
 return this.callj("dmmj");
 }
 enumerateFiles() {
 return this.callj("oj");
 }
 enumerateBinaries() {
 return this.callj("obj");
 }
 enumerateMaps() {
 return this.callj("omj");
 }
 enumerateClasses() {
 return this.callj("icj");
 }
 enumerateSymbols() {
 return this.callj("isj");
 }
 enumerateExports() {
 return this.callj("iEj");
 }
 enumerateImports() {
 return this.callj("iij");
 }
 enumerateLibraries() {
 return this.callj("ilj");
 }
 enumerateSections() {
 return this.callj("iSj");
 }
 enumerateSegments() {
 return this.callj("iSSj");
 }
 enumerateEntrypoints() {
 return this.callj("iej");
 }
 enumerateRelocations() {
 return this.callj("irj");
 }
 enumerateFunctions() {
 return this.cmdj("aflj");
 }
 enumerateFlags() {
 return this.cmdj("fj");
 }
 skip() {
 this.r2.cmd("dss");
 }
 ptr(s) {
 return new NativePointer(s, this);
 }
 call(s) {
 return this.r2.call(s);
 }
 callj(s) {
 return JSON.parse(this.call(s));
 }
 cmd(s) {
 return this.r2.cmd(s);
 }
 cmdj(s) {
 return JSON.parse(this.cmd(s));
 }
 log(s) {
 return this.r2.log(s);
 }
 clippy(msg) {
 this.r2.log(this.r2.cmd("?E " + msg));
 }
 ascii(msg) {
 this.r2.log(this.r2.cmd("?ea " + msg));
 }
}
G.R2PapiSync = R2PapiSync;
// useful to call functions via dxc and to define and describe function signatures
class NativeFunction {
 constructor() { }
}
G.NativeFunction = NativeFunction;
// uhm not sure how to map this into r2 yet
class NativeCallback {
 constructor() { }
}
G.NativeCallback = NativeCallback;
/**
 * Class providing a way to work with 64bit pointers from Javascript, this API mimics the same
 * well-known promitive available in Frida, but it's baked by the current session of r2.
 *
 * It is also possible to use this class via the global `ptr` function.
 *
 * @typedef NativePointer
 */
class NativePointer {
 constructor(s, api) {
 if (api === undefined) {
 this.api = G.R;
 }
 else {
 this.api = api;
 }
 // this.api.r2.log("NP " + s);
 this.addr = ("" + s).trim();
 }
 /**
 * Filter a string to be used as a valid flag name
 *
 * @param {string} name of the symbol name
 * @returns {string} filtered name to be used as a flag
 */
 filterFlag(name) {
 return this.api.call(`fD ${name}`);
 }
 /**
 * Set a flag (name) at the offset pointed
 *
 * @param {string} name of the flag to set
 * @returns {string} base64 decoded string
 */
 setFlag(name) {
 this.api.call(`f ${name}=${this.addr}`);
 }
 /**
 * Remove the flag in the current offset
 *
 */
 unsetFlag() {
 this.api.call(`f-${this.addr}`);
 }
 /**
 * Render an hexadecimal dump of the bytes contained in the range starting
 * in the current pointer and given length.
 *
 * @param {number} length optional amount of bytes to dump, using blocksize
 * @returns {string} string containing the hexadecimal dump of memory
 */
 hexdump(length) {
 const len = length === undefined ? "" : "" + length;
 return this.api.cmd(`x${len}@${this.addr}`);
 }
 functionGraph(format) {
 if (format === "dot") {
 return this.api.cmd(`agfd@ ${this.addr}`);
 }
 if (format === "json") {
 return this.api.cmd(`agfj@${this.addr}`);
 }
 if (format === "mermaid") {
 return this.api.cmd(`agfm@${this.addr}`);
 }
 return this.api.cmd(`agf@${this.addr}`);
 }
 readByteArray(len) {
 return JSON.parse(this.api.cmd(`p8j ${len}@${this.addr}`));
 }
 readHexString(len) {
 return (this.api.cmd(`p8 ${len}@${this.addr}`)).trim();
 }
 and(a) {
 const addr = this.api.call(`?v ${this.addr} & ${a}`);
 return new NativePointer(addr.trim());
 }
 or(a) {
 const addr = this.api.call(`?v ${this.addr} | ${a}`);
 return new NativePointer(addr.trim());
 }
 add(a) {
 const addr = this.api.call(`?v ${this.addr}+${a}`);
 return new NativePointer(addr);
 }
 sub(a) {
 const addr = this.api.call(`?v ${this.addr}-${a}`);
 return new NativePointer(addr);
 }
 writeByteArray(data) {
 this.api.cmd("wx " + data.join(""));
 return this;
 }
 writeAssembly(instruction) {
 this.api.cmd(`wa ${instruction} @ ${this.addr}`);
 return this;
 }
 writeCString(s) {
 this.api.call("w " + s);
 return this;
 }
 writeWideString(s) {
 this.api.call("ww " + s);
 return this;
 }
 /**
 * Check if it's a pointer to the address zero. Also known as null pointer.
 *
 * @returns {boolean} true if null
 */
 isNull() {
 return (this.toNumber()) == 0;
 }
 /**
 * Compare current pointer with the passed one, and return -1, 0 or 1.
 *
 * * if (this < arg) return -1;
 * * if (this > arg) return 1;
 * * if (this == arg) return 0;
 *
 * @returns {number} returns -1, 0 or 1 depending on the comparison of the pointers
 */
 compare(a) {
 const bv = typeof a === "string" || typeof a === "number"
 ? new NativePointer(a)
 : a;
 const dist = r2pipe_js_1.r2.call(`?vi ${this.addr} - ${bv.addr}`);
 if (dist[0] === "-") {
 return -1;
 }
 if (dist[0] === "0") {
 return 0;
 }
 return 1;
 }
 /**
 * Check if it's a pointer to the address zero. Also known as null pointer.
 *
 * @returns {boolean} true if null
 */
 pointsToNull() {
 const value = this.readPointer();
 return (value.compare(0)) == 0;
 }
 toJSON() {
 const output = this.api.cmd("?vi " + this.addr.trim());
 return output.trim();
 }
 toString() {
 return (this.api.cmd("?v " + this.addr.trim())).trim();
 }
 toNumber() {
 return parseInt(this.toString());
 }
 writePointer(p) {
 this.api.cmd(`wvp ${p}@${this}`); // requires 5.8.2
 }
 readRelativePointer() {
 return this.add(this.readS32());
 }
 readPointer() {
 const address = this.api.call("pvp@" + this.addr);
 return new NativePointer(address);
 }
 readS8() {
 // requires 5.8.9
 return parseInt(this.api.cmd(`pv1d@${this.addr}`));
 }
 readU8() {
 return parseInt(this.api.cmd(`pv1u@${this.addr}`));
 }
 readU16() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}`));
 }
 readU16le() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}@e:cfg.bigendian=false`)); // requires 5.8.9
 }
 readU16be() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}@e:cfg.bigendian=true`)); // requires 5.8.9
 }
 readS16() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}`)); // requires 5.8.9
 }
 readS16le() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}@e:cfg.bigendian=false`)); // requires 5.8.9
 }
 readS16be() {
 return parseInt(this.api.cmd(`pv2d@${this.addr}@e:cfg.bigendian=true`)); // requires 5.8.9
 }
 readS32() {
 // same as readInt32()
 return parseInt(this.api.cmd(`pv4d@${this.addr}`)); // requires 5.8.9
 }
 readU32() {
 return parseInt(this.api.cmd(`pv4u@${this.addr}`)); // requires 5.8.9
 }
 readU32le() {
 return parseInt(this.api.cmd(`pv4u@${this.addr}@e:cfg.bigendian=false`)); // requires 5.8.9
 }
 readU32be() {
 return parseInt(this.api.cmd(`pv4u@${this.addr}@e:cfg.bigendian=true`)); // requires 5.8.9
 }
 readU64() {
 // XXX: use bignum or string here
 return parseInt(this.api.cmd(`pv8u@${this.addr}`));
 }
 readU64le() {
 return parseInt(this.api.cmd(`pv8u@${this.addr}@e:cfg.bigendian=false`)); // requires 5.8.9
 }
 readU64be() {
 return parseInt(this.api.cmd(`pv8u@${this.addr}@e:cfg.bigendian=true`)); // requires 5.8.9
 }
 writeInt(n) {
 return this.writeU32(n);
 }
 /**
 * Write a byte in the current offset, the value must be between 0 and 255
 *
 * @param {string} n number to write in the pointed byte in the current address
 * @returns {boolean} false if the operation failed
 */
 writeU8(n) {
 this.api.cmd(`wv1 ${n}@${this.addr}`);
 return true;
 }
 writeU16(n) {
 this.api.cmd(`wv2 ${n}@${this.addr}`);
 return true;
 }
 writeU16be(n) {
 this.api.cmd(`wv2 ${n}@${this.addr}@e:cfg.bigendian=true`);
 return true;
 }
 writeU16le(n) {
 this.api.cmd(`wv2 ${n}@${this.addr}@e:cfg.bigendian=false`);
 return true;
 }
 writeU32(n) {
 this.api.cmd(`wv4 ${n}@${this.addr}`);
 return true;
 }
 writeU32be(n) {
 this.api.cmd(`wv4 ${n}@${this.addr}@e:cfg.bigendian=true`);
 return true;
 }
 writeU32le(n) {
 this.api.cmd(`wv4 ${n}@${this.addr}@e:cfg.bigendian=false`);
 return true;
 }
 writeU64(n) {
 this.api.cmd(`wv8 ${n}@${this.addr}`);
 return true;
 }
 writeU64be(n) {
 this.api.cmd(`wv8 ${n}@${this.addr}@e:cfg.bigendian=true`);
 return true;
 }
 writeU64le(n) {
 this.api.cmd(`wv8 ${n}@${this.addr}@e:cfg.bigendian=false`);
 return true;
 }
 readInt32() {
 return this.readU32();
 }
 readCString() {
 const output = this.api.cmd(`pszj@${this.addr}`);
 return JSON.parse(output).string;
 }
 readWideString() {
 const output = this.api.cmd(`pswj@${this.addr}`);
 return JSON.parse(output).string;
 }
 readPascalString() {
 const output = this.api.cmd(`pspj@${this.addr}`);
 return JSON.parse(output).string;
 }
 instruction() {
 const output = this.api.cmdj(`aoj@${this.addr}`);
 return output[0];
 }
 disassemble(length) {
 const len = length === undefined ? "" : "" + length;
 return this.api.cmd(`pd ${len}@${this.addr}`);
 }
 analyzeFunction() {
 this.api.cmd("af@" + this.addr);
 return this;
 }
 analyzeFunctionRecursively() {
 this.api.cmd("afr@" + this.addr);
 return this;
 }
 name() {
 return (this.api.cmd("fd " + this.addr)).trim();
 }
 methodName() {
 // TODO: @ should be optional here, as addr should be passable as argument imho
 return (this.api.cmd("ic.@" + this.addr)).trim();
 }
 symbolName() {
 // TODO: @ should be optional here, as addr should be passable as argument imho
 const name = this.api.cmd("isj.@" + this.addr);
 return name.trim();
 }
 getFunction() {
 return this.api.cmdj("afij@" + this.addr);
 }
 basicBlock() {
 return this.api.cmdj("abj@" + this.addr);
 }
 functionBasicBlocks() {
 return this.api.cmdj("afbj@" + this.addr);
 }
 xrefs() {
 return this.api.cmdj("axtj@" + this.addr);
 }
}
G.NativePointer = NativePointer;
Object.defineProperty(G, "__esModule", { value: true });
G.newAsyncR2PipeFromSync = G.R2PipeSyncFromSync = void 0;
class R2PipeSyncFromSync {
 constructor(r2p) {
 this.r2p = r2p;
 }
 /**
 * Run a command in the associated instance of radare2 and return the output as a string
 *
 * @param {string} command to be executed inside radare2.
 * @returns {string} The output of the command execution
 */
 cmd(command) {
 return this.r2p.cmd(command);
 }
 cmdAt(command, address) {
 return this.r2p.cmdAt(command, address);
 }
 cmdj(cmd) {
 return this.r2p.cmdj(cmd);
 }
 call(command) {
 return this.r2p.call(command);
 }
 callj(cmd) {
 return this.r2p.cmdj(cmd);
 }
 callAt(command, address) {
 return this.r2p.cmdAt(command, address);
 }
 log(msg) {
 return this.r2p.log(msg);
 }
 plugin(type, maker) {
 return this.r2p.plugin(type, maker);
 }
 unload(type, name) {
 return this.r2p.unload(type, name);
 }
}
G.R2PipeSyncFromSync = R2PipeSyncFromSync;
function newAsyncR2PipeFromSync(r2p) {
 const asyncR2Pipe = new R2PipeSyncFromSync(r2p);
 return asyncR2Pipe;
}
G.newAsyncR2PipeFromSync = newAsyncR2PipeFromSync;
Object.defineProperty(G, "__esModule", { value: true });
G.Base64 = void 0;
class Base64 {
 /**
 * Encode the given input string using base64
 *
 * @param {string} input string to encode
 * @returns {string} base64 encoded string
 */
 static encode(input) {
 return (0, G.b64)(input);
 }
 /**
 * Decode the given base64 string into plain text
 *
 * @param {string} input string encoded in base64 format
 * @returns {string} base64 decoded string
 */
 static decode(input) {
 return (0, G.b64)(input, true);
 }
}
G.Base64 = Base64;
Object.defineProperty(G, "__esModule", { value: true });
G.R2AI = void 0;
/**
 * Class that interacts with the `r2ai` plugin (requires `rlang-python` and `r2i` r2pm packages to be installed).
 * Provides a way to script the interactions with different language models using javascript from inside radare2.
 *
 * @typedef R2AI
 */
class R2AI {
 constructor(r2, num, model) {
 /**
 * Instance variable that informs if the `r2ai` plugin is loaded, must be true in order to use the rest of the methods of this class.
 *
 * @type {boolean}
 */
 this.available = false;
 /**
 * Name of the model instantiated to be used for the subsequent calls.
 *
 * @type {string}
 */
 this.model = "";
 this.r2 = r2;
 this.available = false;
 }
 checkAvailability() {
 if (this.available) {
 return true;
 }
 this.available = r2pipe_js_1.r2.cmd("r2ai -h").trim() !== "";
 /*
 if (this.available) {
 if (num) {
 r2.call(`r2ai -n ${num}`)
 }
 // r2.call('r2ai -e DEBUG=1')
 if (model) {
 this.model = model;
 }
 }
 */
 return this.available;
 }
 /**
 * Reset conversation messages
 */
 reset() {
 this.checkAvailability();
 if (this.available) {
 r2pipe_js_1.r2.call("r2ai -R");
 }
 }
 /**
 * Set the role (system prompt) message for the language model to obey.
 *
 * @param {string} text containing the system prompt
 * @returns {boolean} true if successful
 */
 setRole(msg) {
 if (this.available) {
 r2pipe_js_1.r2.call(`r2ai -r ${msg}`);
 return true;
 }
 return false;
 }
 /**
 * Set the Model name or path to the GGUF file to use.
 *
 * @param {string} model name or path to GGUF file
 * @returns {boolean} true if successful
 */
 setModel(modelName) {
 if (this.available) {
 r2pipe_js_1.r2.call(`r2ai -m ${this.model}`);
 return true;
 }
 return false;
 }
 /**
 * Get the current selected model name.
 *
 * @returns {boolean} model name
 */
 getModel() {
 if (this.available) {
 this.model = r2pipe_js_1.r2.call("r2ai -m").trim();
 }
 return this.model;
 }
 /**
 * Get a list of suggestions for model names to use.
 *
 * @returns {string[]} array of strings containing the model names known to work
 */
 listModels() {
 if (this.available) {
 const models = r2pipe_js_1.r2.call("r2ai -M");
 return models
 .replace(/-m /, "")
 .trim()
 .split(/\n/g)
 .filter((x) => x.indexOf(":") !== -1);
 }
 return [];
 }
 /**
 * Send message to the language model to be appended to the current conversation (see `.reset()`)
 *
 * @param {string} text sent from the user to the language model
 * @returns {string} response from the language model
 */
 query(msg) {
 if (!this.available || msg == "") {
 return "";
 }
 const fmsg = msg.trim().replace(/\n/g, ".");
 const response = r2pipe_js_1.r2.call(`r2ai ${fmsg}`);
 return response.trim();
 }
}
G.R2AI = R2AI;
Object.defineProperty(G, "__esModule", { value: true });
G.R2Frida = void 0;
class R2Frida {
 constructor(r2) {
 this.r2 = r2;
 this.isAvailable = false;
 }
 checkAvailability() {
 if (!this.isAvailable) {
 const output = r2.cmd("o~frida://");
 if (output.trim() === "") {
 throw new Error("There's no frida session available");
 }
 }
 this.isAvailable = true;
 }
 eval(expr) {
 return r2.cmd(`"": ${expr}`);
 }
 targetDetails() {
 return r2.cmdj(":ij");
 }
}
G.R2Frida = R2Frida;
// shell utilities on top of r2pipe
Object.defineProperty(G, "__esModule", { value: true });
G.R2Shell = void 0;
/**
 * Class that interacts with the `r2ai` plugin (requires `rlang-python` and `r2i` r2pm packages to be installed).
 * Provides a way to script the interactions with different language models using javascript from inside radare2.
 *
 * @typedef R2Shell
 */
class R2Shell {
 /**
 * Create a new instance of the R2Shell
 *
 * @param {R2Papi} take the R2Papi intance to used as backend to run the commands
 * @returns {R2Shell} instance of the shell api
 */
 constructor(papi) {
 this.rp = papi;
 }
 /**
 * Create a new directory in the host system, if the opational recursive argument is set to
 * true it will create all the necessary subdirectories instead of just the specified one.
 *
 * @param {string} text path to the new directory to be created
 * @param {boolean?} disabled by default, but if it's true, it will create subdirectories recursively if necessary
 * @returns {boolean} true if successful
 */
 mkdir(file, recursive) {
 if (recursive === true) {
 this.rp.call(`mkdir -p ${file}`);
 }
 else {
 this.rp.call(`mkdir ${file}`);
 }
 return true;
 }
 /**
 * Deletes a file
 *
 * @param {string} path to the file to remove
 * @returns {boolean} true if successful
 */
 unlink(file) {
 this.rp.call(`rm ${file}`);
 return true;
 }
 /**
 * Change current directory
 *
 * @param {string} path to the directory
 * @returns {boolean} true if successful
 */
 chdir(path) {
 this.rp.call(`cd ${path}`);
 return true;
 }
 /**
 * List files in the current directory
 *
 * @returns {string[]} array of file names
 */
 ls() {
 const files = this.rp.call(`ls -q`);
 return files.trim().split("\n");
 }
 /**
 * TODO: Checks if a file exists (not implemented)
 *
 * @returns {boolean} true if the file exists, false if it does not
 */
 fileExists(path) {
 // TODO
 return false;
 }
 /**
 * Opens an URL or application
 * Execute `xdg-open` on linux, `start` on windows, `open` on Mac
 *
 * @param {string} URI or file to open by the system
 */
 open(arg) {
 this.rp.call(`open ${arg}`);
 }
 /**
 * Run a system command and get the return code
 *
 * @param {string} system command to be executed
 * @returns {number} return code (0 is success)
 */
 system(cmd) {
 this.rp.call(`!${cmd}`);
 return 0;
 }
 /**
 * Mount the given offset on the specified path using the filesytem.
 * This is not a system-level mountpoint, it's using the internal filesystem abstraction of radare2.
 *
 * @param {string} filesystem type name (see .
 * @param {string} system command to be executed
 * @param {string|number}
 * @returns {number} return code (0 is success)
 */
 mount(fstype, path, offset) {
 if (!offset) {
 offset = 0;
 }
 this.rp.call(`m ${fstype} ${path} ${offset}`);
 return true;
 }
 /**
 * Unmount the mountpoint associated with the given path.
 *
 * @param {string} path to the mounted filesystem
 * @returns {void} TODO: should return boolean
 */
 umount(path) {
 this.rp.call(`m-${path}`);
 }
 /**
 * Change current directory on the internal radare2 filesystem
 *
 * @param {string} path name to change to
 * @returns {void} TODO: should return boolean
 */
 chdir2(path) {
 this.rp.call(`mdq ${path}`);
 }
 /**
 * List the files contained in the given path within the virtual radare2 filesystem.
 *
 * @param {string} path name to change to
 * @returns {void} TODO: should return boolean
 */
 ls2(path) {
 const files = this.rp.call(`mdq ${path}`);
 return files.trim().split("\n");
 }
 /**
 * Enumerate all the mountpoints set in the internal virtual filesystem of radare2
 * @returns {any[]} array of mount
 */
 enumerateFilesystemTypes() {
 return this.rp.cmdj("mLj");
 }
 /**
 * Enumerate all the mountpoints set in the internal virtual filesystem of radare2
 * @returns {any[]} array of mount
 */
 enumerateMountpoints() {
 const output = this.rp.cmdj("mj");
 return output["mountpoints"];
 }
 /**
 * TODO: not implemented
 */
 isSymlink(file) {
 return false;
 }
 /**
 * TODO: not implemented
 */
 isDirectory(file) {
 return false;
 }
}
G.R2Shell = R2Shell;
Object.defineProperty(G, "__esModule", { value: true });
G.EsilParser = G.EsilNode = G.EsilToken = void 0;
// ("this is just a comment"), -- comments are also part of the runtime
/*
=("//", {
 =(obj, {}())
 =([obj, comment], 32)
 if(eq([obj,comment], 32),
 ret()
 )
 ret(obj)
})
*/
class EsilToken {
 constructor(text = "", position = 0) {
 this.label = "";
 this.comment = "";
 this.text = "";
 this.addr = "0"; // for ut64 we use strings for numbers :<
 this.position = 0;
 this.text = text;
 this.position = position;
 }
 toString() {
 return this.text;
 }
}
G.EsilToken = EsilToken;
class EsilNode {
 constructor(token = new EsilToken(), type = "none") {
 this.type = "none";
 this.token = token;
 this.children = [];
 }
 setSides(lhs, rhs) {
 this.lhs = lhs;
 this.rhs = rhs;
 }
 addChildren(ths, fhs) {
 if (ths !== undefined) {
 this.children.push(ths);
 }
 if (fhs !== undefined) {
 this.children.push(fhs);
 }
 }
 toEsil() {
 if (this.lhs !== undefined && this.rhs !== undefined) {
 // XXX handle ?{ }{ }
 let left = this.lhs.toEsil();
 if (left !== "") {
 left += ",";
 }
 const right = this.rhs.toEsil();
 return `${right},${left}${this.token}`;
 }
 return ""; // this.token.text;
 }
 toString() {
 let str = "";
 if (this.token.label !== "") {
 str += this.token.label + ":\n";
 }
 if (this.token.addr !== "0") {
 // str += "// @ " + this.token.addr + "\n";
 }
 if (this.token.comment !== "") {
 str += "/*" + this.token.comment + "*/\n";
 }
 if (this.token.toString() === "GOTO") {
 if (this.children.length > 0) {
 const children = this.children[0];
 str += "goto label_" + children.token.position + ";\n";
 }
 else {
 // console.log(JSON.stringify(this,null, 2));
 const pos = 0;
 str += `goto label_${pos};\n`;
 }
 }
 if (this.children.length > 0) {
 str += ` (if (${this.rhs})\n`;
 for (const children of this.children) {
 if (children !== null) {
 const x = children.toString();
 if (x != "") {
 str += ` ${x}\n`;
 }
 }
 }
 str += " )\n";
 }
 if (this.lhs !== undefined && this.rhs !== undefined) {
 return str + ` ( ${this.lhs} ${this.token} ${this.rhs} )`;
 // return str + `${this.lhs} ${this.token} ${this.rhs}`;
 }
 return str + this.token.toString();
 }
}
G.EsilNode = EsilNode;
class EsilParser {
 constructor(r2) {
 this.cur = 0;
 this.r2 = r2;
 this.cur = 0;
 this.stack = [];
 this.nodes = [];
 this.tokens = [];
 this.root = new EsilNode(new EsilToken("function", 0), "block");
 }
 toJSON() {
 if (this.stack.length > 0) {
 // return JSON.stringify (this.stack, null, 2);
 throw new Error("The ESIL stack is not empty");
 }
 return JSON.stringify(this.root, null, 2);
 }
 toEsil() {
 return this.nodes.map((x) => x.toEsil()).join(",");
 }
 optimizeFlags(node) {
 if (node.rhs !== undefined) {
 this.optimizeFlags(node.rhs);
 }
 if (node.lhs !== undefined) {
 this.optimizeFlags(node.lhs);
 }
 for (let i = 0; i < node.children.length; i++) {
 this.optimizeFlags(node.children[i]);
 }
 const addr = node.toString();
 if (+addr > 4096) {
 const cname = r2.cmd(`fd.@ ${addr}`);
 const fname = cname.trim().split("\n")[0].trim();
 if (fname != "" && fname.indexOf("+") === -1) {
 node.token.text = fname;
 }
 }
 }
 optimize(options) {
 if (options.indexOf("flag") != -1) {
 this.optimizeFlags(this.root);
 }
 }
 toString() {
 return this.root.children.map((x) => x.toString()).join(";\n");
 }
 reset() {
 this.nodes = [];
 this.stack = [];
 this.tokens = [];
 this.cur = 0;
 this.root = new EsilNode(new EsilToken("function", 0), "block");
 }
 parseRange(from, to) {
 let pos = from;
 while (pos < this.tokens.length && pos < to) {
 const token = this.peek(pos);
 if (!token) {
 // console.log("BREAK");
 break;
 }
 // console.log(pos, token);
 this.cur = pos;
 this.pushToken(token);
 pos = this.cur;
 pos++;
 }
 // console.log("done");
 }
 parseFunction(addr) {
 const ep = this;
 function parseAmount(n) {
 // console.log("PDQ "+n);
 const output = r2.cmd("pie " + n + " @e:scr.color=0");
 const lines = output.trim().split("\n");
 for (const line of lines) {
 if (line.length === 0) {
 console.log("Empty");
 continue;
 }
 // console.log("parse", r2.cmd("?v:$$"));
 const kv = line.split(" ");
 if (kv.length > 1) {
 // line != "") {
 // console.log("// @ " + kv[0]);
 //ep.reset ();
 r2.cmd(`s ${kv[0]}`);
 ep.parse(kv[1], kv[0]);
 ep.optimize("flags,labels");
 //console.log(ep.toString());
 }
 }
 // console.log(ep.toString());
 }
 const oaddr = (r2.cmd("?v $$")).trim();
 // const func = r2.cmdj("pdrj"); // XXX this command changes the current seek
 if (addr === undefined) {
 addr = oaddr;
 }
 const bbs = r2.cmdj(`afbj@${addr}`); // XXX this command changes the current seek
 for (const bb of bbs) {
 // console.log("bb_" + bb.addr + ":");
 r2.cmd(`s ${bb.addr}`);
 parseAmount(bb.ninstr);
 }
 r2.cmd(`s ${oaddr}`);
 }
 parse(expr, addr) {
 const tokens = expr
 .trim()
 .split(",")
 .map((x) => x.trim());
 const from = this.tokens.length;
 for (const tok of tokens) {
 const token = new EsilToken(tok, this.tokens.length);
 if (addr !== undefined) {
 token.addr = addr;
 }
 this.tokens.push(token);
 }
 const to = this.tokens.length;
 this.parseRange(from, to);
 }
 peek(a) {
 return this.tokens[a];
 }
 pushToken(tok) {
 if (this.isNumber(tok)) {
 const node = new EsilNode(tok, "number");
 this.stack.push(node);
 this.nodes.push(node);
 }
 else if (this.isInternal(tok)) {
 const node = new EsilNode(tok, "flag");
 this.stack.push(node);
 this.nodes.push(node);
 }
 else if (this.isOperation(tok)) {
 // run the operation login
 }
 else {
 // assume it's a register, so just push the string
 const node = new EsilNode(tok, "register");
 this.stack.push(node);
 this.nodes.push(node);
 }
 // we need a list of register names to do this check properly
 // throw new Error ("Unknown token");
 }
 isNumber(expr) {
 if (expr.toString().startsWith("0")) {
 return true;
 }
 return +expr > 0;
 }
 isInternal(expr) {
 const text = expr.toString();
 return text.startsWith("$") && text.length > 1;
 }
 parseUntil(start) {
 const from = start + 1;
 let pos = from;
 const origStack = [];
 const this_nodes_length = this.nodes.length;
 this.stack.forEach((x) => origStack.push(x));
 while (pos < this.tokens.length) {
 const token = this.peek(pos);
 if (!token) {
 break;
 }
 if (token.toString() === "}") {
 break;
 }
 if (token.toString() === "}{") {
 // return token;
 break;
 }
 // console.log("peek ", this.tokens[pos]);
 pos++;
 }
 this.stack = origStack;
 const to = pos;
 this.parseRange(from, to);
 const same = this.nodes.length == this_nodes_length;
 // console.log("BLOCK ("+ ep.toString());
 if (same) {
 return null;
 }
 return this.nodes[this.nodes.length - 1]; // this.tokens.length - 1];
 }
 getNodeFor(index) {
 const tok = this.peek(index);
 if (tok === undefined) {
 return null;
 }
 for (const node of this.nodes) {
 if (node.token.position === index) {
 return node;
 }
 }
 this.nodes.push(new EsilNode(new EsilToken("label", index), "label"));
 return null;
 }
 findNodeFor(index) {
 for (const node of this.nodes) {
 if (node.token.position === index) {
 return node;
 }
 }
 return null;
 }
 isOperation(expr) {
 switch (expr.toString()) {
 // 1pop1push
 case "[1]":
 case "[2]":
 case "[4]":
 case "[8]":
 if (this.stack.length >= 1) {
 const i1 = this.stack.pop();
 // TODO: MemoryReferenceNode(i1));
 const mn = new EsilNode(i1.token, "operation"); // expr.toString());
 this.stack.push(i1); // mn);
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 // 1pop1push
 case "!":
 if (this.stack.length >= 1) {
 const i0 = new EsilNode(new EsilToken("", expr.position), "none");
 const i1 = this.stack.pop();
 const nn = new EsilNode(expr, "operation");
 nn.setSides(i0, i1);
 this.stack.push(nn);
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 case "":
 case "}":
 case "}{":
 // no pops or nothing, just does nothing
 return true;
 case "DUP":
 if (this.stack.length < 1) {
 throw new Error("goto cant pop");
 }
 else {
 const destNode = this.stack.pop();
 this.stack.push(destNode);
 this.stack.push(destNode);
 }
 return true;
 case "GOTO":
 // take previous statement which should be const and add a label
 {
 const prev = this.peek(expr.position - 1);
 if (prev !== null) {
 // TODO: check stack
 if (this.stack.length < 1) {
 throw new Error("goto cant pop");
 }
 const destNode = this.stack.pop();
 if (destNode !== null) {
 const value = 0 | +destNode.toString();
 if (value > 0) {
 const destToken = this.peek(value);
 if (destToken !== undefined) {
 destToken.label = "label_" + value;
 destToken.comment = "hehe";
 const nn = new EsilNode(expr, "goto");
 const gn = this.getNodeFor(destToken.position);
 if (gn != null) {
 nn.children.push(gn);
 }
 this.root.children.push(nn);
 }
 else {
 console.error("Cannot find goto node");
 }
 }
 else {
 console.error("Cannot find dest node for goto");
 }
 }
 }
 }
 return true;
 // controlflow
 case "?{": // ESIL_TOKEN_IF
 if (this.stack.length >= 1) {
 const i0 = new EsilNode(new EsilToken("if", expr.position), "none");
 const i1 = this.stack.pop();
 const nn = new EsilNode(expr, "operation");
 nn.setSides(i0, i1); // left side can be ignored for now.. but we can express this somehow
 const trueBlock = this.parseUntil(expr.position);
 let falseBlock = null;
 // nn.addChildren(trueBlock, falseBlock);
 if (trueBlock !== null) {
 nn.children.push(trueBlock);
 this.nodes.push(trueBlock);
 falseBlock = this.parseUntil(trueBlock.token.position + 1);
 if (falseBlock !== null) {
 nn.children.push(falseBlock);
 this.nodes.push(falseBlock);
 }
 }
 // console.log("true", trueBlock);
 // console.log("false", falseBlock);
 // this.stack.push(nn);
 this.nodes.push(nn);
 this.root.children.push(nn);
 if (falseBlock !== null) {
 this.cur = falseBlock.token.position;
 }
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 case "-":
 if (this.stack.length >= 2) {
 const i0 = this.stack.pop();
 const i1 = this.stack.pop();
 const nn = new EsilNode(expr, "operation");
 nn.setSides(i0, i1);
 if (this.stack.length === 0) {
 //	this.root.children.push(nn);
 }
 this.stack.push(nn);
 this.nodes.push(nn);
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 // 2pop1push
 case "<":
 case ">":
 case "^":
 case "&":
 case "|":
 case "+":
 case "*":
 case "/":
 case ">>=":
 case "<<=":
 case ">>>=":
 case "<<<=":
 case ">>>>=":
 case "<<<<=":
 if (this.stack.length >= 2) {
 const i0 = this.stack.pop();
 const i1 = this.stack.pop();
 const nn = new EsilNode(expr, "operation");
 nn.setSides(i0, i1);
 if (this.stack.length === 0) {
 //	this.root.children.push(nn);
 }
 this.stack.push(nn);
 this.nodes.push(nn);
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 // 2pop0push
 case "=":
 case ":=":
 case "-=":
 case "+=":
 case "==":
 case "=[1]":
 case "=[2]":
 case "=[4]":
 case "=[8]":
 if (this.stack.length >= 2) {
 const i0 = this.stack.pop();
 const i1 = this.stack.pop();
 const nn = new EsilNode(expr, "operation");
 nn.setSides(i0, i1);
 if (this.stack.length === 0) {
 this.root.children.push(nn);
 }
 this.nodes.push(nn);
 }
 else {
 throw new Error("Stack needs more items");
 }
 return true;
 }
 return false;
 }
}
G.EsilParser = EsilParser;
const r2pipe_js_1 = G;
