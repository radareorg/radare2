adc=add with carry
and=bitwise AND
asl=arithmetic shift left
bcc=branch on carry clear
bcs=branch on carry set
beq=branch if equal (zero)
bit=test bits
bmi=branch if minus (negative)
bne=branch if not equal
bpl=branch if plus (not negative)
bvc=branch if overflow clear
bvs=branch if overflow set
brk=break / software interrupt
clc=clear carry
cld=clear decimal
cli=clear interrupt disable
clv=clear overflow
cmp=compare
cpx=compare X register
cpa=compare accumulator
cpy=compare Y register
dec=decrement memory
dex=decrement X register
dey=decrement Y register
eor=exclusive OR
inc=increment memory
inx=increment X register
iny=increment Y register
jmp=jump
jsr=jump to subroutine
lda=load accumulator
ldx=load X register
ldy=load Y register
lsr=logical shift right
mvn=move negative (block transfer)
mvp=move positive (block transfer)
nop=no operation
ora=bitwise OR (accumulator)
pha=push accumulator
php=push processor status
phb=push B register
phk=push program bank
phx=push X register
phy=push Y register
pla=pull accumulator (pop)
plp=pull processor status (pop)
plb=pull B register (pop)
plx=pull X register
ply=pull Y register
rep=reset processor status bits (clear flags)
rol=rotate left
ror=rotate right
rti=return from interrupt
rts=return from subroutine
sep=set processor status bits
stz=store zero
sta=store accumulator
stx=store X register
sty=store Y register
sei=set interrupt disable
sbc=subtract with carry
tax=transfer A to X
tay=transfer A to Y
txa=transfer X to A
txs=transfer X to S
tya=transfer Y to A
xba=swap B and A (byte swap)
invalid=invalid instruction

