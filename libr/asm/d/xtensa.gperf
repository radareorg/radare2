%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_xtensa -N sdb_get_c_xtensa -t xtensa.gperf > xtensa.c
// gcc -DMAIN=1 xtensa.c ; ./a.out > xtensa.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
rsr,"read special register"
ipf,"instruction cache prefetch"
ufloat.s,"convert unsigned fixed to single"
call4,"call PC-relative, rotate window by 4"
add.n,"narrow add"
bbsi,"branch if bit set immediate"
call0,"non-windowed call"
beqz.n,"narrow branch if equal zero"
floor.s,"floor single to fixed"
add,"add"
break.n,"narrow breakpoint"
call8,"call PC-relative, rotate window by 8"
mulsh,"multiply signed high"
ssa8l,"set shift amount for LE byte shift"
lsiu,"load single immediate with update"
bnez.n,"narrow branch if not equal zero"
maxu,"maximum value unsigned"
ball,"branch if all bits set"
simcall,"simulator call"
diwb,"data cache index write back"
diwbi,"data cache index write back invalidate"
rsync,"register read synchronize"
add.s,"add single"
dhu,"data cache hit unlock"
s16i,"store 16-bit"
extui,"extract unsigned immediate"
dii,"data cache index invalidate"
movsp,"move to stack pointer"
ssa8b,"set shift amount for BE byte shift"
retw.n,"narrow windowed return"
ssl,"set shift amount for left shift"
srli,"shift right logical immediate"
moveqz,"move if equal to zero"
ldinc,"load with autoincrement"
un.s,"compare single unordered"
ssi,"store single immediate"
dpfro,"data cache prefetch for read once"
bltui,"branch if less than unsigned immediate"
rfr,"move FR to AR"
ssr,"set shift amount for right shift"
rdtlb1,"read data TLB entry translation"
bltz,"branch if less than zero"
rdtlb0,"read data TLB entry virtual"
bbc,"branch if bit clear"
ssx,"store single indexed"
bltu,"branch if less than unsigned"
excw,"exception wait"
clamps,"signed clamp"
j,"unconditional jump"
diu,"data cache index unlock"
movgez,"move if greater than or equal to zero"
rfe,"return from exception"
rur,"read user register"
ssiu,"store single immediate with update"
wer,"write external register"
rfi,"return from high-priority interrupt"
bbci,"branch if bit clear immediate"
loopgtz,"loop if greater than zero"
s8i,"store 8-bit"
blti,"branch if less than immediate"
iii,"instruction cache index invalidate"
bbs,"branch if bit set"
sll,"shift left logical"
or,"bitwise logical or"
mull,"multiply low"
iiu,"instruction cache index unlock"
neg,"negate"
mov.s,"move single"
max,"maximum value"
bbci.l,"branch if bit clear immediate LE"
mov.n,"narrow move"
bgei,"branch if greater than or equal immediate"
rfde,"return from double exception"
rfdd,"return from debug and dispatch"
wsr,"write special register"
ssai,"set shift amount immediate"
iitlb,"invalidate instruction TLB entry"
bgeu,"branch if greater than or equal unsigned"
rfme,"return from memory error"
abs,"absolute value"
rfdo,"return from debug operation"
movt.s,"move single if true"
xsr,"exchange special register"
sdct,"store data cache tag"
sra,"shift right arithmetic"
ihi,"instruction cache hit invalidate"
orb,"boolean or"
src,"shift right combined"
srl,"shift right logical"
bgez,"branch if greater than or equal to zero"
ihu,"instruction cache hit unlock"
blt,"branch if less than"
remu,"remainder unsigned"
idtlb,"invalidate data TLB entry"
rems,"remainder signed"
abs.s,"absolute value single"
min,"minimum value"
extw,"external wait"
rfwo,"return from window overflow"
ule.s,"compare single unord or less than or equal"
andb,"boolean and"
s32ri,"store 32-bit release"
beqz,"branch if equal to zero"
sub,"subtract"
rfwu,"return from window underflow"
bany,"branch if any bit set"
slli,"shift left logical immediate"
addmi,"add immediate with shift by 8"
sub.s,"subtract single"
lsx,"load single indexed"
subx8,"subtract with shift by 3"
mov,"move"
l32ai,"load 32-bit acquire"
beqi,"branch if equal immediate"
l16si,"load 16-bit signed"
waiti,"wait for interrupt"
rsil,"read and set interrupt level"
subx2,"subtract with shift by 1"
loop,"loop"
subx4,"subtract with shift by 2"
wur,"write user register"
s32e,"store 32-bit for window exceptions"
lsi,"load single immediate"
minu,"minimum value unsigned"
wdtlb,"write data TLB entry"
bnall,"branch if not-all bits set"
pitlb,"probe instruction TLB"
isync,"instruction fetch synchronize"
beq,"branch if equal"
dpfw,"data cache prefetch for write"
addx8,"add with shift by 3"
ult.s,"compare single unordered or less than"
l32i.n,"narrow load 32-bit"
jx,"unconditional jump register"
s32i,"store 32-bit"
bgeui,"i branch if greater than or equal unsigned immediate"
addx4,"add with shift by 2"
dpfr,"data cache prefetch for read"
addx2,"add with shift by 1"
orbc,"boolean or with complement"
rfue,"return from user-mode exception"
srai,"shift right arithmetic immediate"
lsxu,"load single indexed with update"
bf,"branch if false"
sict,"store instruction cache tag"
xorb,"boolean exclusive or"
dhwbi,"data cache hit writeback invalidate"
bne,"branch if not equal"
sicw,"store instruction cache word"
licw,"load instruction cache word"
addi.n,"narrow add immediate"
dpfl,"data cache prefetch and lock"
lict,"load instruction cache tag"
madd.s,"multiply and add single"
mul.s,"multiply single"
ssxu,"store single indexed with update"
nop.n,"narrow no-operation"
wfr,"move AR to FR"
xor,"bitwise logical exclusive or"
bt,"branch if true"
l8ui,"load 8-bit unsigned"
movf.s,"move single if false"
ceil.s,"ceiling single to fixed"
neg.s,"negate single"
olt.s,"compare single ordered and less than"
loopnez,"loop if not-equal zero"
bnei,"branch if not equal immediate"
l16ui,"load 16-bit unsigned"
oeq.s,"compare single equal"
bbsi.l,"branch if bit set immediate LE"
nsau,"normalization shift amount unsigned"
l32i,"load 32-bit"
addi,"add immediate"
andbc,"boolean and with complement"
movt,"move if true"
muluh,"multiply unsigned high"
movnez,"move if not-equal to zero"
break,"breakpoint"
and,"bitwise logical and"
movnez.s,"move single if not equal to zero"
witlb,"write instruction TLB entry"
ueq.s,"compare single unordered or equal"
l32e,"load 32-bit for window exceptions"
bnez,"branch if not-equal to zero"
nop,"no-operation"
trunc.s,"truncate single to fixed"
all4,"all 4 booleans true"
movgez.s,"move single if greater than or equal to zero"
movf,"move if false"
rotw,"rotate window"
movi,"move immediate"
ritlb0,"read instruction TLB entry virtual"
ret.n,"narrow non-windowed return"
ritlb1,"read instruction TLB entry translation"
dsync,"load/store synchronize"
utrunc.s,"truncate single to fixed unsigned"
l32r,"load 32-bit PC-relative"
movi.n,"narrow move immediate"
movltz,"move if less than zero"
dhwb,"data cache hit writeback"
bnone,"branch if no bit set"
s32c1i,"store 32-bit compare conditional"
all8,"all 8 booleans true"
sext,"sign extend"
dpfwo,"data cache prefetch for write once"
callx12,"call register, rotate window by 12"
float.s,"convert fixed to single"
j.l,"unconditional jump long"
lddec,"load with autodecrement"
ole.s,"compare single ordered and less than or equal"
entry,"subroutine entry"
mul16u,"multiply 16-bit unsigned"
mul16s,"multiply 16-bit signed"
moveqz.s,"move single if equal to zero"
bge,"branch if greater than or equal"
msub.s,"multiply and subtract single"
retw,"windowed return"
ill.n,"narrow illegal instruction"
movltz.s,"move single if less than zero"
s32i.n,"narrow store 32-bit"
rer,"read external register"
ill,"illegal instruction"
memw,"memory wait"
pdtlb,"probe data tlb"
ret,"non-windowed return"
syscall,"system call"
round.s,"round single to fixed"
ldct,"load data cache tag"
call12,"call PC-relative, rotate window by 12"
callx8,"call register, rotate window by 8"
nsa,"normalization shift amount"
any4,"any 4 booleans true"
callx4,"call register, rotate window by 4"
any8,"any 8 booleans true"
callx0,"non-windowed call register"
esync,"execute synchronize"
ipfl,"instruction cache prefetch and lock"
dhi,"data cache hit invalidate"
quou,"quotient unsigned"
quos,"quotient signed"
%%
// SDB-CGEN V1.7.0
// 0x55fa8e7e4170
const char* gperf_xtensa_get(const char *s) {
	const struct kv *o = sdb_get_c_xtensa (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_xtensa_hash(const char *s) {
	return sdb_hash_c_xtensa(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_xtensa = {
	.name = "xtensa",
	.get = &gperf_xtensa_get,
	.hash = &gperf_xtensa_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("xtensa.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open xtensa.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_xtensa_H\n");
	printf ("#define INCLUDE_xtensa_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_xtensa_%s %d\n",
					line, sdb_hash_c_xtensa (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

