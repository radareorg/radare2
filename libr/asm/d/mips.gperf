%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_mips -N sdb_get_c_mips -t mips.gperf > mips.c
// gcc -DMAIN=1 mips.c ; ./a.out > mips.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
c.cond.fmt,"floating point compare"
lhu,"lhu $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte."
dinsu,"doubleword insert bit field upper"
trunc.l.fmt,"floating point truncate to long fixed point"
bgezal,"branch on greater than or equal to zero and link"
add,"adds two registers, trap on overflow"
dext,"doubleword extract bit field"
bc1t,"branch on fp true"
floor.l.fmt,"floating point floor convert to long fixed point"
daddiu,"doubleword add immediate unsigned"
teq,"trap if equal"
cvt.d.fmt,"floating point convert to double floating point"
round.l.fmt,"floating point round to long fixed point"
dinsm,"doubleword insert bit field middle"
dmult,"doubleword multiply"
cvt.s.pl,"floating point convert pair lower to single floating point"
bc1f,"branch on fp false"
nmsub.fmt,"floating point negative multiply subtract"
movf.fmt,"floating point move conditional on floating point false"
divu,"divides two registers and puts the 32-bit integer result in LO and the remainder in HI."
dmtc2,"doubleword move to coprocessor 2"
dmtc1,"doubleword move to floating point"
tgeu,"trap if greater or equal unsigned"
dmtc0,"doubleword move to coprocessor 0"
cvt.s.pu,"floating point convert pair upper to single floating point"
sqrt.fmt,"floating point square root"
bgtz,"branch on greater than zero"
mult,"int HI, int LO = (64-bit) $s * $t, trap on overflow"
round.w.fmt,"floating point round to word fixed point"
mthi,"move to hi register"
b,"unconditional branch"
dmfc1,"doubleword move from floating point"
bltz,"branch on less than zero"
movt.fmt,"floating point move conditional on floating point true"
dmfc0,"doubleword move from coprocessor 0"
recip.fmt,"reciprocal approximation"
dmfc2,"doubleword move from coprocessor 2"
bltzall,"branch on less than zero and link likely"
swxc1,"store word indexed from floating point"
lui,"loads a 16-bit immediate operand into the upper 16-bits of the register specified."
deret,"debug exception return"
tgei,"trap if greater or equal immediate"
j,"unconditionally jumps to the instruction at the specified address"
div,"divides two registers and puts the 32-bit integer result in LO and the remainder in HI."
slt,"tests if one register is less than another."
srlv,"srlv $d,$t,$s, shifts $s number of bits to the right - zeros are shifted in"
tgeiu,"trap if greater or equal immediate unsigned"
seb,"sign-extend byte"
sll,"sll $d,$t,shamt, shifts shamt number of bits to the left (multiply but 2^n)"
or,"bitwise or"
sdbbp,"software debug breakpoint"
cvt.w.fmt,"floating point convert to word fixed point"
wsbh,"word swap bytes within halfwords"
eret,"exception return"
cvt.ps.s,"floating point convert pair to paired single"
ldl,"load doubleword left"
seh,"sign-extend halfword"
dsbh,"doubleword swap bytes within halfwords"
mflo,"moves a value from LO to a register"
ext,"extract bit field"
msub,"multiply and subtract word to hi,lo"
sdr,"store doubleword right"
dsrl32,"doubleword shift right logical plus 32"
suxc1,"store doubleword indexed unaligned from floating point"
pref,"prefetch"
bc2tl,"branch on cop2 true likely"
ori,"bitwise or, leftmost 16 bits are padded with 0s"
daddi,"doubleword add immediate"
mfhc1,"move word from high half of floating point register"
mtc2,"move word to coprocessor 2"
mtc1,"move word to floating point"
mtc0,"move to coprocessor 0"
mfhc2,"move word from high half of coprocessor 2 register"
dsrlv,"doubleword shift right logical variable"
sra,"sda $d,$t,shamt, shifts shamt number of bits - the sign bit is shifted in"
dsll,"doubleword shift left logical"
srl,"srl $d,$t,shamt, shifts shamt number of bits to the right - zeros are shifted in."
bgez,"branch on greater than or equal to zero"
sllv,"sllv $d,$t,$s, shifts $s number of bits to the left"
neg.fmt,"floating point negate"
daddu,"doubleword add unsigned"
rdpgpr,"read gpr from previous shadow set"
ddivu,"doubleword divide unsigned"
pll.ps,"pair lower lower"
abs.fmt,"floating point absolute value"
ldr,"load doubleword right"
sdi,"store doubleword"
lwc1,"load word to floating point"
trunc.w.fmt,"floating point truncate to word fixed point"
tltiu,"trap if less than immediate unsigned"
sdl,"store doubleword left"
lwc2,"load word to coprocessor 2"
lld,"load linked doubleword"
bc1fl,"branch on fp false likely"
li,"load immediate (pseudoinstruction)"
bgezall,"branch on greater than or equal to zero and link likely"
lh,"lh $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte, sign is extended to width of register."
bgezl,"branch on greater than or equal to zero likely"
ll,"load linked word"
andi,"bitwise and, leftmost 16 bits are padded with 0s"
dextm,"doubleword extract bit field middle"
dsubu,"doubleword subtract unsigned"
bltzal,"branch on less than zero and link"
lb,"lb $t,C($s), loads the byte stored from: MEM[$s+C], sign is extended to width of register"
sub,"subtracts two registers, trap on overflow"
ld,"load doubleword"
dmultu,"doubleword multiply unsigned"
jr.hb,"jump register with hazard barrier"
dsub,"doubleword subtract"
dsra,"doubleword shift right arithmetic"
puu.ps,"pair upper upper"
bc2fl,"branch on cop2 false likely"
mul,"multiply word to gpr"
tlbwi,"write indexed tlb entry"
floor.w.fmt,"floating point floor convert to word fixed point"
sw,"sw $t,C($s), stores a word into: MEM[$s+C] and the following 3 bytes."
cop2,"coprocessor operation to coprocessor 2"
dsrl,"doubleword shift right logical"
add.fmt,"floating point add"
lw,"lw $t,C($s), loads the word stored from: MEM[$s+C] and the following 3 bytes."
dextu,"doubleword extract bit field upper"
slti,"tests if one register is less than a constant."
beql,"branch on equal likely"
ehb,"execution hazard barrier"
mthc2,"move word to high half of coprocessor 2 register"
mthc1,"move word to high half of floating point register"
mfc1,"move word from floating point"
mfc0,"move from coprocessor 0"
sdc1,"store doubleword from floating point"
sb,"sb $t,C($s), stores the least-significant 8-bit of a register (a byte) into: MEM[$s+C]."
sc,"store a word to memory."
mfc2,"move word from coprocessor 2"
dins,"doubleword insert bit field"
sdc2,"store doubleword from coprocessor 2"
jalr,"jump and link register"
tlbwr,"write random tlb entry"
di,"disable interrupts"
cvt.s.fmt,"floating point convert to single floating point"
beq,"beq $s,$t,C, goes to the instruction at the specified address if two registers are equal."
div.fmt,"floating point divide"
sdxc1,"store doubleword indexed from floating point"
sh,"sh $t,C($s), stores the least-significant 16-bit of a register (a halfword) into: MEM[$s+C]."
sltu,"tests if one register is less than an unsigned constant."
ctc1,"move control word to floating point"
blezl,"branch on less than or equal to zero likely"
ctc2,"move control word to coprocessor 2"
jr,"jumps to the address contained in the specified register"
subu,"subtracts two registers"
blez,"branch if the register is less than or equal to zero."
drotr32,"doubleword rotate right plus 32"
movn.fmt,"floating point move conditional on not zero"
sub.fmt,"floating point subtract"
mtcZ,"moves a 4 byte value from a general purpose register to a Coprocessor Z Control register. Sign extension."
plu.ps,"pair lower upper"
dsllv,"doubleword shift left logical variable"
multu,"int HI, int LO = (64-bit) $s * $t"
srav,"srav $d,$t,$s, shifts $s number of bits - the sign bit is shifted in"
bne,"branch on not equal"
cvt.l.fmt,"floating point convert to long fixed point"
jal,"used to call a subroutine, $31 holds the return address; returning from a subroutine is done by: jr $31. Return address is PC + 8, not PC + 4 due to the use of a branch delay slot which forces the instruction after the jump to be executed"
madd,"multiply and add word to hi,lo"
xori,"bitwise xor with a constant"
ei,"enable interrupts"
ceil.l.fmt,"fixed point ceiling convert to long fixed point"
xor,"bitwise xor"
mov.fmt,"floating point move"
bnel,"branch on not equal likely"
alnv.ps,"floating point align variable"
tlbr,"read indexed tlb entry"
msubu,"multiply and subtract word to hi,lo"
tlbp,"probe tlb for matching entry"
swl,"store word left"
ins,"insert bit field"
lbu,"load byte unsigned"
nmadd.fmt,"floating point negative multiply add"
addi,"add sign-extended constants (or copy one register to another: addi $1, $2, 0), trap on overflow"
swr,"store word right"
tne,"trap if not equal"
movt,"move conditional on floating point true"
mfhi,"moves a value from HI to a register"
addu,"adds two registers"
break,"breakpoint"
and,"bitwise and"
ldc2,"load doubleword to coprocessor 2"
prefx,"prefetch indexed"
tnei,"trap if not equal immediate"
movz,"conditional move."
mtlo,"move to lo register"
ldc1,"load doubleword to floating point"
luxc1,"load doubleword indexed unaligned to floating point"
nop,"no operation"
bgtzl,"branch on greater than zero likely"
nor,"bitwise nor"
clo,"count leading ones in word"
move,"moves a register value into another register (pseudoinstruction)."
rsqrt.fmt,"reciprocal square root approximation"
bneq,"goes to the instruction at the specified address if two registers are not equal."
sync,"synchronize shared memory"
movf,"move conditional on floating point false"
wrpgpr,"write to gpr in previous shadow set"
synci,"synchronize caches to make instruction writes effective"
rotr,"rotate word right"
clz,"count leading zeros in word"
bc1tl,"branch on fp true likely"
tlti,"trap if less than immediate"
movn,"conditional move."
cfc2,"move control word from coprocessor 2"
cfc1,"move control word from floating point"
movz.fmt,"floating point move conditional on zero"
rdhwr,"read hardware register"
teqi,"trap if equal immediate"
mul.fmt,"floating point multiply"
mfcZ,"moves a 4 byte value from Coprocessor Z Control register to a general purpose register. Sign extension."
lwxc1,"load word indexed to floating point"
cache,"perform cache operation."
drotr,"doubleword rotate right"
dclo,"count leading ones in doubleword"
tlt,"trap if less than"
scd,"store conditional doubleword"
drotrv,"doubleword rotate right variable"
swc2,"store word from coprocessor 2"
tltu,"trap if less than unsigned"
rotrv,"rotate word right variable"
swc1,"store word from floating point"
ssnop,"superscalar no operation"
jraddiusp,"increment stackpointer and jump to ra register"
dsrav,"doubleword shift right arithmetic variable"
syscall,"system call"
tge,"trap if greater or equal"
ldxc1,"load doubleword indexed to floating point"
jalr.hb,"jump and link register with hazard barrier"
dclz,"count leading zeros in doubleword"
lwu,"load word unsigned"
lwr,"load word right"
msub.fmt,"floating point multiply subtract"
madd.fmt,"floating point multiply add"
dshd,"doubleword swap halfwords within doublewords"
bltzl,"branch on less than zero likely"
bc2t,"branch on cop2 true"
bal,"branch and link"
pul.ps,"pair upper lower"
lwl,"load word left"
ddiv,"doubleword divide"
dsll32,"doubleword shift left logical plus 32"
dsra32,"doubleword shift right arithmetic plus 32"
dadd,"doubleword add"
addiu,"add sign-extended constants (or copy one register to another: addi $1, $2, 0)"
maddu,"multiply and add unsigned word to hi,lo"
ceil.w.fmt,"floating point ceiling convert to word fixed point"
bc2f,"branch on cop2 false"
sltiu,"set on less than immediate unsigned"
wait,"enter standby mode"
%%
// SDB-CGEN V1.7.0
// 0x55c54ea05160
const char* gperf_mips_get(const char *s) {
	const struct kv *o = sdb_get_c_mips (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_mips_hash(const char *s) {
	return sdb_hash_c_mips(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_mips = {
	.name = "mips",
	.get = &gperf_mips_get,
	.hash = &gperf_mips_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("mips.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open mips.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_mips_H\n");
	printf ("#define INCLUDE_mips_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_mips_%s %d\n",
					line, sdb_hash_c_mips (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

