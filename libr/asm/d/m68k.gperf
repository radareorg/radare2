%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_m68k -N sdb_get_c_m68k -t m68k.gperf > m68k.c
// gcc -DMAIN=1 m68k.c ; ./a.out > m68k.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
subq,"subtract quick"
eori,"logical exclusive-or immediate"
rol,"rotate left"
fsmove,"move floating-point register double precision"
pflusha,"flush entry(ies) in the atcs"
movep,"move peripheral"
cmp,"compare"
moveq,"move quick"
or,"logical inclusive-or"
moves,"move address space"
fgetman,"floating-point get mantissa"
pvalid,"validate a pointer"
andi,"logical and immediate"
trapcc,"trap conditionally"
subx,"subtract with extend"
link,"link and allocate"
fmovem,"move multiple floating-point registers"
ftanh,"hyperbolic tangent"
fetox,"floating-point ex"
and,"logical and"
fmovecr,"move constant rom"
fsglmul,"single-precision multiply"
fsneg,"floating-point negate single precision"
unpk,"unpack bcd"
movea,"move address"
fsabs,"floating-point absolute value single precision"
chk2,"check register against upper and lower bounds"
movec,"move control register"
divu,"unsigned divide"
fsinh,"hyperbolic sine"
extb,"sign extend"
pscc,"set on pmmu condition"
movem,"move multiple registers"
roxl,"rotate with extend left"
divs,"signed divide"
pload*,"load an entry into the atc"
pflush,"flush entry(ies) in the atcs"
fsincos,"simultaneous sine and cosine"
fssub,"floating-point subtract single precision"
ori,"logical inclusive-or immediate"
callm,"call module"
roxr,"rotate with extend right"
pack,"pack bcd"
cinv,"invalidate cache entries"
reset,"reset external devices"
neg,"negate"
clr,"clear"
fintrz,"floating-point integer part, round-to-zero"
fdsqrt,"floating-point square root double precision"
cmp2,"compare register against upper and lower bounds"
ftentox,"floating-point 10x"
jsr,"jump to subroutine"
facos,"floating-point arc cosine"
adda,"add address"
fadd,"floating-point add"
frem,"ieee remainder"
cprestore,"coprocessor restore function"
cpgen,"coprocessor general function"
flog10,"floating-point log10"
add,"add"
addi,"add immediate"
flogn,"floating-point loge"
tas,"test operand and set"
jmp,"jump"
addq,"add quick"
fcos,"floating-point cosine"
illegal,"take illegal instruction trap"
cas2,"compare and swap dual operands"
trapv,"trap on overflow"
addx,"add with extend"
not,"logical complement"
cptracpcc,"trap on coprocessor condition"
nop,"no operation"
bfffo,"bit field find first one"
fatan,"floating-point arc tangent"
bfclr,"test bit field and clear"
fdbcc,"floating-point decrement and branch"
pflush*,"invalidate entries in the atc"
fatanh,"floating-point hyperbolic arc tangent"
fddiv,"floating-point divide double precision"
fdmul,"floating-point multiply double precision"
fetoxm,"floating-point ex -1"
fdneg,"floating-point negate double precision"
fsgldiv,"single-precision divide"
pflusha*,"invalidate all entries in the atc"
lea,"load effective address"
nbcd,"negate decimal with extend"
fsmul,"floating-point multiply single precision"
psave,"pmmu save function"
negx,"negate with extend"
abcd,"add decimal with extend"
pdbcc,"test, decrement, and branch on pmmu condition"
rte,"return from exception"
rtd,"return and deallocate"
bchg,"test bit and change"
fsqrt,"floating-point square root"
fscale,"floating-point scale exponent"
trap,"trap"
fscc,"floating-point set according to condition"
muls,"signed multiply"
rtm,"return from module"
pmove,"move pmmu register"
ftwotox,"floating-point 2x"
swap,"swap register words"
mulu,"unsigned multiply"
rts,"return from subroutine"
fbcc,"floating-point branch"
rtr,"return and restore"
fcmp,"floating-point compare"
cas,"compare and swap operands"
cmpi,"compare immediate"
bfexts,"signed bit field extract"
lpstop,"low-power stop"
cptrapcc,"trap on coprocessor condition"
bfextu,"unsigned bit field extract"
bgnd,"enter background mode"
tblsn,"signed table lookup with interpolate"
cmpm,"compare memory to memory"
bset,"test bit and set"
fcosh,"floating-point hyperbolic cosine"
fsave,"save floating-point internal state"
cmpa,"compare address"
move,"move"
sub,"subtract"
fnop,"floating-point no operation"
prestore,"pmmu restore function"
cpsave,"coprocessor save function"
asr,"arithmetic shift  right"
scc,"set conditionally"
bcc,"branch conditionally"
chk,"check register against bound"
ptrapcc,"trap on pmmu condition"
ftan,"tangent"
ftrapcc,"floating-point trap on condition"
divsl,"signed divide"
bra,"branch"
fasin,"floating-point arc sine"
asl,"arithmetic shift left"
ftst,"floating-point test"
cpbcc,"branch on coprocessor condition"
cpscc,"set on coprocessor condition"
tblun,"unsigned table lookup with interpolate"
fgetexp,"floating-point get exponent"
btst,"test bit"
lsr,"logical shift right"
tblu,"unsigned table lookup with interpolate"
unlk,"unlink"
dbcc,"test condition, decrement and branch"
tbls,"unsigned table lookup with interpolate"
bsr,"branch to subroutine"
bfchg,"test bit field and change"
fsin,"sine"
lsl,"logical shift left"
fdfabs,"floating-point absolute value double precision"
fdsub,"floating-point subtract double precision"
fmove,"move floating-point register"
fsdiv,"floating-point divide simple precision"
ptest,"test a logical address"
ext,"sign extend"
fint,"floating-point integer part"
fdabs,"floating-point absolute value double precision"
bftst,"test bit field"
fmod,"floating-point modulo remainder"
stop,"stop"
fmul,"floating-point multiply"
move16,"16-byte block move"
fsfabs,"floating-point absolute value single precision"
exg,"exchange registers"
fneg,"floating-point negate"
fdiv,"floating-point divide"
tst,"test operand"
fsadd,"floating-point add single"
pload,"load an entry into the atc"
bkpt,"breakpoint"
eor,"logical exclusive-or"
flognp,"floating-point loge (x + 1)"
fabs,"floating-point absolute value"
bfset,"test bit field and set"
fssqrt,"floating-point square root single precision"
cpush,"push then invalidate cache entries"
divul,"unsigned divide"
frestore,"restore floating-point internal state"
suba,"subtract address"
bfins,"bit field insert"
bclr,"test bit and clear"
pea,"push effective address"
pflushs,"flush entry(ies) in the atcs"
pflushr,"flush entry(ies) in the atcs and rpt entries"
ror,"rotate right"
subi,"subtract immediate"
sbcd,"subtract decimal with extend"
cpdbcc,"test coprocessor condition decrement and branch"
fdadd,"floating-point add double precision"
fdmove,"move floating-point register single"
fsub,"floating-point subtract"
pbcc,"branch on pmmu condition"
flog2,"floating-point log2"
%%
// SDB-CGEN V1.7.0
// 0x560b8d96d160
const char* gperf_m68k_get(const char *s) {
	const struct kv *o = sdb_get_c_m68k (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_m68k_hash(const char *s) {
	return sdb_hash_c_m68k(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_m68k = {
	.name = "m68k",
	.get = &gperf_m68k_get,
	.hash = &gperf_m68k_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("m68k.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open m68k.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_m68k_H\n");
	printf ("#define INCLUDE_m68k_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_m68k_%s %d\n",
					line, sdb_hash_c_m68k (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

