adc=add with carry
add=add without carry
adiw=add immediate to word
and=logical AND
andi=logical AND with immediatend
asr=arithmetic shift right
bclr=bit clear in SREG
bld=bit load from the T flag in SREG to a bit in register
brbc=branch if bit in SREG is cleared
brbs=branch if bit in SREG is set
brcc=branch if carry cleared
brcs=branch if carry set
break=break
breq=branch if equal
brge=branch if greater or equal signed
brhc=branch if half carry flag is cleared
brhs=branch if half carry flag is set
brid=branch if global interrupt is disabled
brie=branch if global interrupt is enabled
brlo=branch if lower (unsigned)
brlt=branch if less than (signed)
brmi=branch if minus
brne=branch if not equal
brpl=branch if plus
brsh=branch if same or higher (unsigned)
brtc=branch if the T flag is cleared
brts=branch if the T flag is Set
brvc=branch if overflow cleared
brvs=branch if overflow set
bset=bit set in SREG
bst=bit store from bit in register to T flag in SREG
call=long call to a subroutine
cbi=clear bit in I/O register
cbr=clear bits in register
clc=clear carry flag
clh=clear half carry flag
cli=clear global interrupt flag
cln=clear negative flag
clr=clear register
cls=clear signed flag
clt=clear T flag
clv=clear overflow flag
clz=clear zero flag
com=one's complement
cp=compare
cpc=compare with carry
cpi=compare with immediate
cpse=compare skip if equal
dec=decrement
eicall=extended indirect call to subroutine
eijmp=extended indirect jump
elpm=extended load programm memory
eor=exclusive OR
fmul=fractional multiply unsigned
fmuls=fractional multiply signed
fmulsu=fractional multiply signed with unsigned
icall=indirect call to subroutine
ijmp=indirect jump
in=load an I/O location to register
inc=incerement
jmp=jump
lat=load and toggle
las=load and set
lac=load and clear
ld=LD Rd,X. load indirect
ld=LD Rd,X+. load indirect and post-increment
ld=LD Rd,-X. load indirect and pre-decrement
ld=LD Rd,Y. load indirect
ld=LD Rd,Y+. load indirect and post-increment
ld=LD Rd,-Y. load indirect and pre-decrement
ldd=LDD Rd,Y+q. load indirect and displacement
ld=LD Rd,Z. load indirect
ld=LD Rd,Z+. load indirect and post-increment
ld=LD Rd,-Z. load indirect and pre-decrement
ldd=LDD Rd,Z+q. load indirect and displacement
ldi=LDI Rd,K. load immediate
lds=LDS Rd,K. load direct from SRAM
lpm=LPM. load programm memory
lpm=LPM Rd,Z. load programm memory
lpm=LPM Rd,Z+. load programm memory and post-increment
lsl=logical shift left
lsr=logical shift right
mov=copy register
movw=copy register word
mul=multiply unsigned
muls=multiply signed
mulsu=multiply signed with unsigned
neg=two's complement
nop=no operation
or=logical OR
ori=logical OR with immediate
out=store register to I/O location
pop=pop register from stack
push=push register on stack
rcall=relative call to subroutine
ret=return from subroutine
reti=return from interrupt
rjmp=relative jump
rol=rotate left through carry
ror=rotate right through carry
sbc=substract with carry
sbci=substract immediate with carry
sbi=set bit in I/O register
sbic=skip if bit in I/O register is cleared
sbis=skip if bit in I/O register is set
sbiw=substract immediate from word
sbr=set bits in register
sbrc=skip if bit register is cleared
sbrs=skip if bit register is set
sec=set carry flag
seh=set half carry flag
sei=set global interrupt flag
sen=set negative flag
ser=set all bits in register
ses=set signed flag
set=set T flag
sev=set overflow flag
sez=set zero flag
sleep=sleep mode
spm=store program memory
st=ST X,Rr. store indirect
st=ST X+,Rr. store indirect and post-increment
st=ST -X,Rr. store indirect and pre-decrement
st=ST Y,Rr. store indirect
st=ST Y+,Rr. store indirect and post-increment
st=ST -Y,Rr. store indirect and pre-decrement
std=STD Y+q,Rr. store indirect and displacement
st=ST Z,Rr. store indirect
st=ST Z+,Rr. store indirect and post-increment
st=ST -Z,Rr. store indirect and pre-decrement
std=STD Z+q,Rr. store indirect and displacement
sts=store direct to SRAM
sub=substract without carry
subi=substract immediate
swap=swap nibbles
tst=test for zero or minus
wdr=watchdog reset
xch=exchange
