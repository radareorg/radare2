abs_s=absolute value (saturated)
abs=absolute value
abss=absolute and saturate
abssw=absolute and saturate of word
adc=add with carry
add_s=add (saturated)
add=add
add1_s=add with left shift by 1 bit (saturated)
add1=add with left shift by 1 bit
add2_s=add with left shift by 2 bits (saturated)
add2=add with left shift by 2 bits
add3_s=add with left shift by 3 bits (saturated)
add3=add with left shift by 3 bits
adds=add and saturate
addsdw=add and saturate dual word
and_s=logical and (saturated)
and=logical and
asl_s=arithmetic shift left (saturated)
asl=arithmetic shift left
asls=arithmetic shift left and saturate
asr_s=arithmetic shift right (saturated)
asr=arithmetic shift right
asrs=arithmetic shift right and saturate
bbit0=branch if bit cleared to 0
bbit1=branch if bit set to 1
bcc_s=branch if condition true (saturated)
bcc=branch if condition true
bclr_s=clear specified bit (to 0) (saturated)
bclr=clear specified bit (to 0)
bic_s=bit-wise inverted and (saturated)
bic=bit-wise inverted and
bl_s=branch and link (saturated)
blcc=branch and link conditionally
bmsk_s=bit mask (saturated)
bmsk=bit mask
brcc_s=branch on compare (saturated)
brcc=branch on compare
brk_s=break (halt) processor (saturated)
brk=break (halt) processor
bset_s=set specified bit (to 1) (saturated)
bset=set specified bit (to 1)
btst_s=test value of specified bit (saturated)
btst=test value of specified bit
bxor=bit xor
cmp_s=compare (saturated)
cmp=compare
divaw=division assist
ex=atomic exchange
ext_s=unsigned extend (saturated)
ext=unsigned extend
flag=write to status register
jcc_s=jump conditionally (saturated)
jcc=jump conditionally
jl_s=jump and link (saturated)
jlcc=jump and link conditionally
ld_s=load from memory (saturated)
ld=load from memory
lpcc=loop (zero-overhead loops)
lr=load from auxiliary memory
lsr_s=logical shift right (saturated)
lsr=logical shift left
max=return maximum
min=return minimum
mov_s=move (copy) to register (saturated)
mov=move (copy) to register
mpy=32 x 32 signed multiply (low)
mpyh=32 x 32 signed multiply (high)
mpyhu=32 x 32 unsigned multiply (high)
mpyu=32 x 32 unsigned multiply (low)
mul64_s=32 x 32 multiply (saturated)
mul64=32 x 32 signed multiply
mulu64=32 x 32 unsigned multiply
neg_s=negate (saturated)
neg=negate
negs=negate and saturate
negsw=negate and saturate of word
nop_s=no operation (saturated)
nop=no operation
norm=normalize to 32 bits
normw=normalize to 16 bits
not_s=logical bit inversion (saturated)
not=logical bit inversion
or_s=logical or (saturated)
or=logical or
pop_s=restore register value from stack (saturated)
pop=restore register value from stack
prefetch=prefetch from memory
push_s=store register value on stack (saturated)
push=store register value on stack
rcmp=reverse compare
rlc=rotate left through carry
rnd16=round to word
ror=rotate right
rrc=rotate right through carry
rsub=reverse subtraction
rtie=return from interrupt/exception
sat16=saturate to word
sbc=subtract with carry
sex_s=signed extend (saturated)
sex=signed extend
sleep=put processor in sleep mode
sr=store to auxiliary memory
st_s=store to memory (saturated)
st=store to memory
sub_s=subtract (saturated)
sub=subtract
sub1=subtract with left shift by 1 bit
sub2=subtract with left shift by 2 bits
sub3=subtract with left shift by 3 bits
subs=subtract and saturate
subsdw=subtract and saturate dual word
swap=swap 16 x 16
swi=software interrupt
sync=synchronize
trap_s=raise exception (saturated)
trap0=raise exception with param. 0
trap=raise exception
tst_s=test (saturated)
tst=test
unimp_s=unimplemented instruction
xor_s=logical exclusive-or (saturated)
xor=logical exclusive-or
b=unconditional branch
bl=branch and link
jmp=unconditional jump
call=call subroutine
ret=return from subroutine
lda=load address
sta=store address
ldb=load byte
stb=store byte
ldw=load word
stw=store word
ldh=load halfword
sth=store halfword
ldd=load doubleword
std=store doubleword
ldc=load coprocessor
stc=store coprocessor
mrc=move to register from coprocessor
mcr=move to coprocessor from register
cdp=coprocessor data processing
clz=count leading zeros
fls=find least significant set bit
fms=find most significant set bit
ffs=find first set bit
mod=modulo
div=divide
divu=divide unsigned
rem=remainder
remu=remainder unsigned
seq=set if equal
sne=set if not equal
sgt=set if greater than
sgtu=set if greater than unsigned
slt=set if less than
sltu=set if less than unsigned
sge=set if greater or equal
sgeu=set if greater or equal unsigned
sle=set if less or equal
sleu=set if less or equal unsigned
ldm=load multiple registers
stm=store multiple registers
enter=function entry
leave=function exit
brkpt=breakpoint
dbg=debug
di=disable interrupts
ei=enable interrupts
iret=return from interrupt
wait=wait for event
sev=send event
sev_lite=send event lite
wfe=wait for event
wfi=wait for interrupt
