adc=add with carry
add=add two values
addeq=add two values if Z set (equal)
addne=add two values if Z clear (not equal)
and=logical AND
andeq=logical AND if Z set (equal)
andne=logical AND if Z clear (not equal)
b=branches the program counter to dst (pc aka r15)
bcc=branch if C clear (no carry)
bcs=branch if C set (carry)
beq=branches if equal (see 'b') Z is set
bge=branch if N clear and V clear
bgt=branch if Z, N and V clear
bhi=branch if C set and Z clear
bic=logical bit clear
bl=branches and link, similar to call in i386, set lr(r14) = pc, changes pc (r15) )
ble=branch if (Z || (N && V)) or !N && V) or !N && V
bls=branch if C clear or Z set
blt=branch if N clear and V set
blx=branch link and optionally exchange to Thumb
bmi=branch if N set
bne=branch if Z clear (not equal)
bpl=branch if N clear
bvc=branch if V clear
bvs=branch if V set
bx=branches and exchanges cpu mode to 16 bits (thumb mode)
bxj=branches and exchanges cpu mode to Jazzele (jumps to a bytecode vector)
cdp=coprocessor data operations
cmn=compare negated
cmp=compare
cmp=compares two registers
cps=change processor state
eor=logical exclusive OR (XOR)
eoreq=logical exclusive OR (XOR) if Z set (equal)
eorne=logical exclusive OR (XOR) if Z clear (not equal)
flt=armfpu: convert int to float: flt 
ldc=load from memory to coprocessor
ldf=armfpu: load float value pointed by reg+(offset): ldf f0, [r0,#off]
ldmda=decrement after
ldmdb=decrement before
ldmia=incrememnt after
ldmib=increment before
ldr=load from memory to register
ldreq=load from memory to register if Z set (equal)
ldrne=load from memory to register if Z clear (not equal)
mcr=move to coprocessor from ARM register
mcrr=move to coprocessor from two ARM register
mov.w=move 3byte immediate into register
mov=move value between registers
movs=move byte into register
movt=write 16 bit value on top of halfword
movw=write 16 bit value on lower bits
orr=logical inclusive OR
orreq=logical inclusive OR if Z set (equal)
orrne=logical inclusive OR if Z clear (not equal)
rfe=return from exception (loads pc+cpsr)
rsb=reverse substract
rsc=reverse substract with carry
sbc=substract with carry
sbfx=signed bit field extract
srs=store return state
stc=store coprocessor register
stc=store from coprocessor to memory
stf=armfpu: store float value pointed by reg+(offset): ldf [r0,#off]
str=store register into memory
strd=store floating point value in memory
streq=store register into memory if Z set (equal)
strne=store register into memory if Z clear (not equal)
sub=substract two values
subeq=substract two values if Z set (equal)
subne=substract two values if Z clear (not equal)
svc=supervisor call
teq=test equivalence
tst.w=logical AND register value with 12-bit immediate value
tst=test
ubfx=unsigned bit field extract
uxtab16=zero extend bytes to halfwords add halfwords
uxtab=zero extend byte to word, add
vadd=vector add
vsri=vector shift right and insert
wfs=armfpu: write fp status register. wfs r0
