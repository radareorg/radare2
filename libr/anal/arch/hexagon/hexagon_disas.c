/* radare - LGPL - Copyright 2018-2021 - xvilka */

#include <stdbool.h>
#include <r_types.h>
#include <r_util.h>
#include <r_asm.h>
#include "hexagon.h"
#include "hexagon_insn.h"

extern ut32 constant_extender;

int hexagon_disasm_instruction(ut32 hi_u32, HexInsn *hi, ut32 addr) {
	// DUPLEXES
	if (((hi_u32 >> 14) & 0x3) == 0) {
		switch ((((hi_u32 >> 29) & 0xF) << 1) | ((hi_u32 >> 13) & 1)) {
			case 0x0: {
				if ((hi_u32 & 0xf000f000) == 0x10001000) {
					// Instruction: 0: 0001IIIIuuuueeee0001iiiissssdddd | Re = memub (Ru + #U4:0) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RU____U4_0____RD___MEMUB__RS____U4_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0x1000) {
					// Instruction: 0: 0000IIIIuuuueeee0001iiiissssdddd | Re = memw (Ru + #U4:2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RU____U4_2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0x0) {
					// Instruction: 0: 0000IIIIuuuueeee0000iiiissssdddd | Re = memw (Ru + #U4:2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RU____U4_2____RD___MEMW__RS____U4_2_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				break;
			}
			case 0x1: {
				if ((hi_u32 & 0xf000ffc4) == 0x10003f40) {
					// Instruction: 1: 0001iiiissssdddd0011111101---0-- | Rd = memub (Rs + #u4:0) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc4) == 0x10003f00) {
					// Instruction: 1: 0001iiiissssdddd0011111100---0-- | Rd = memub (Rs + #u4:0) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____DEALLOCFRAME;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003f45) {
					// Instruction: 1: 0001iiiissssdddd0011111101---101 | Rd = memub (Rs + #u4:0) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003fc5) {
					// Instruction: 1: 0001iiiissssdddd0011111111---101 | Rd = memub (Rs + #u4:0) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003f47) {
					// Instruction: 1: 0001iiiissssdddd0011111101---111 | Rd = memub (Rs + #u4:0) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003fc7) {
					// Instruction: 1: 0001iiiissssdddd0011111111---111 | Rd = memub (Rs + #u4:0) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003f44) {
					// Instruction: 1: 0001iiiissssdddd0011111101---100 | Rd = memub (Rs + #u4:0) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003fc4) {
					// Instruction: 1: 0001iiiissssdddd0011111111---100 | Rd = memub (Rs + #u4:0) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003f46) {
					// Instruction: 1: 0001iiiissssdddd0011111101---110 | Rd = memub (Rs + #u4:0) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x10003fc6) {
					// Instruction: 1: 0001iiiissssdddd0011111111---110 | Rd = memub (Rs + #u4:0) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc4) == 0x10003fc0) {
					// Instruction: 1: 0001iiiissssdddd0011111111---0-- | Rd = memub (Rs + #u4:0) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc4) == 0x3f40) {
					// Instruction: 1: 0000iiiissssdddd0011111101---0-- | Rd = memw (Rs + #u4:2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc4) == 0x3f00) {
					// Instruction: 1: 0000iiiissssdddd0011111100---0-- | Rd = memw (Rs + #u4:2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____DEALLOCFRAME;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3f45) {
					// Instruction: 1: 0000iiiissssdddd0011111101---101 | Rd = memw (Rs + #u4:2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3fc5) {
					// Instruction: 1: 0000iiiissssdddd0011111111---101 | Rd = memw (Rs + #u4:2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3f47) {
					// Instruction: 1: 0000iiiissssdddd0011111101---111 | Rd = memw (Rs + #u4:2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3fc7) {
					// Instruction: 1: 0000iiiissssdddd0011111111---111 | Rd = memw (Rs + #u4:2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3f44) {
					// Instruction: 1: 0000iiiissssdddd0011111101---100 | Rd = memw (Rs + #u4:2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3fc4) {
					// Instruction: 1: 0000iiiissssdddd0011111111---100 | Rd = memw (Rs + #u4:2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3f46) {
					// Instruction: 1: 0000iiiissssdddd0011111101---110 | Rd = memw (Rs + #u4:2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc7) == 0x3fc6) {
					// Instruction: 1: 0000iiiissssdddd0011111111---110 | Rd = memw (Rs + #u4:2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ffc4) == 0x3fc0) {
					// Instruction: 1: 0000iiiissssdddd0011111111---0-- | Rd = memw (Rs + #u4:2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0x10003c00) {
					// Instruction: 1: 0001IIIIsssseeee0011110iiiiidddd | Re = memub (Rs + #U4:0) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RS____U4_0____RD___MEMW__SP____U5_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0x10003e00) {
					// Instruction: 1: 0001IIIIsssseeee00111110iiiiiddd | Re = memub (Rs + #U4:0) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RS____U4_0____RDD___MEMD__SP____U5_3_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x10003000) {
					// Instruction: 1: 0001IIIIuuuueeee00110iiissssdddd | Re = memub (Ru + #U4:0) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RU____U4_0____RD___MEMB__RS____U3_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x10002000) {
					// Instruction: 1: 0001IIIIuuuueeee00100iiissssdddd | Re = memub (Ru + #U4:0) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RU____U4_0____RD___MEMH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x10002800) {
					// Instruction: 1: 0001IIIIuuuueeee00101iiissssdddd | Re = memub (Ru + #U4:0) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUB__RU____U4_0____RD___MEMUH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0x3c00) {
					// Instruction: 1: 0000IIIIsssseeee0011110iiiiidddd | Re = memw (Rs + #U4:2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RS____U4_2____RD___MEMW__SP____U5_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0x3e00) {
					// Instruction: 1: 0000IIIIsssseeee00111110iiiiiddd | Re = memw (Rs + #U4:2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RS____U4_2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x3000) {
					// Instruction: 1: 0000IIIIuuuueeee00110iiissssdddd | Re = memw (Ru + #U4:2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RU____U4_2____RD___MEMB__RS____U3_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x2000) {
					// Instruction: 1: 0000IIIIuuuueeee00100iiissssdddd | Re = memw (Ru + #U4:2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RU____U4_2____RD___MEMH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0x2800) {
					// Instruction: 1: 0000IIIIuuuueeee00101iiissssdddd | Re = memw (Ru + #U4:2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__RU____U4_2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				break;
			}
			case 0x2: {
				if ((hi_u32 & 0xf800ffc4) == 0x30001f40) {
					// Instruction: 2: 00110iiissssdddd0001111101---0-- | Rd = memb (Rs + #u3:0) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x30001f00) {
					// Instruction: 2: 00110iiissssdddd0001111100---0-- | Rd = memb (Rs + #u3:0) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____DEALLOCFRAME;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001f45) {
					// Instruction: 2: 00110iiissssdddd0001111101---101 | Rd = memb (Rs + #u3:0) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001fc5) {
					// Instruction: 2: 00110iiissssdddd0001111111---101 | Rd = memb (Rs + #u3:0) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001f47) {
					// Instruction: 2: 00110iiissssdddd0001111101---111 | Rd = memb (Rs + #u3:0) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001fc7) {
					// Instruction: 2: 00110iiissssdddd0001111111---111 | Rd = memb (Rs + #u3:0) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001f44) {
					// Instruction: 2: 00110iiissssdddd0001111101---100 | Rd = memb (Rs + #u3:0) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001fc4) {
					// Instruction: 2: 00110iiissssdddd0001111111---100 | Rd = memb (Rs + #u3:0) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001f46) {
					// Instruction: 2: 00110iiissssdddd0001111101---110 | Rd = memb (Rs + #u3:0) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x30001fc6) {
					// Instruction: 2: 00110iiissssdddd0001111111---110 | Rd = memb (Rs + #u3:0) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x30001fc0) {
					// Instruction: 2: 00110iiissssdddd0001111111---0-- | Rd = memb (Rs + #u3:0) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x20001f40) {
					// Instruction: 2: 00100iiissssdddd0001111101---0-- | Rd = memh (Rs + #u3:1) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x20001f00) {
					// Instruction: 2: 00100iiissssdddd0001111100---0-- | Rd = memh (Rs + #u3:1) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____DEALLOCFRAME;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001f45) {
					// Instruction: 2: 00100iiissssdddd0001111101---101 | Rd = memh (Rs + #u3:1) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001fc5) {
					// Instruction: 2: 00100iiissssdddd0001111111---101 | Rd = memh (Rs + #u3:1) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001f47) {
					// Instruction: 2: 00100iiissssdddd0001111101---111 | Rd = memh (Rs + #u3:1) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001fc7) {
					// Instruction: 2: 00100iiissssdddd0001111111---111 | Rd = memh (Rs + #u3:1) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001f44) {
					// Instruction: 2: 00100iiissssdddd0001111101---100 | Rd = memh (Rs + #u3:1) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001fc4) {
					// Instruction: 2: 00100iiissssdddd0001111111---100 | Rd = memh (Rs + #u3:1) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001f46) {
					// Instruction: 2: 00100iiissssdddd0001111101---110 | Rd = memh (Rs + #u3:1) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x20001fc6) {
					// Instruction: 2: 00100iiissssdddd0001111111---110 | Rd = memh (Rs + #u3:1) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x20001fc0) {
					// Instruction: 2: 00100iiissssdddd0001111111---0-- | Rd = memh (Rs + #u3:1) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x28001f40) {
					// Instruction: 2: 00101iiissssdddd0001111101---0-- | Rd = memuh (Rs + #u3:1) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x28001f00) {
					// Instruction: 2: 00101iiissssdddd0001111100---0-- | Rd = memuh (Rs + #u3:1) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____DEALLOCFRAME;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001f45) {
					// Instruction: 2: 00101iiissssdddd0001111101---101 | Rd = memuh (Rs + #u3:1) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001fc5) {
					// Instruction: 2: 00101iiissssdddd0001111111---101 | Rd = memuh (Rs + #u3:1) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001f47) {
					// Instruction: 2: 00101iiissssdddd0001111101---111 | Rd = memuh (Rs + #u3:1) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001fc7) {
					// Instruction: 2: 00101iiissssdddd0001111111---111 | Rd = memuh (Rs + #u3:1) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001f44) {
					// Instruction: 2: 00101iiissssdddd0001111101---100 | Rd = memuh (Rs + #u3:1) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF__P0__DEALLOC_RETURN;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001fc4) {
					// Instruction: 2: 00101iiissssdddd0001111111---100 | Rd = memuh (Rs + #u3:1) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF__P0__JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001f46) {
					// Instruction: 2: 00101iiissssdddd0001111101---110 | Rd = memuh (Rs + #u3:1) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x28001fc6) {
					// Instruction: 2: 00101iiissssdddd0001111111---110 | Rd = memuh (Rs + #u3:1) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x28001fc0) {
					// Instruction: 2: 00101iiissssdddd0001111111---0-- | Rd = memuh (Rs + #u3:1) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____JUMPR_LR;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc4) == 0x3c001f40) {
					// Instruction: 2: 0011110iiiiidddd0001111101---0-- | Rd = memw (Sp + #u5:2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc4) == 0x3c001f00) {
					// Instruction: 2: 0011110iiiiidddd0001111100---0-- | Rd = memw (Sp + #u5:2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001f45) {
					// Instruction: 2: 0011110iiiiidddd0001111101---101 | Rd = memw (Sp + #u5:2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001fc5) {
					// Instruction: 2: 0011110iiiiidddd0001111111---101 | Rd = memw (Sp + #u5:2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001f47) {
					// Instruction: 2: 0011110iiiiidddd0001111101---111 | Rd = memw (Sp + #u5:2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001fc7) {
					// Instruction: 2: 0011110iiiiidddd0001111111---111 | Rd = memw (Sp + #u5:2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001f44) {
					// Instruction: 2: 0011110iiiiidddd0001111101---100 | Rd = memw (Sp + #u5:2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001fc4) {
					// Instruction: 2: 0011110iiiiidddd0001111111---100 | Rd = memw (Sp + #u5:2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001f46) {
					// Instruction: 2: 0011110iiiiidddd0001111101---110 | Rd = memw (Sp + #u5:2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc7) == 0x3c001fc6) {
					// Instruction: 2: 0011110iiiiidddd0001111111---110 | Rd = memw (Sp + #u5:2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ffc4) == 0x3c001fc0) {
					// Instruction: 2: 0011110iiiiidddd0001111111---0-- | Rd = memw (Sp + #u5:2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x3e001f40) {
					// Instruction: 2: 00111110iiiiiddd0001111101---0-- | Rdd = memd (Sp + #u5:3) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x3e001f00) {
					// Instruction: 2: 00111110iiiiiddd0001111100---0-- | Rdd = memd (Sp + #u5:3) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001f45) {
					// Instruction: 2: 00111110iiiiiddd0001111101---101 | Rdd = memd (Sp + #u5:3) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001fc5) {
					// Instruction: 2: 00111110iiiiiddd0001111111---101 | Rdd = memd (Sp + #u5:3) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001f47) {
					// Instruction: 2: 00111110iiiiiddd0001111101---111 | Rdd = memd (Sp + #u5:3) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001fc7) {
					// Instruction: 2: 00111110iiiiiddd0001111111---111 | Rdd = memd (Sp + #u5:3) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001f44) {
					// Instruction: 2: 00111110iiiiiddd0001111101---100 | Rdd = memd (Sp + #u5:3) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001fc4) {
					// Instruction: 2: 00111110iiiiiddd0001111111---100 | Rdd = memd (Sp + #u5:3) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001f46) {
					// Instruction: 2: 00111110iiiiiddd0001111101---110 | Rdd = memd (Sp + #u5:3) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x3e001fc6) {
					// Instruction: 2: 00111110iiiiiddd0001111111---110 | Rdd = memd (Sp + #u5:3) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x3e001fc0) {
					// Instruction: 2: 00111110iiiiiddd0001111111---0-- | Rdd = memd (Sp + #u5:3) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x30001c00) {
					// Instruction: 2: 00110IIIsssseeee0001110iiiiidddd | Re = memb (Rs + #U3:0) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMB__RS____U3_0____RD___MEMW__SP____U5_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x30001e00) {
					// Instruction: 2: 00110IIIsssseeee00011110iiiiiddd | Re = memb (Rs + #U3:0) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMB__RS____U3_0____RDD___MEMD__SP____U5_3_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x30001000) {
					// Instruction: 2: 00110IIIuuuueeee00010iiissssdddd | Re = memb (Ru + #U3:0) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMB__RU____U3_0____RD___MEMB__RS____U3_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x20001c00) {
					// Instruction: 2: 00100IIIsssseeee0001110iiiiidddd | Re = memh (Rs + #U3:1) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMH__RS____U3_1____RD___MEMW__SP____U5_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20001e00) {
					// Instruction: 2: 00100IIIsssseeee00011110iiiiiddd | Re = memh (Rs + #U3:1) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMH__RS____U3_1____RDD___MEMD__SP____U5_3_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x20001000) {
					// Instruction: 2: 00100IIIuuuueeee00010iiissssdddd | Re = memh (Ru + #U3:1) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMH__RU____U3_1____RD___MEMB__RS____U3_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x20000000) {
					// Instruction: 2: 00100IIIuuuueeee00000iiissssdddd | Re = memh (Ru + #U3:1) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMH__RU____U3_1____RD___MEMH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x20000800) {
					// Instruction: 2: 00100IIIuuuueeee00001iiissssdddd | Re = memh (Ru + #U3:1) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMH__RU____U3_1____RD___MEMUH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x28001c00) {
					// Instruction: 2: 00101IIIsssseeee0001110iiiiidddd | Re = memuh (Rs + #U3:1) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUH__RS____U3_1____RD___MEMW__SP____U5_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x28001e00) {
					// Instruction: 2: 00101IIIsssseeee00011110iiiiiddd | Re = memuh (Rs + #U3:1) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUH__RS____U3_1____RDD___MEMD__SP____U5_3_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x28001000) {
					// Instruction: 2: 00101IIIuuuueeee00010iiissssdddd | Re = memuh (Ru + #U3:1) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUH__RU____U3_1____RD___MEMB__RS____U3_0_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x28000800) {
					// Instruction: 2: 00101IIIuuuueeee00001iiissssdddd | Re = memuh (Ru + #U3:1) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMUH__RU____U3_1____RD___MEMUH__RS____U3_1_;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[5].type = HEX_OP_TYPE_IMM;
					hi->ops[5].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hex_get_sub_reg(hi->ops[4].op.reg), hi->ops[5].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0x3c001c00) {
					// Instruction: 2: 0011110IIIIIeeee0001110iiiiidddd | Re = memw (Sp + #U5:2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__SP____U5_2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0x3c001e00) {
					// Instruction: 2: 0011110IIIIIeeee00011110iiiiiddd | Re = memw (Sp + #U5:2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___MEMW__SP____U5_2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x3e001e00) {
					// Instruction: 2: 00111110IIIIIeee00011110iiiiiddd | Ree = memd (Sp + #U5:3) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___MEMD__SP____U5_3____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xffc4ffc7) == 0x3f001fc5) {
					// Instruction: 2: 0011111100---0--0001111111---101 | deallocframe ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 0;
					hi->duplex = true;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; if (! p0) jumpr Lr");
					break;
				}
				if ((hi_u32 & 0xffc4ffc7) == 0x3f001fc7) {
					// Instruction: 2: 0011111100---0--0001111111---111 | deallocframe ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 0;
					hi->duplex = true;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; if (! p0.new) jumpr:nt Lr");
					break;
				}
				if ((hi_u32 & 0xffc4ffc7) == 0x3f001fc4) {
					// Instruction: 2: 0011111100---0--0001111111---100 | deallocframe ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___IF__P0__JUMPR_LR;
					hi->op_count = 0;
					hi->duplex = true;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; if (p0) jumpr Lr");
					break;
				}
				if ((hi_u32 & 0xffc4ffc7) == 0x3f001fc6) {
					// Instruction: 2: 0011111100---0--0001111111---110 | deallocframe ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 0;
					hi->duplex = true;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; if (p0.new) jumpr:nt Lr");
					break;
				}
				if ((hi_u32 & 0xffc4ffc4) == 0x3f001fc0) {
					// Instruction: 2: 0011111100---0--0001111111---0-- | deallocframe ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___JUMPR_LR;
					hi->op_count = 0;
					hi->duplex = true;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; jumpr Lr");
					break;
				}
				break;
			}
			case 0x3: {
				if ((hi_u32 & 0xfc00ff00) == 0x28003900) {
					// Instruction: 3: 001010IIIIIIdddd00111001ssss--ii | Rd = #U6 ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD____U6___P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003800) {
					// Instruction: 3: 001010iiiiiidddd00111000ssssxxxx | Rd = #u6 ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD____U6___RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003800) {
					// Instruction: 3: 001010iiiiiidddd00111000ssssxxxx | Rd = #u6 ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD____U6___RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003800) {
					// Instruction: 3: 00110000uuuudddd00111000ssssxxxx | Rd = Ru ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___RU___RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003800) {
					// Instruction: 3: 00110000uuuudddd00111000ssssxxxx | Rd = Ru ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___RU___RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003900) {
					// Instruction: 3: 00110000uuuudddd00111001ssss--ii | Rd = Ru ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___RU___P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003800) {
					// Instruction: 3: 00110011uuuudddd00111000ssssxxxx | Rd = add (Ru, #-1) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003800) {
					// Instruction: 3: 00110011uuuudddd00111000ssssxxxx | Rd = add (Ru, #-1) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003900) {
					// Instruction: 3: 00110011uuuudddd00111001ssss--ii | Rd = add (Ru, #-1) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003800) {
					// Instruction: 3: 00110001uuuudddd00111000ssssxxxx | Rd = add (Ru, #1) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003800) {
					// Instruction: 3: 00110001uuuudddd00111000ssssxxxx | Rd = add (Ru, #1) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003900) {
					// Instruction: 3: 00110001uuuudddd00111001ssss--ii | Rd = add (Ru, #1) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003900) {
					// Instruction: 3: 001011IIIIIIdddd00111001ssss--ii | Rd = add (Sp, #U6:2) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003800) {
					// Instruction: 3: 001011iiiiiidddd00111000ssssxxxx | Rd = add (Sp, #u6:2) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003800) {
					// Instruction: 3: 001011iiiiiidddd00111000ssssxxxx | Rd = add (Sp, #u6:2) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003800) {
					// Instruction: 3: 00110010uuuudddd00111000ssssxxxx | Rd = and (Ru, #1) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003800) {
					// Instruction: 3: 00110010uuuudddd00111000ssssxxxx | Rd = and (Ru, #1) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003900) {
					// Instruction: 3: 00110010uuuudddd00111001ssss--ii | Rd = and (Ru, #1) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x37003800) {
					// Instruction: 3: 00110111uuuudddd00111000ssssxxxx | Rd = and (Ru, #255) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x37003800) {
					// Instruction: 3: 00110111uuuudddd00111000ssssxxxx | Rd = and (Ru, #255) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x37003900) {
					// Instruction: 3: 00110111uuuudddd00111001ssss--ii | Rd = and (Ru, #255) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003800) {
					// Instruction: 3: 00110101uuuudddd00111000ssssxxxx | Rd = sxtb (Ru) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003800) {
					// Instruction: 3: 00110101uuuudddd00111000ssssxxxx | Rd = sxtb (Ru) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003900) {
					// Instruction: 3: 00110101uuuudddd00111001ssss--ii | Rd = sxtb (Ru) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003800) {
					// Instruction: 3: 00110100uuuudddd00111000ssssxxxx | Rd = sxth (Ru) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003800) {
					// Instruction: 3: 00110100uuuudddd00111000ssssxxxx | Rd = sxth (Ru) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003900) {
					// Instruction: 3: 00110100uuuudddd00111001ssss--ii | Rd = sxth (Ru) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x36003800) {
					// Instruction: 3: 00110110uuuudddd00111000ssssxxxx | Rd = zxth (Ru) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x36003800) {
					// Instruction: 3: 00110110uuuudddd00111000ssssxxxx | Rd = zxth (Ru) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x36003900) {
					// Instruction: 3: 00110110uuuudddd00111001ssss--ii | Rd = zxth (Ru) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fe40) == 0x3a003a00) {
					// Instruction: 3: 0011101--0--eeee0011101--0--dddd | Re = #-1 ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD_____1;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fd18) == 0x3a003c00) {
					// Instruction: 3: 0011101--0--eeee001111-0-ii00ddd | Re = #-1 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE___0___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fd08) == 0x3a003d00) {
					// Instruction: 3: 0011101--0--eeee001111-1ssss0ddd | Re = #-1 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE___0__RS_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fd18) == 0x3a003c08) {
					// Instruction: 3: 0011101--0--eeee001111-0-ii01ddd | Re = #-1 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE___1___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fd18) == 0x3a003c10) {
					// Instruction: 3: 0011101--0--eeee001111-0-ii10ddd | Re = #-1 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE___2___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fd18) == 0x3a003c18) {
					// Instruction: 3: 0011101--0--eeee001111-0-ii11ddd | Re = #-1 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE___3___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fd08) == 0x3a003d08) {
					// Instruction: 3: 0011101--0--eeee001111-1ssss1ddd | Re = #-1 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___COMBINE__RS___0_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fe70) == 0x3a003a70) {
					// Instruction: 3: 0011101--0--eeee0011101--111dddd | Re = #-1 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE_____1___IF___NOT__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fe70) == 0x3a003a50) {
					// Instruction: 3: 0011101--0--eeee0011101--101dddd | Re = #-1 ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE_____1___IF___NOT__P0_NEW__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fe70) == 0x3a003a60) {
					// Instruction: 3: 0011101--0--eeee0011101--110dddd | Re = #-1 ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE_____1___IF__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40fe70) == 0x3a003a40) {
					// Instruction: 3: 0011101--0--eeee0011101--100dddd | Re = #-1 ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE_____1___IF__P0_NEW__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe40) == 0x28003a00) {
					// Instruction: 3: 001010IIIIIIeeee0011101--0--dddd | Re = #U6 ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fc00) == 0x28002800) {
					// Instruction: 3: 001010IIIIIIeeee001010iiiiiidddd | Re = #U6 ; Rd = #u6
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD____U6;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f0) >> 4);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = 0x%x", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003300) {
					// Instruction: 3: 001010IIIIIIeeee00110011ssssdddd | Re = #U6 ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003100) {
					// Instruction: 3: 001010IIIIIIeeee00110001ssssdddd | Re = #U6 ; Rd = add (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___ADD__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = add (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fc00) == 0x28002c00) {
					// Instruction: 3: 001010IIIIIIeeee001011iiiiiidddd | Re = #U6 ; Rd = add (Sp, #u6:2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___ADD__SP___U6_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = add (Sp, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003200) {
					// Instruction: 3: 001010IIIIIIeeee00110010ssssdddd | Re = #U6 ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003700) {
					// Instruction: 3: 001010IIIIIIeeee00110111ssssdddd | Re = #U6 ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x28003c00) {
					// Instruction: 3: 001010IIIIIIeeee001111-0-ii00ddd | Re = #U6 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd08) == 0x28003d00) {
					// Instruction: 3: 001010IIIIIIeeee001111-1ssss0ddd | Re = #U6 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x28003c08) {
					// Instruction: 3: 001010IIIIIIeeee001111-0-ii01ddd | Re = #U6 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x28003c10) {
					// Instruction: 3: 001010IIIIIIeeee001111-0-ii10ddd | Re = #U6 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x28003c18) {
					// Instruction: 3: 001010IIIIIIeeee001111-0-ii11ddd | Re = #U6 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd08) == 0x28003d08) {
					// Instruction: 3: 001010IIIIIIeeee001111-1ssss1ddd | Re = #U6 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x28003a70) {
					// Instruction: 3: 001010IIIIIIeeee0011101--111dddd | Re = #U6 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE____U6___IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x28003a50) {
					// Instruction: 3: 001010IIIIIIeeee0011101--101dddd | Re = #U6 ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE____U6___IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x28003a60) {
					// Instruction: 3: 001010IIIIIIeeee0011101--110dddd | Re = #U6 ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE____U6___IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x28003a40) {
					// Instruction: 3: 001010IIIIIIeeee0011101--100dddd | Re = #U6 ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE____U6___IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003000) {
					// Instruction: 3: 001010iiiiiieeee00110000ssssdddd | Re = #u6 ; Rd = Rs
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___RS;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003500) {
					// Instruction: 3: 001010iiiiiieeee00110101ssssdddd | Re = #u6 ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003400) {
					// Instruction: 3: 001010iiiiiieeee00110100ssssdddd | Re = #u6 ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x28003600) {
					// Instruction: 3: 001010iiiiiieeee00110110ssssdddd | Re = #u6 ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x30003a00) {
					// Instruction: 3: 00110000sssseeee0011101--0--dddd | Re = Rs ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x30003c00) {
					// Instruction: 3: 00110000sssseeee001111-0-ii00ddd | Re = Rs ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x30003c08) {
					// Instruction: 3: 00110000sssseeee001111-0-ii01ddd | Re = Rs ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x30003c10) {
					// Instruction: 3: 00110000sssseeee001111-0-ii10ddd | Re = Rs ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x30003c18) {
					// Instruction: 3: 00110000sssseeee001111-0-ii11ddd | Re = Rs ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x30003a70) {
					// Instruction: 3: 00110000sssseeee0011101--111dddd | Re = Rs ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___RS___IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x30003a50) {
					// Instruction: 3: 00110000sssseeee0011101--101dddd | Re = Rs ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___RS___IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x30003a60) {
					// Instruction: 3: 00110000sssseeee0011101--110dddd | Re = Rs ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___RS___IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x30003a40) {
					// Instruction: 3: 00110000sssseeee0011101--100dddd | Re = Rs ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___RS___IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003000) {
					// Instruction: 3: 00110000uuuueeee00110000ssssdddd | Re = Ru ; Rd = Rs
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___RS;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003300) {
					// Instruction: 3: 00110000uuuueeee00110011ssssdddd | Re = Ru ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003100) {
					// Instruction: 3: 00110000uuuueeee00110001ssssdddd | Re = Ru ; Rd = add (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___ADD__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = add (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003200) {
					// Instruction: 3: 00110000uuuueeee00110010ssssdddd | Re = Ru ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003700) {
					// Instruction: 3: 00110000uuuueeee00110111ssssdddd | Re = Ru ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003500) {
					// Instruction: 3: 00110000uuuueeee00110101ssssdddd | Re = Ru ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003400) {
					// Instruction: 3: 00110000uuuueeee00110100ssssdddd | Re = Ru ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x30003600) {
					// Instruction: 3: 00110000uuuueeee00110110ssssdddd | Re = Ru ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x30003d00) {
					// Instruction: 3: 00110000uuuueeee001111-1ssss0ddd | Re = Ru ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x30003d08) {
					// Instruction: 3: 00110000uuuueeee001111-1ssss1ddd | Re = Ru ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x33003a00) {
					// Instruction: 3: 00110011sssseeee0011101--0--dddd | Re = add (Rs, #-1) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x33003c00) {
					// Instruction: 3: 00110011sssseeee001111-0-ii00ddd | Re = add (Rs, #-1) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x33003c08) {
					// Instruction: 3: 00110011sssseeee001111-0-ii01ddd | Re = add (Rs, #-1) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x33003c10) {
					// Instruction: 3: 00110011sssseeee001111-0-ii10ddd | Re = add (Rs, #-1) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x33003c18) {
					// Instruction: 3: 00110011sssseeee001111-0-ii11ddd | Re = add (Rs, #-1) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x33003a70) {
					// Instruction: 3: 00110011sssseeee0011101--111dddd | Re = add (Rs, #-1) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x33003a50) {
					// Instruction: 3: 00110011sssseeee0011101--101dddd | Re = add (Rs, #-1) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x33003a60) {
					// Instruction: 3: 00110011sssseeee0011101--110dddd | Re = add (Rs, #-1) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x33003a40) {
					// Instruction: 3: 00110011sssseeee0011101--100dddd | Re = add (Rs, #-1) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x31003a00) {
					// Instruction: 3: 00110001sssseeee0011101--0--dddd | Re = add (Rs, #1) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x31003c00) {
					// Instruction: 3: 00110001sssseeee001111-0-ii00ddd | Re = add (Rs, #1) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x31003c08) {
					// Instruction: 3: 00110001sssseeee001111-0-ii01ddd | Re = add (Rs, #1) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x31003c10) {
					// Instruction: 3: 00110001sssseeee001111-0-ii10ddd | Re = add (Rs, #1) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x31003c18) {
					// Instruction: 3: 00110001sssseeee001111-0-ii11ddd | Re = add (Rs, #1) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x31003a70) {
					// Instruction: 3: 00110001sssseeee0011101--111dddd | Re = add (Rs, #1) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x31003a50) {
					// Instruction: 3: 00110001sssseeee0011101--101dddd | Re = add (Rs, #1) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x31003a60) {
					// Instruction: 3: 00110001sssseeee0011101--110dddd | Re = add (Rs, #1) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x31003a40) {
					// Instruction: 3: 00110001sssseeee0011101--100dddd | Re = add (Rs, #1) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003300) {
					// Instruction: 3: 00110011uuuueeee00110011ssssdddd | Re = add (Ru, #-1) ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003700) {
					// Instruction: 3: 00110011uuuueeee00110111ssssdddd | Re = add (Ru, #-1) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003500) {
					// Instruction: 3: 00110011uuuueeee00110101ssssdddd | Re = add (Ru, #-1) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003400) {
					// Instruction: 3: 00110011uuuueeee00110100ssssdddd | Re = add (Ru, #-1) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x33003600) {
					// Instruction: 3: 00110011uuuueeee00110110ssssdddd | Re = add (Ru, #-1) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x33003d00) {
					// Instruction: 3: 00110011uuuueeee001111-1ssss0ddd | Re = add (Ru, #-1) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x33003d08) {
					// Instruction: 3: 00110011uuuueeee001111-1ssss1ddd | Re = add (Ru, #-1) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003300) {
					// Instruction: 3: 00110001uuuueeee00110011ssssdddd | Re = add (Ru, #1) ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003100) {
					// Instruction: 3: 00110001uuuueeee00110001ssssdddd | Re = add (Ru, #1) ; Rd = add (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___ADD__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = add (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003200) {
					// Instruction: 3: 00110001uuuueeee00110010ssssdddd | Re = add (Ru, #1) ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003700) {
					// Instruction: 3: 00110001uuuueeee00110111ssssdddd | Re = add (Ru, #1) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003500) {
					// Instruction: 3: 00110001uuuueeee00110101ssssdddd | Re = add (Ru, #1) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003400) {
					// Instruction: 3: 00110001uuuueeee00110100ssssdddd | Re = add (Ru, #1) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x31003600) {
					// Instruction: 3: 00110001uuuueeee00110110ssssdddd | Re = add (Ru, #1) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x31003d00) {
					// Instruction: 3: 00110001uuuueeee001111-1ssss0ddd | Re = add (Ru, #1) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x31003d08) {
					// Instruction: 3: 00110001uuuueeee001111-1ssss1ddd | Re = add (Ru, #1) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe40) == 0x2c003a00) {
					// Instruction: 3: 001011IIIIIIeeee0011101--0--dddd | Re = add (Sp, #U6:2) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003300) {
					// Instruction: 3: 001011IIIIIIeeee00110011ssssdddd | Re = add (Sp, #U6:2) ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003100) {
					// Instruction: 3: 001011IIIIIIeeee00110001ssssdddd | Re = add (Sp, #U6:2) ; Rd = add (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___ADD__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = add (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fc00) == 0x2c002c00) {
					// Instruction: 3: 001011IIIIIIeeee001011iiiiiidddd | Re = add (Sp, #U6:2) ; Rd = add (Sp, #u6:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___ADD__SP___U6_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = add (Sp, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003200) {
					// Instruction: 3: 001011IIIIIIeeee00110010ssssdddd | Re = add (Sp, #U6:2) ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003700) {
					// Instruction: 3: 001011IIIIIIeeee00110111ssssdddd | Re = add (Sp, #U6:2) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x2c003c00) {
					// Instruction: 3: 001011IIIIIIeeee001111-0-ii00ddd | Re = add (Sp, #U6:2) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd08) == 0x2c003d00) {
					// Instruction: 3: 001011IIIIIIeeee001111-1ssss0ddd | Re = add (Sp, #U6:2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x2c003c08) {
					// Instruction: 3: 001011IIIIIIeeee001111-0-ii01ddd | Re = add (Sp, #U6:2) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x2c003c10) {
					// Instruction: 3: 001011IIIIIIeeee001111-0-ii10ddd | Re = add (Sp, #U6:2) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd18) == 0x2c003c18) {
					// Instruction: 3: 001011IIIIIIeeee001111-0-ii11ddd | Re = add (Sp, #U6:2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fd08) == 0x2c003d08) {
					// Instruction: 3: 001011IIIIIIeeee001111-1ssss1ddd | Re = add (Sp, #U6:2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x2c003a70) {
					// Instruction: 3: 001011IIIIIIeeee0011101--111dddd | Re = add (Sp, #U6:2) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x2c003a50) {
					// Instruction: 3: 001011IIIIIIeeee0011101--101dddd | Re = add (Sp, #U6:2) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x2c003a60) {
					// Instruction: 3: 001011IIIIIIeeee0011101--110dddd | Re = add (Sp, #U6:2) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe70) == 0x2c003a40) {
					// Instruction: 3: 001011IIIIIIeeee0011101--100dddd | Re = add (Sp, #U6:2) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003000) {
					// Instruction: 3: 001011iiiiiieeee00110000ssssdddd | Re = add (Sp, #u6:2) ; Rd = Rs
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___RS;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003500) {
					// Instruction: 3: 001011iiiiiieeee00110101ssssdddd | Re = add (Sp, #u6:2) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003400) {
					// Instruction: 3: 001011iiiiiieeee00110100ssssdddd | Re = add (Sp, #u6:2) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x2c003600) {
					// Instruction: 3: 001011iiiiiieeee00110110ssssdddd | Re = add (Sp, #u6:2) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x32003a00) {
					// Instruction: 3: 00110010sssseeee0011101--0--dddd | Re = and (Rs, #1) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x32003c00) {
					// Instruction: 3: 00110010sssseeee001111-0-ii00ddd | Re = and (Rs, #1) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x32003c08) {
					// Instruction: 3: 00110010sssseeee001111-0-ii01ddd | Re = and (Rs, #1) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x32003c10) {
					// Instruction: 3: 00110010sssseeee001111-0-ii10ddd | Re = and (Rs, #1) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x32003c18) {
					// Instruction: 3: 00110010sssseeee001111-0-ii11ddd | Re = and (Rs, #1) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x32003a70) {
					// Instruction: 3: 00110010sssseeee0011101--111dddd | Re = and (Rs, #1) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x32003a50) {
					// Instruction: 3: 00110010sssseeee0011101--101dddd | Re = and (Rs, #1) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x32003a60) {
					// Instruction: 3: 00110010sssseeee0011101--110dddd | Re = and (Rs, #1) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x32003a40) {
					// Instruction: 3: 00110010sssseeee0011101--100dddd | Re = and (Rs, #1) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x37003a00) {
					// Instruction: 3: 00110111sssseeee0011101--0--dddd | Re = and (Rs, #255) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x37003c00) {
					// Instruction: 3: 00110111sssseeee001111-0-ii00ddd | Re = and (Rs, #255) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x37003c08) {
					// Instruction: 3: 00110111sssseeee001111-0-ii01ddd | Re = and (Rs, #255) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x37003c10) {
					// Instruction: 3: 00110111sssseeee001111-0-ii10ddd | Re = and (Rs, #255) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x37003c18) {
					// Instruction: 3: 00110111sssseeee001111-0-ii11ddd | Re = and (Rs, #255) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x37003a70) {
					// Instruction: 3: 00110111sssseeee0011101--111dddd | Re = and (Rs, #255) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x37003a50) {
					// Instruction: 3: 00110111sssseeee0011101--101dddd | Re = and (Rs, #255) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x37003a60) {
					// Instruction: 3: 00110111sssseeee0011101--110dddd | Re = and (Rs, #255) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x37003a40) {
					// Instruction: 3: 00110111sssseeee0011101--100dddd | Re = and (Rs, #255) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003300) {
					// Instruction: 3: 00110010uuuueeee00110011ssssdddd | Re = and (Ru, #1) ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003200) {
					// Instruction: 3: 00110010uuuueeee00110010ssssdddd | Re = and (Ru, #1) ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003700) {
					// Instruction: 3: 00110010uuuueeee00110111ssssdddd | Re = and (Ru, #1) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003500) {
					// Instruction: 3: 00110010uuuueeee00110101ssssdddd | Re = and (Ru, #1) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003400) {
					// Instruction: 3: 00110010uuuueeee00110100ssssdddd | Re = and (Ru, #1) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x32003600) {
					// Instruction: 3: 00110010uuuueeee00110110ssssdddd | Re = and (Ru, #1) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x32003d00) {
					// Instruction: 3: 00110010uuuueeee001111-1ssss0ddd | Re = and (Ru, #1) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x32003d08) {
					// Instruction: 3: 00110010uuuueeee001111-1ssss1ddd | Re = and (Ru, #1) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x37003700) {
					// Instruction: 3: 00110111uuuueeee00110111ssssdddd | Re = and (Ru, #255) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x37003d00) {
					// Instruction: 3: 00110111uuuueeee001111-1ssss0ddd | Re = and (Ru, #255) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x37003d08) {
					// Instruction: 3: 00110111uuuueeee001111-1ssss1ddd | Re = and (Ru, #255) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x35003a00) {
					// Instruction: 3: 00110101sssseeee0011101--0--dddd | Re = sxtb (Rs) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x35003c00) {
					// Instruction: 3: 00110101sssseeee001111-0-ii00ddd | Re = sxtb (Rs) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x35003c08) {
					// Instruction: 3: 00110101sssseeee001111-0-ii01ddd | Re = sxtb (Rs) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x35003c10) {
					// Instruction: 3: 00110101sssseeee001111-0-ii10ddd | Re = sxtb (Rs) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x35003c18) {
					// Instruction: 3: 00110101sssseeee001111-0-ii11ddd | Re = sxtb (Rs) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x35003a70) {
					// Instruction: 3: 00110101sssseeee0011101--111dddd | Re = sxtb (Rs) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x35003a50) {
					// Instruction: 3: 00110101sssseeee0011101--101dddd | Re = sxtb (Rs) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x35003a60) {
					// Instruction: 3: 00110101sssseeee0011101--110dddd | Re = sxtb (Rs) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x35003a40) {
					// Instruction: 3: 00110101sssseeee0011101--100dddd | Re = sxtb (Rs) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003700) {
					// Instruction: 3: 00110101uuuueeee00110111ssssdddd | Re = sxtb (Ru) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003500) {
					// Instruction: 3: 00110101uuuueeee00110101ssssdddd | Re = sxtb (Ru) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x35003600) {
					// Instruction: 3: 00110101uuuueeee00110110ssssdddd | Re = sxtb (Ru) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x35003d00) {
					// Instruction: 3: 00110101uuuueeee001111-1ssss0ddd | Re = sxtb (Ru) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x35003d08) {
					// Instruction: 3: 00110101uuuueeee001111-1ssss1ddd | Re = sxtb (Ru) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x34003a00) {
					// Instruction: 3: 00110100sssseeee0011101--0--dddd | Re = sxth (Rs) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x34003c00) {
					// Instruction: 3: 00110100sssseeee001111-0-ii00ddd | Re = sxth (Rs) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x34003c08) {
					// Instruction: 3: 00110100sssseeee001111-0-ii01ddd | Re = sxth (Rs) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x34003c10) {
					// Instruction: 3: 00110100sssseeee001111-0-ii10ddd | Re = sxth (Rs) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x34003c18) {
					// Instruction: 3: 00110100sssseeee001111-0-ii11ddd | Re = sxth (Rs) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x34003a70) {
					// Instruction: 3: 00110100sssseeee0011101--111dddd | Re = sxth (Rs) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x34003a50) {
					// Instruction: 3: 00110100sssseeee0011101--101dddd | Re = sxth (Rs) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x34003a60) {
					// Instruction: 3: 00110100sssseeee0011101--110dddd | Re = sxth (Rs) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x34003a40) {
					// Instruction: 3: 00110100sssseeee0011101--100dddd | Re = sxth (Rs) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003700) {
					// Instruction: 3: 00110100uuuueeee00110111ssssdddd | Re = sxth (Ru) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003500) {
					// Instruction: 3: 00110100uuuueeee00110101ssssdddd | Re = sxth (Ru) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003400) {
					// Instruction: 3: 00110100uuuueeee00110100ssssdddd | Re = sxth (Ru) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x34003600) {
					// Instruction: 3: 00110100uuuueeee00110110ssssdddd | Re = sxth (Ru) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x34003d00) {
					// Instruction: 3: 00110100uuuueeee001111-1ssss0ddd | Re = sxth (Ru) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x34003d08) {
					// Instruction: 3: 00110100uuuueeee001111-1ssss1ddd | Re = sxth (Ru) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x36003a00) {
					// Instruction: 3: 00110110sssseeee0011101--0--dddd | Re = zxth (Rs) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x36003c00) {
					// Instruction: 3: 00110110sssseeee001111-0-ii00ddd | Re = zxth (Rs) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x36003c08) {
					// Instruction: 3: 00110110sssseeee001111-0-ii01ddd | Re = zxth (Rs) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x36003c10) {
					// Instruction: 3: 00110110sssseeee001111-0-ii10ddd | Re = zxth (Rs) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x36003c18) {
					// Instruction: 3: 00110110sssseeee001111-0-ii11ddd | Re = zxth (Rs) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x36003a70) {
					// Instruction: 3: 00110110sssseeee0011101--111dddd | Re = zxth (Rs) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x36003a50) {
					// Instruction: 3: 00110110sssseeee0011101--101dddd | Re = zxth (Rs) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x36003a60) {
					// Instruction: 3: 00110110sssseeee0011101--110dddd | Re = zxth (Rs) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x36003a40) {
					// Instruction: 3: 00110110sssseeee0011101--100dddd | Re = zxth (Rs) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x36003700) {
					// Instruction: 3: 00110110uuuueeee00110111ssssdddd | Re = zxth (Ru) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x36003600) {
					// Instruction: 3: 00110110uuuueeee00110110ssssdddd | Re = zxth (Ru) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x36003d00) {
					// Instruction: 3: 00110110uuuueeee001111-1ssss0ddd | Re = zxth (Ru) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x36003d08) {
					// Instruction: 3: 00110110uuuueeee001111-1ssss1ddd | Re = zxth (Ru) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c003c00) {
					// Instruction: 3: 001111-0-II00eee001111-0-ii00ddd | Ree = combine (#0, #U2) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (#0, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c003d00) {
					// Instruction: 3: 001111-0-II00eee001111-1ssss0ddd | Ree = combine (#0, #U2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c003c08) {
					// Instruction: 3: 001111-0-II00eee001111-0-ii01ddd | Ree = combine (#0, #U2) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (#1, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c003c10) {
					// Instruction: 3: 001111-0-II00eee001111-0-ii10ddd | Ree = combine (#0, #U2) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (#2, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c003c18) {
					// Instruction: 3: 001111-0-II00eee001111-0-ii11ddd | Ree = combine (#0, #U2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c003d08) {
					// Instruction: 3: 001111-0-II00eee001111-1ssss1ddd | Ree = combine (#0, #U2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fd08) == 0x3d003d00) {
					// Instruction: 3: 001111-1uuuu0eee001111-1ssss0ddd | Ree = combine (#0, Ru) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = combine (#0, %s)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fd08) == 0x3d003d08) {
					// Instruction: 3: 001111-1uuuu0eee001111-1ssss1ddd | Ree = combine (#0, Ru) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c083d00) {
					// Instruction: 3: 001111-0-II01eee001111-1ssss0ddd | Ree = combine (#1, #U2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c083c08) {
					// Instruction: 3: 001111-0-II01eee001111-0-ii01ddd | Ree = combine (#1, #U2) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = combine (#1, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c083c10) {
					// Instruction: 3: 001111-0-II01eee001111-0-ii10ddd | Ree = combine (#1, #U2) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = combine (#2, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c083c18) {
					// Instruction: 3: 001111-0-II01eee001111-0-ii11ddd | Ree = combine (#1, #U2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c083d08) {
					// Instruction: 3: 001111-0-II01eee001111-1ssss1ddd | Ree = combine (#1, #U2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c103d00) {
					// Instruction: 3: 001111-0-II10eee001111-1ssss0ddd | Ree = combine (#2, #U2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c103c10) {
					// Instruction: 3: 001111-0-II10eee001111-0-ii10ddd | Ree = combine (#2, #U2) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = combine (#2, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c103c18) {
					// Instruction: 3: 001111-0-II10eee001111-0-ii11ddd | Ree = combine (#2, #U2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c103d08) {
					// Instruction: 3: 001111-0-II10eee001111-1ssss1ddd | Ree = combine (#2, #U2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c183d00) {
					// Instruction: 3: 001111-0-II11eee001111-1ssss0ddd | Ree = combine (#3, #U2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fd18) == 0x3c183c18) {
					// Instruction: 3: 001111-0-II11eee001111-0-ii11ddd | Ree = combine (#3, #U2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fd08) == 0x3c183d08) {
					// Instruction: 3: 001111-0-II11eee001111-1ssss1ddd | Ree = combine (#3, #U2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fd08) == 0x3d083d08) {
					// Instruction: 3: 001111-1uuuu1eee001111-1ssss1ddd | Ree = combine (Ru, #0) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = combine (%s, #0)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x38003a00) {
					// Instruction: 3: 00111000ssssxxxx0011101--0--dddd | Rx = add (Rs, Rx) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c00) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii00ddd | Rx = add (Rs, Rx) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c08) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii01ddd | Rx = add (Rs, Rx) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c10) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii10ddd | Rx = add (Rs, Rx) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c18) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii11ddd | Rx = add (Rs, Rx) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a70) {
					// Instruction: 3: 00111000ssssxxxx0011101--111dddd | Rx = add (Rs, Rx) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a50) {
					// Instruction: 3: 00111000ssssxxxx0011101--101dddd | Rx = add (Rs, Rx) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a60) {
					// Instruction: 3: 00111000ssssxxxx0011101--110dddd | Rx = add (Rs, Rx) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a40) {
					// Instruction: 3: 00111000ssssxxxx0011101--100dddd | Rx = add (Rs, Rx) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x38003d00) {
					// Instruction: 3: 00111000uuuuxxxx001111-1ssss0ddd | Rx = add (Ru, Rx) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x38003d08) {
					// Instruction: 3: 00111000uuuuxxxx001111-1ssss1ddd | Rx = add (Ru, Rx) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003900) {
					// Instruction: 3: 00111000uuuuxxxx00111001ssss--ii | Rx = add (Ru, Rx) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe40) == 0x20003a00) {
					// Instruction: 3: 00100IIIIIIIxxxx0011101--0--dddd | Rx = add (Rx, #S7) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fc00) == 0x20002800) {
					// Instruction: 3: 00100IIIIIIIxxxx001010iiiiiidddd | Rx = add (Rx, #S7) ; Rd = #u6
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD____U6;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f0) >> 4);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = 0x%x", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003300) {
					// Instruction: 3: 00100IIIIIIIxxxx00110011ssssdddd | Rx = add (Rx, #S7) ; Rd = add (Rs, #-1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___ADD__RS____1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = add (%s, #-1)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003100) {
					// Instruction: 3: 00100IIIIIIIxxxx00110001ssssdddd | Rx = add (Rx, #S7) ; Rd = add (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___ADD__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = add (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fc00) == 0x20002c00) {
					// Instruction: 3: 00100IIIIIIIxxxx001011iiiiiidddd | Rx = add (Rx, #S7) ; Rd = add (Sp, #u6:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___ADD__SP___U6_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = add (Sp, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003200) {
					// Instruction: 3: 00100IIIIIIIxxxx00110010ssssdddd | Rx = add (Rx, #S7) ; Rd = and (Rs, #1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___AND__RS___1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = and (%s, #1)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003700) {
					// Instruction: 3: 00100IIIIIIIxxxx00110111ssssdddd | Rx = add (Rx, #S7) ; Rd = and (Rs, #255)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___AND__RS___255_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = and (%s, #255)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fd18) == 0x20003c00) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-0-ii00ddd | Rx = add (Rx, #S7) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fd08) == 0x20003d00) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-1ssss0ddd | Rx = add (Rx, #S7) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fd18) == 0x20003c08) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-0-ii01ddd | Rx = add (Rx, #S7) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fd18) == 0x20003c10) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-0-ii10ddd | Rx = add (Rx, #S7) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fd18) == 0x20003c18) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-0-ii11ddd | Rx = add (Rx, #S7) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fd08) == 0x20003d08) {
					// Instruction: 3: 00100IIIIIIIxxxx001111-1ssss1ddd | Rx = add (Rx, #S7) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe70) == 0x20003a70) {
					// Instruction: 3: 00100IIIIIIIxxxx0011101--111dddd | Rx = add (Rx, #S7) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe70) == 0x20003a50) {
					// Instruction: 3: 00100IIIIIIIxxxx0011101--101dddd | Rx = add (Rx, #S7) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe70) == 0x20003a60) {
					// Instruction: 3: 00100IIIIIIIxxxx0011101--110dddd | Rx = add (Rx, #S7) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe70) == 0x20003a40) {
					// Instruction: 3: 00100IIIIIIIxxxx0011101--100dddd | Rx = add (Rx, #S7) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003900) {
					// Instruction: 3: 00100IIIIIIIxxxx00111001ssss--ii | Rx = add (Rx, #S7) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003000) {
					// Instruction: 3: 00100iiiiiiixxxx00110000ssssdddd | Rx = add (Rx, #s7) ; Rd = Rs
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___RS;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003500) {
					// Instruction: 3: 00100iiiiiiixxxx00110101ssssdddd | Rx = add (Rx, #s7) ; Rd = sxtb (Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___SXTB__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = sxtb (%s)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003400) {
					// Instruction: 3: 00100iiiiiiixxxx00110100ssssdddd | Rx = add (Rx, #s7) ; Rd = sxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___SXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = sxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003600) {
					// Instruction: 3: 00100iiiiiiixxxx00110110ssssdddd | Rx = add (Rx, #s7) ; Rd = zxth (Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___ZXTH__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = zxth (%s)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x38003a00) {
					// Instruction: 3: 00111000ssssxxxx0011101--0--dddd | Rx = add (Rx, Rs) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c00) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii00ddd | Rx = add (Rx, Rs) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c08) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii01ddd | Rx = add (Rx, Rs) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c10) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii10ddd | Rx = add (Rx, Rs) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x38003c18) {
					// Instruction: 3: 00111000ssssxxxx001111-0-ii11ddd | Rx = add (Rx, Rs) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a70) {
					// Instruction: 3: 00111000ssssxxxx0011101--111dddd | Rx = add (Rx, Rs) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a50) {
					// Instruction: 3: 00111000ssssxxxx0011101--101dddd | Rx = add (Rx, Rs) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a60) {
					// Instruction: 3: 00111000ssssxxxx0011101--110dddd | Rx = add (Rx, Rs) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x38003a40) {
					// Instruction: 3: 00111000ssssxxxx0011101--100dddd | Rx = add (Rx, Rs) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x38003d00) {
					// Instruction: 3: 00111000uuuuxxxx001111-1ssss0ddd | Rx = add (Rx, Ru) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x38003d08) {
					// Instruction: 3: 00111000uuuuxxxx001111-1ssss1ddd | Rx = add (Rx, Ru) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003900) {
					// Instruction: 3: 00111000uuuuxxxx00111001ssss--ii | Rx = add (Rx, Ru) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003800) {
					// Instruction: 3: 00111000uuuuyyyy00111000ssssxxxx | Ry = add (Ru, Ry) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RU__RY____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Ry) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003800) {
					// Instruction: 3: 00111000uuuuyyyy00111000ssssxxxx | Ry = add (Ru, Ry) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RU__RY____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Ry) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x20002000) {
					// Instruction: 3: 00100IIIIIIIyyyy00100iiiiiiixxxx | Ry = add (Ry, #S7) ; Rx = add (Rx, #s7)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RY___S7____RX___ADD__RX___S7_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7f0) >> 4);
					if (hi->ops[3].op.imm & (1 << 6)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Ry, %d) ; %s = add (Rx, %d)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003800) {
					// Instruction: 3: 00100iiiiiiiyyyy00111000ssssxxxx | Ry = add (Ry, #s7) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RY___S7____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Ry, %d) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x20003800) {
					// Instruction: 3: 00100iiiiiiiyyyy00111000ssssxxxx | Ry = add (Ry, #s7) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RY___S7____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Ry, %d) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003800) {
					// Instruction: 3: 00111000uuuuyyyy00111000ssssxxxx | Ry = add (Ry, Ru) ; Rx = add (Rs, Rx)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RY__RU____RX___ADD__RS__RX_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Ry, %s) ; %s = add (%s, Rx)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x38003800) {
					// Instruction: 3: 00111000uuuuyyyy00111000ssssxxxx | Ry = add (Ry, Ru) ; Rx = add (Rx, Rs)
					hi->instruction = HEX_INS_DUPLEX_RY___ADD__RY__RU____RX___ADD__RX__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Ry
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rx
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Ry, %s) ; %s = add (Rx, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a703c00) {
					// Instruction: 3: 0011101--111eeee001111-0-ii00ddd | if (! p0) Re = #0 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE___0___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a703d00) {
					// Instruction: 3: 0011101--111eeee001111-1ssss0ddd | if (! p0) Re = #0 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE___0__RS_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a703c08) {
					// Instruction: 3: 0011101--111eeee001111-0-ii01ddd | if (! p0) Re = #0 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE___1___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a703c10) {
					// Instruction: 3: 0011101--111eeee001111-0-ii10ddd | if (! p0) Re = #0 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE___2___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a703c18) {
					// Instruction: 3: 0011101--111eeee001111-0-ii11ddd | if (! p0) Re = #0 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE___3___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a703d08) {
					// Instruction: 3: 0011101--111eeee001111-1ssss1ddd | if (! p0) Re = #0 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___COMBINE__RS___0_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a703a70) {
					// Instruction: 3: 0011101--111eeee0011101--111dddd | if (! p0) Re = #0 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___IF___NOT__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a503c00) {
					// Instruction: 3: 0011101--101eeee001111-0-ii00ddd | if (! p0.new) Re = #0 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE___0___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a503d00) {
					// Instruction: 3: 0011101--101eeee001111-1ssss0ddd | if (! p0.new) Re = #0 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE___0__RS_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a503c08) {
					// Instruction: 3: 0011101--101eeee001111-0-ii01ddd | if (! p0.new) Re = #0 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE___1___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a503c10) {
					// Instruction: 3: 0011101--101eeee001111-0-ii10ddd | if (! p0.new) Re = #0 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE___2___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a503c18) {
					// Instruction: 3: 0011101--101eeee001111-0-ii11ddd | if (! p0.new) Re = #0 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE___3___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a503d08) {
					// Instruction: 3: 0011101--101eeee001111-1ssss1ddd | if (! p0.new) Re = #0 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___COMBINE__RS___0_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a503a70) {
					// Instruction: 3: 0011101--101eeee0011101--111dddd | if (! p0.new) Re = #0 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___IF___NOT__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a503a50) {
					// Instruction: 3: 0011101--101eeee0011101--101dddd | if (! p0.new) Re = #0 ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___IF___NOT__P0_NEW__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a503a60) {
					// Instruction: 3: 0011101--101eeee0011101--110dddd | if (! p0.new) Re = #0 ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___IF__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a603c00) {
					// Instruction: 3: 0011101--110eeee001111-0-ii00ddd | if (p0) Re = #0 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE___0___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a603d00) {
					// Instruction: 3: 0011101--110eeee001111-1ssss0ddd | if (p0) Re = #0 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE___0__RS_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a603c08) {
					// Instruction: 3: 0011101--110eeee001111-0-ii01ddd | if (p0) Re = #0 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE___1___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a603c10) {
					// Instruction: 3: 0011101--110eeee001111-0-ii10ddd | if (p0) Re = #0 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE___2___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a603c18) {
					// Instruction: 3: 0011101--110eeee001111-0-ii11ddd | if (p0) Re = #0 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE___3___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a603d08) {
					// Instruction: 3: 0011101--110eeee001111-1ssss1ddd | if (p0) Re = #0 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___COMBINE__RS___0_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a603a70) {
					// Instruction: 3: 0011101--110eeee0011101--111dddd | if (p0) Re = #0 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___IF___NOT__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a603a60) {
					// Instruction: 3: 0011101--110eeee0011101--110dddd | if (p0) Re = #0 ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___IF__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a403c00) {
					// Instruction: 3: 0011101--100eeee001111-0-ii00ddd | if (p0.new) Re = #0 ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE___0___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a403d00) {
					// Instruction: 3: 0011101--100eeee001111-1ssss0ddd | if (p0.new) Re = #0 ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE___0__RS_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a403c08) {
					// Instruction: 3: 0011101--100eeee001111-0-ii01ddd | if (p0.new) Re = #0 ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE___1___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a403c10) {
					// Instruction: 3: 0011101--100eeee001111-0-ii10ddd | if (p0.new) Re = #0 ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE___2___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd18) == 0x3a403c18) {
					// Instruction: 3: 0011101--100eeee001111-0-ii11ddd | if (p0.new) Re = #0 ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE___3___U2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fd08) == 0x3a403d08) {
					// Instruction: 3: 0011101--100eeee001111-1ssss1ddd | if (p0.new) Re = #0 ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___COMBINE__RS___0_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a403a70) {
					// Instruction: 3: 0011101--100eeee0011101--111dddd | if (p0.new) Re = #0 ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___IF___NOT__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a403a50) {
					// Instruction: 3: 0011101--100eeee0011101--101dddd | if (p0.new) Re = #0 ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___IF___NOT__P0_NEW__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a403a60) {
					// Instruction: 3: 0011101--100eeee0011101--110dddd | if (p0.new) Re = #0 ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___IF__P0__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe70) == 0x3a403a40) {
					// Instruction: 3: 0011101--100eeee0011101--100dddd | if (p0.new) Re = #0 ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___IF__P0_NEW__RD____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe40) == 0x39003a00) {
					// Instruction: 3: 00111001ssss--II0011101--0--dddd | p0 = cmp.eq (Rs, #U2) ; Rd = #-1
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RD_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = #-1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x39003c00) {
					// Instruction: 3: 00111001ssss--II001111-0-ii00ddd | p0 = cmp.eq (Rs, #U2) ; Rdd = combine (#0, #u2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RDD___COMBINE___0___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (#0, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x39003c08) {
					// Instruction: 3: 00111001ssss--II001111-0-ii01ddd | p0 = cmp.eq (Rs, #U2) ; Rdd = combine (#1, #u2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RDD___COMBINE___1___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (#1, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x39003c10) {
					// Instruction: 3: 00111001ssss--II001111-0-ii10ddd | p0 = cmp.eq (Rs, #U2) ; Rdd = combine (#2, #u2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RDD___COMBINE___2___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (#2, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fd18) == 0x39003c18) {
					// Instruction: 3: 00111001ssss--II001111-0-ii11ddd | p0 = cmp.eq (Rs, #U2) ; Rdd = combine (#3, #u2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RDD___COMBINE___3___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (#3, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x39003a70) {
					// Instruction: 3: 00111001ssss--II0011101--111dddd | p0 = cmp.eq (Rs, #U2) ; if (! p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x39003a50) {
					// Instruction: 3: 00111001ssss--II0011101--101dddd | p0 = cmp.eq (Rs, #U2) ; if (! p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x39003a60) {
					// Instruction: 3: 00111001ssss--II0011101--110dddd | p0 = cmp.eq (Rs, #U2) ; if (p0) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe70) == 0x39003a40) {
					// Instruction: 3: 00111001ssss--II0011101--100dddd | p0 = cmp.eq (Rs, #U2) ; if (p0.new) Rd = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0_NEW__RD____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0.new) %s = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x39003d00) {
					// Instruction: 3: 00111001uuuu--II001111-1ssss0ddd | p0 = cmp.eq (Ru, #U2) ; Rdd = combine (#0, Rs)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RDD___COMBINE___0__RS_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (#0, %s)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fd08) == 0x39003d08) {
					// Instruction: 3: 00111001uuuu--II001111-1ssss1ddd | p0 = cmp.eq (Ru, #U2) ; Rdd = combine (Rs, #0)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RDD___COMBINE__RS___0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = combine (%s, #0)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x39003900) {
					// Instruction: 3: 00111001uuuu--II00111001ssss--ii | p0 = cmp.eq (Ru, #U2) ; p0 = cmp.eq (Rs, #u2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____P0___CMP_EQ__RS___U2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; p0 = cmp.eq (%s, 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				break;
			}
			case 0x4: {
				if ((hi_u32 & 0xfe40f000) == 0x5a001000) {
					// Instruction: 4: 0101101--0--eeee0001iiiissssdddd | Re = #-1 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMUB__RS____U4_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40f000) == 0x5a000000) {
					// Instruction: 4: 0101101--0--eeee0000iiiissssdddd | Re = #-1 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMW__RS____U4_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x48001000) {
					// Instruction: 4: 010010IIIIIIeeee0001iiiissssdddd | Re = #U6 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x48000000) {
					// Instruction: 4: 010010IIIIIIeeee0000iiiissssdddd | Re = #U6 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x50001000) {
					// Instruction: 4: 01010000uuuueeee0001iiiissssdddd | Re = Ru ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x50000000) {
					// Instruction: 4: 01010000uuuueeee0000iiiissssdddd | Re = Ru ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x53001000) {
					// Instruction: 4: 01010011uuuueeee0001iiiissssdddd | Re = add (Ru, #-1) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x53000000) {
					// Instruction: 4: 01010011uuuueeee0000iiiissssdddd | Re = add (Ru, #-1) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x51001000) {
					// Instruction: 4: 01010001uuuueeee0001iiiissssdddd | Re = add (Ru, #1) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x51000000) {
					// Instruction: 4: 01010001uuuueeee0000iiiissssdddd | Re = add (Ru, #1) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x4c001000) {
					// Instruction: 4: 010011IIIIIIeeee0001iiiissssdddd | Re = add (Sp, #U6:2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x4c000000) {
					// Instruction: 4: 010011IIIIIIeeee0000iiiissssdddd | Re = add (Sp, #U6:2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x52001000) {
					// Instruction: 4: 01010010uuuueeee0001iiiissssdddd | Re = and (Ru, #1) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x52000000) {
					// Instruction: 4: 01010010uuuueeee0000iiiissssdddd | Re = and (Ru, #1) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x57001000) {
					// Instruction: 4: 01010111uuuueeee0001iiiissssdddd | Re = and (Ru, #255) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x57000000) {
					// Instruction: 4: 01010111uuuueeee0000iiiissssdddd | Re = and (Ru, #255) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x55001000) {
					// Instruction: 4: 01010101uuuueeee0001iiiissssdddd | Re = sxtb (Ru) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x55000000) {
					// Instruction: 4: 01010101uuuueeee0000iiiissssdddd | Re = sxtb (Ru) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x54001000) {
					// Instruction: 4: 01010100uuuueeee0001iiiissssdddd | Re = sxth (Ru) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x54000000) {
					// Instruction: 4: 01010100uuuueeee0000iiiissssdddd | Re = sxth (Ru) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x56001000) {
					// Instruction: 4: 01010110uuuueeee0001iiiissssdddd | Re = zxth (Ru) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x56000000) {
					// Instruction: 4: 01010110uuuueeee0000iiiissssdddd | Re = zxth (Ru) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c001000) {
					// Instruction: 4: 010111-0-II00eee0001iiiissssdddd | Ree = combine (#0, #U2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c000000) {
					// Instruction: 4: 010111-0-II00eee0000iiiissssdddd | Ree = combine (#0, #U2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x5d001000) {
					// Instruction: 4: 010111-1uuuu0eee0001iiiissssdddd | Ree = combine (#0, Ru) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x5d000000) {
					// Instruction: 4: 010111-1uuuu0eee0000iiiissssdddd | Ree = combine (#0, Ru) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c081000) {
					// Instruction: 4: 010111-0-II01eee0001iiiissssdddd | Ree = combine (#1, #U2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c080000) {
					// Instruction: 4: 010111-0-II01eee0000iiiissssdddd | Ree = combine (#1, #U2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c101000) {
					// Instruction: 4: 010111-0-II10eee0001iiiissssdddd | Ree = combine (#2, #U2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c100000) {
					// Instruction: 4: 010111-0-II10eee0000iiiissssdddd | Ree = combine (#2, #U2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c181000) {
					// Instruction: 4: 010111-0-II11eee0001iiiissssdddd | Ree = combine (#3, #U2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x5c180000) {
					// Instruction: 4: 010111-0-II11eee0000iiiissssdddd | Ree = combine (#3, #U2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x5d081000) {
					// Instruction: 4: 010111-1uuuu1eee0001iiiissssdddd | Ree = combine (Ru, #0) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memub (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x5d080000) {
					// Instruction: 4: 010111-1uuuu1eee0000iiiissssdddd | Ree = combine (Ru, #0) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memw (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x58001000) {
					// Instruction: 4: 01011000uuuuxxxx0001iiiissssdddd | Rx = add (Ru, Rx) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x58000000) {
					// Instruction: 4: 01011000uuuuxxxx0000iiiissssdddd | Rx = add (Ru, Rx) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x40001000) {
					// Instruction: 4: 01000IIIIIIIxxxx0001iiiissssdddd | Rx = add (Rx, #S7) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x40000000) {
					// Instruction: 4: 01000IIIIIIIxxxx0000iiiissssdddd | Rx = add (Rx, #S7) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x58001000) {
					// Instruction: 4: 01011000uuuuxxxx0001iiiissssdddd | Rx = add (Rx, Ru) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x58000000) {
					// Instruction: 4: 01011000uuuuxxxx0000iiiissssdddd | Rx = add (Rx, Ru) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a701000) {
					// Instruction: 4: 0101101--111eeee0001iiiissssdddd | if (! p0) Re = #0 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMUB__RS____U4_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a700000) {
					// Instruction: 4: 0101101--111eeee0000iiiissssdddd | if (! p0) Re = #0 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMW__RS____U4_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a501000) {
					// Instruction: 4: 0101101--101eeee0001iiiissssdddd | if (! p0.new) Re = #0 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMUB__RS____U4_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a500000) {
					// Instruction: 4: 0101101--101eeee0000iiiissssdddd | if (! p0.new) Re = #0 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMW__RS____U4_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a601000) {
					// Instruction: 4: 0101101--110eeee0001iiiissssdddd | if (p0) Re = #0 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMUB__RS____U4_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a600000) {
					// Instruction: 4: 0101101--110eeee0000iiiissssdddd | if (p0) Re = #0 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMW__RS____U4_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a401000) {
					// Instruction: 4: 0101101--100eeee0001iiiissssdddd | if (p0.new) Re = #0 ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMUB__RS____U4_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x5a400000) {
					// Instruction: 4: 0101101--100eeee0000iiiissssdddd | if (p0.new) Re = #0 ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMW__RS____U4_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x59001000) {
					// Instruction: 4: 01011001uuuu--II0001iiiissssdddd | p0 = cmp.eq (Ru, #U2) ; Rd = memub (Rs + #u4:0)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RD___MEMUB__RS____U4_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memub (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x59000000) {
					// Instruction: 4: 01011001uuuu--II0000iiiissssdddd | p0 = cmp.eq (Ru, #U2) ; Rd = memw (Rs + #u4:2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RD___MEMW__RS____U4_2_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memw (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				break;
			}
			case 0x5: {
				if ((hi_u32 & 0xfe40ffc4) == 0x5a003f40) {
					// Instruction: 5: 0101101--0--dddd0011111101---0-- | Rd = #-1 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD_____1___DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc4) == 0x5a003f00) {
					// Instruction: 5: 0101101--0--dddd0011111100---0-- | Rd = #-1 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD_____1___DEALLOCFRAME;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003f45) {
					// Instruction: 5: 0101101--0--dddd0011111101---101 | Rd = #-1 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003fc5) {
					// Instruction: 5: 0101101--0--dddd0011111111---101 | Rd = #-1 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003f47) {
					// Instruction: 5: 0101101--0--dddd0011111101---111 | Rd = #-1 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003fc7) {
					// Instruction: 5: 0101101--0--dddd0011111111---111 | Rd = #-1 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003f44) {
					// Instruction: 5: 0101101--0--dddd0011111101---100 | Rd = #-1 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003fc4) {
					// Instruction: 5: 0101101--0--dddd0011111111---100 | Rd = #-1 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003f46) {
					// Instruction: 5: 0101101--0--dddd0011111101---110 | Rd = #-1 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc7) == 0x5a003fc6) {
					// Instruction: 5: 0101101--0--dddd0011111111---110 | Rd = #-1 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD_____1___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ffc4) == 0x5a003fc0) {
					// Instruction: 5: 0101101--0--dddd0011111111---0-- | Rd = #-1 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD_____1___JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x48003f40) {
					// Instruction: 5: 010010iiiiiidddd0011111101---0-- | Rd = #u6 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD____U6___DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x48003f00) {
					// Instruction: 5: 010010iiiiiidddd0011111100---0-- | Rd = #u6 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD____U6___DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003f45) {
					// Instruction: 5: 010010iiiiiidddd0011111101---101 | Rd = #u6 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003fc5) {
					// Instruction: 5: 010010iiiiiidddd0011111111---101 | Rd = #u6 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003f47) {
					// Instruction: 5: 010010iiiiiidddd0011111101---111 | Rd = #u6 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003fc7) {
					// Instruction: 5: 010010iiiiiidddd0011111111---111 | Rd = #u6 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003f44) {
					// Instruction: 5: 010010iiiiiidddd0011111101---100 | Rd = #u6 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003fc4) {
					// Instruction: 5: 010010iiiiiidddd0011111111---100 | Rd = #u6 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003f46) {
					// Instruction: 5: 010010iiiiiidddd0011111101---110 | Rd = #u6 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x48003fc6) {
					// Instruction: 5: 010010iiiiiidddd0011111111---110 | Rd = #u6 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD____U6___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x48003fc0) {
					// Instruction: 5: 010010iiiiiidddd0011111111---0-- | Rd = #u6 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD____U6___JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x50003f40) {
					// Instruction: 5: 01010000ssssdddd0011111101---0-- | Rd = Rs ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___RS___DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x50003f00) {
					// Instruction: 5: 01010000ssssdddd0011111100---0-- | Rd = Rs ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___RS___DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003f45) {
					// Instruction: 5: 01010000ssssdddd0011111101---101 | Rd = Rs ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003fc5) {
					// Instruction: 5: 01010000ssssdddd0011111111---101 | Rd = Rs ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003f47) {
					// Instruction: 5: 01010000ssssdddd0011111101---111 | Rd = Rs ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003fc7) {
					// Instruction: 5: 01010000ssssdddd0011111111---111 | Rd = Rs ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003f44) {
					// Instruction: 5: 01010000ssssdddd0011111101---100 | Rd = Rs ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003fc4) {
					// Instruction: 5: 01010000ssssdddd0011111111---100 | Rd = Rs ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003f46) {
					// Instruction: 5: 01010000ssssdddd0011111101---110 | Rd = Rs ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x50003fc6) {
					// Instruction: 5: 01010000ssssdddd0011111111---110 | Rd = Rs ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___RS___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x50003fc0) {
					// Instruction: 5: 01010000ssssdddd0011111111---0-- | Rd = Rs ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___RS___JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x53003f40) {
					// Instruction: 5: 01010011ssssdddd0011111101---0-- | Rd = add (Rs, #-1) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x53003f00) {
					// Instruction: 5: 01010011ssssdddd0011111100---0-- | Rd = add (Rs, #-1) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003f45) {
					// Instruction: 5: 01010011ssssdddd0011111101---101 | Rd = add (Rs, #-1) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003fc5) {
					// Instruction: 5: 01010011ssssdddd0011111111---101 | Rd = add (Rs, #-1) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003f47) {
					// Instruction: 5: 01010011ssssdddd0011111101---111 | Rd = add (Rs, #-1) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003fc7) {
					// Instruction: 5: 01010011ssssdddd0011111111---111 | Rd = add (Rs, #-1) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003f44) {
					// Instruction: 5: 01010011ssssdddd0011111101---100 | Rd = add (Rs, #-1) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003fc4) {
					// Instruction: 5: 01010011ssssdddd0011111111---100 | Rd = add (Rs, #-1) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003f46) {
					// Instruction: 5: 01010011ssssdddd0011111101---110 | Rd = add (Rs, #-1) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x53003fc6) {
					// Instruction: 5: 01010011ssssdddd0011111111---110 | Rd = add (Rs, #-1) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x53003fc0) {
					// Instruction: 5: 01010011ssssdddd0011111111---0-- | Rd = add (Rs, #-1) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x51003f40) {
					// Instruction: 5: 01010001ssssdddd0011111101---0-- | Rd = add (Rs, #1) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x51003f00) {
					// Instruction: 5: 01010001ssssdddd0011111100---0-- | Rd = add (Rs, #1) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003f45) {
					// Instruction: 5: 01010001ssssdddd0011111101---101 | Rd = add (Rs, #1) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003fc5) {
					// Instruction: 5: 01010001ssssdddd0011111111---101 | Rd = add (Rs, #1) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003f47) {
					// Instruction: 5: 01010001ssssdddd0011111101---111 | Rd = add (Rs, #1) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003fc7) {
					// Instruction: 5: 01010001ssssdddd0011111111---111 | Rd = add (Rs, #1) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003f44) {
					// Instruction: 5: 01010001ssssdddd0011111101---100 | Rd = add (Rs, #1) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003fc4) {
					// Instruction: 5: 01010001ssssdddd0011111111---100 | Rd = add (Rs, #1) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003f46) {
					// Instruction: 5: 01010001ssssdddd0011111101---110 | Rd = add (Rs, #1) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x51003fc6) {
					// Instruction: 5: 01010001ssssdddd0011111111---110 | Rd = add (Rs, #1) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x51003fc0) {
					// Instruction: 5: 01010001ssssdddd0011111111---0-- | Rd = add (Rs, #1) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x4c003f40) {
					// Instruction: 5: 010011iiiiiidddd0011111101---0-- | Rd = add (Sp, #u6:2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x4c003f00) {
					// Instruction: 5: 010011iiiiiidddd0011111100---0-- | Rd = add (Sp, #u6:2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003f45) {
					// Instruction: 5: 010011iiiiiidddd0011111101---101 | Rd = add (Sp, #u6:2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003fc5) {
					// Instruction: 5: 010011iiiiiidddd0011111111---101 | Rd = add (Sp, #u6:2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003f47) {
					// Instruction: 5: 010011iiiiiidddd0011111101---111 | Rd = add (Sp, #u6:2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003fc7) {
					// Instruction: 5: 010011iiiiiidddd0011111111---111 | Rd = add (Sp, #u6:2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003f44) {
					// Instruction: 5: 010011iiiiiidddd0011111101---100 | Rd = add (Sp, #u6:2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003fc4) {
					// Instruction: 5: 010011iiiiiidddd0011111111---100 | Rd = add (Sp, #u6:2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003f46) {
					// Instruction: 5: 010011iiiiiidddd0011111101---110 | Rd = add (Sp, #u6:2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc7) == 0x4c003fc6) {
					// Instruction: 5: 010011iiiiiidddd0011111111---110 | Rd = add (Sp, #u6:2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ffc4) == 0x4c003fc0) {
					// Instruction: 5: 010011iiiiiidddd0011111111---0-- | Rd = add (Sp, #u6:2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x52003f40) {
					// Instruction: 5: 01010010ssssdddd0011111101---0-- | Rd = and (Rs, #1) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x52003f00) {
					// Instruction: 5: 01010010ssssdddd0011111100---0-- | Rd = and (Rs, #1) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003f45) {
					// Instruction: 5: 01010010ssssdddd0011111101---101 | Rd = and (Rs, #1) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003fc5) {
					// Instruction: 5: 01010010ssssdddd0011111111---101 | Rd = and (Rs, #1) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003f47) {
					// Instruction: 5: 01010010ssssdddd0011111101---111 | Rd = and (Rs, #1) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003fc7) {
					// Instruction: 5: 01010010ssssdddd0011111111---111 | Rd = and (Rs, #1) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003f44) {
					// Instruction: 5: 01010010ssssdddd0011111101---100 | Rd = and (Rs, #1) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003fc4) {
					// Instruction: 5: 01010010ssssdddd0011111111---100 | Rd = and (Rs, #1) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003f46) {
					// Instruction: 5: 01010010ssssdddd0011111101---110 | Rd = and (Rs, #1) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x52003fc6) {
					// Instruction: 5: 01010010ssssdddd0011111111---110 | Rd = and (Rs, #1) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x52003fc0) {
					// Instruction: 5: 01010010ssssdddd0011111111---0-- | Rd = and (Rs, #1) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x57003f40) {
					// Instruction: 5: 01010111ssssdddd0011111101---0-- | Rd = and (Rs, #255) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x57003f00) {
					// Instruction: 5: 01010111ssssdddd0011111100---0-- | Rd = and (Rs, #255) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003f45) {
					// Instruction: 5: 01010111ssssdddd0011111101---101 | Rd = and (Rs, #255) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003fc5) {
					// Instruction: 5: 01010111ssssdddd0011111111---101 | Rd = and (Rs, #255) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003f47) {
					// Instruction: 5: 01010111ssssdddd0011111101---111 | Rd = and (Rs, #255) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003fc7) {
					// Instruction: 5: 01010111ssssdddd0011111111---111 | Rd = and (Rs, #255) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003f44) {
					// Instruction: 5: 01010111ssssdddd0011111101---100 | Rd = and (Rs, #255) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003fc4) {
					// Instruction: 5: 01010111ssssdddd0011111111---100 | Rd = and (Rs, #255) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003f46) {
					// Instruction: 5: 01010111ssssdddd0011111101---110 | Rd = and (Rs, #255) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x57003fc6) {
					// Instruction: 5: 01010111ssssdddd0011111111---110 | Rd = and (Rs, #255) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x57003fc0) {
					// Instruction: 5: 01010111ssssdddd0011111111---0-- | Rd = and (Rs, #255) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x55003f40) {
					// Instruction: 5: 01010101ssssdddd0011111101---0-- | Rd = sxtb (Rs) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x55003f00) {
					// Instruction: 5: 01010101ssssdddd0011111100---0-- | Rd = sxtb (Rs) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003f45) {
					// Instruction: 5: 01010101ssssdddd0011111101---101 | Rd = sxtb (Rs) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003fc5) {
					// Instruction: 5: 01010101ssssdddd0011111111---101 | Rd = sxtb (Rs) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003f47) {
					// Instruction: 5: 01010101ssssdddd0011111101---111 | Rd = sxtb (Rs) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003fc7) {
					// Instruction: 5: 01010101ssssdddd0011111111---111 | Rd = sxtb (Rs) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003f44) {
					// Instruction: 5: 01010101ssssdddd0011111101---100 | Rd = sxtb (Rs) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003fc4) {
					// Instruction: 5: 01010101ssssdddd0011111111---100 | Rd = sxtb (Rs) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003f46) {
					// Instruction: 5: 01010101ssssdddd0011111101---110 | Rd = sxtb (Rs) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x55003fc6) {
					// Instruction: 5: 01010101ssssdddd0011111111---110 | Rd = sxtb (Rs) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x55003fc0) {
					// Instruction: 5: 01010101ssssdddd0011111111---0-- | Rd = sxtb (Rs) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x54003f40) {
					// Instruction: 5: 01010100ssssdddd0011111101---0-- | Rd = sxth (Rs) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x54003f00) {
					// Instruction: 5: 01010100ssssdddd0011111100---0-- | Rd = sxth (Rs) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003f45) {
					// Instruction: 5: 01010100ssssdddd0011111101---101 | Rd = sxth (Rs) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003fc5) {
					// Instruction: 5: 01010100ssssdddd0011111111---101 | Rd = sxth (Rs) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003f47) {
					// Instruction: 5: 01010100ssssdddd0011111101---111 | Rd = sxth (Rs) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003fc7) {
					// Instruction: 5: 01010100ssssdddd0011111111---111 | Rd = sxth (Rs) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003f44) {
					// Instruction: 5: 01010100ssssdddd0011111101---100 | Rd = sxth (Rs) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003fc4) {
					// Instruction: 5: 01010100ssssdddd0011111111---100 | Rd = sxth (Rs) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003f46) {
					// Instruction: 5: 01010100ssssdddd0011111101---110 | Rd = sxth (Rs) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x54003fc6) {
					// Instruction: 5: 01010100ssssdddd0011111111---110 | Rd = sxth (Rs) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x54003fc0) {
					// Instruction: 5: 01010100ssssdddd0011111111---0-- | Rd = sxth (Rs) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x56003f40) {
					// Instruction: 5: 01010110ssssdddd0011111101---0-- | Rd = zxth (Rs) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x56003f00) {
					// Instruction: 5: 01010110ssssdddd0011111100---0-- | Rd = zxth (Rs) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003f45) {
					// Instruction: 5: 01010110ssssdddd0011111101---101 | Rd = zxth (Rs) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003fc5) {
					// Instruction: 5: 01010110ssssdddd0011111111---101 | Rd = zxth (Rs) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003f47) {
					// Instruction: 5: 01010110ssssdddd0011111101---111 | Rd = zxth (Rs) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003fc7) {
					// Instruction: 5: 01010110ssssdddd0011111111---111 | Rd = zxth (Rs) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003f44) {
					// Instruction: 5: 01010110ssssdddd0011111101---100 | Rd = zxth (Rs) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003fc4) {
					// Instruction: 5: 01010110ssssdddd0011111111---100 | Rd = zxth (Rs) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003f46) {
					// Instruction: 5: 01010110ssssdddd0011111101---110 | Rd = zxth (Rs) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x56003fc6) {
					// Instruction: 5: 01010110ssssdddd0011111111---110 | Rd = zxth (Rs) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x56003fc0) {
					// Instruction: 5: 01010110ssssdddd0011111111---0-- | Rd = zxth (Rs) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c003f40) {
					// Instruction: 5: 010111-0-ii00ddd0011111101---0-- | Rdd = combine (#0, #u2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c003f00) {
					// Instruction: 5: 010111-0-ii00ddd0011111100---0-- | Rdd = combine (#0, #u2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003f45) {
					// Instruction: 5: 010111-0-ii00ddd0011111101---101 | Rdd = combine (#0, #u2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003fc5) {
					// Instruction: 5: 010111-0-ii00ddd0011111111---101 | Rdd = combine (#0, #u2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003f47) {
					// Instruction: 5: 010111-0-ii00ddd0011111101---111 | Rdd = combine (#0, #u2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003fc7) {
					// Instruction: 5: 010111-0-ii00ddd0011111111---111 | Rdd = combine (#0, #u2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003f44) {
					// Instruction: 5: 010111-0-ii00ddd0011111101---100 | Rdd = combine (#0, #u2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003fc4) {
					// Instruction: 5: 010111-0-ii00ddd0011111111---100 | Rdd = combine (#0, #u2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003f46) {
					// Instruction: 5: 010111-0-ii00ddd0011111101---110 | Rdd = combine (#0, #u2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c003fc6) {
					// Instruction: 5: 010111-0-ii00ddd0011111111---110 | Rdd = combine (#0, #u2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c003fc0) {
					// Instruction: 5: 010111-0-ii00ddd0011111111---0-- | Rdd = combine (#0, #u2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d003f40) {
					// Instruction: 5: 010111-1ssss0ddd0011111101---0-- | Rdd = combine (#0, Rs) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d003f00) {
					// Instruction: 5: 010111-1ssss0ddd0011111100---0-- | Rdd = combine (#0, Rs) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003f45) {
					// Instruction: 5: 010111-1ssss0ddd0011111101---101 | Rdd = combine (#0, Rs) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003fc5) {
					// Instruction: 5: 010111-1ssss0ddd0011111111---101 | Rdd = combine (#0, Rs) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003f47) {
					// Instruction: 5: 010111-1ssss0ddd0011111101---111 | Rdd = combine (#0, Rs) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003fc7) {
					// Instruction: 5: 010111-1ssss0ddd0011111111---111 | Rdd = combine (#0, Rs) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003f44) {
					// Instruction: 5: 010111-1ssss0ddd0011111101---100 | Rdd = combine (#0, Rs) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003fc4) {
					// Instruction: 5: 010111-1ssss0ddd0011111111---100 | Rdd = combine (#0, Rs) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003f46) {
					// Instruction: 5: 010111-1ssss0ddd0011111101---110 | Rdd = combine (#0, Rs) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d003fc6) {
					// Instruction: 5: 010111-1ssss0ddd0011111111---110 | Rdd = combine (#0, Rs) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d003fc0) {
					// Instruction: 5: 010111-1ssss0ddd0011111111---0-- | Rdd = combine (#0, Rs) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c083f40) {
					// Instruction: 5: 010111-0-ii01ddd0011111101---0-- | Rdd = combine (#1, #u2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c083f00) {
					// Instruction: 5: 010111-0-ii01ddd0011111100---0-- | Rdd = combine (#1, #u2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083f45) {
					// Instruction: 5: 010111-0-ii01ddd0011111101---101 | Rdd = combine (#1, #u2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083fc5) {
					// Instruction: 5: 010111-0-ii01ddd0011111111---101 | Rdd = combine (#1, #u2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083f47) {
					// Instruction: 5: 010111-0-ii01ddd0011111101---111 | Rdd = combine (#1, #u2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083fc7) {
					// Instruction: 5: 010111-0-ii01ddd0011111111---111 | Rdd = combine (#1, #u2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083f44) {
					// Instruction: 5: 010111-0-ii01ddd0011111101---100 | Rdd = combine (#1, #u2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083fc4) {
					// Instruction: 5: 010111-0-ii01ddd0011111111---100 | Rdd = combine (#1, #u2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083f46) {
					// Instruction: 5: 010111-0-ii01ddd0011111101---110 | Rdd = combine (#1, #u2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c083fc6) {
					// Instruction: 5: 010111-0-ii01ddd0011111111---110 | Rdd = combine (#1, #u2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c083fc0) {
					// Instruction: 5: 010111-0-ii01ddd0011111111---0-- | Rdd = combine (#1, #u2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c103f40) {
					// Instruction: 5: 010111-0-ii10ddd0011111101---0-- | Rdd = combine (#2, #u2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c103f00) {
					// Instruction: 5: 010111-0-ii10ddd0011111100---0-- | Rdd = combine (#2, #u2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103f45) {
					// Instruction: 5: 010111-0-ii10ddd0011111101---101 | Rdd = combine (#2, #u2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103fc5) {
					// Instruction: 5: 010111-0-ii10ddd0011111111---101 | Rdd = combine (#2, #u2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103f47) {
					// Instruction: 5: 010111-0-ii10ddd0011111101---111 | Rdd = combine (#2, #u2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103fc7) {
					// Instruction: 5: 010111-0-ii10ddd0011111111---111 | Rdd = combine (#2, #u2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103f44) {
					// Instruction: 5: 010111-0-ii10ddd0011111101---100 | Rdd = combine (#2, #u2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103fc4) {
					// Instruction: 5: 010111-0-ii10ddd0011111111---100 | Rdd = combine (#2, #u2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103f46) {
					// Instruction: 5: 010111-0-ii10ddd0011111101---110 | Rdd = combine (#2, #u2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c103fc6) {
					// Instruction: 5: 010111-0-ii10ddd0011111111---110 | Rdd = combine (#2, #u2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c103fc0) {
					// Instruction: 5: 010111-0-ii10ddd0011111111---0-- | Rdd = combine (#2, #u2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c183f40) {
					// Instruction: 5: 010111-0-ii11ddd0011111101---0-- | Rdd = combine (#3, #u2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c183f00) {
					// Instruction: 5: 010111-0-ii11ddd0011111100---0-- | Rdd = combine (#3, #u2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183f45) {
					// Instruction: 5: 010111-0-ii11ddd0011111101---101 | Rdd = combine (#3, #u2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183fc5) {
					// Instruction: 5: 010111-0-ii11ddd0011111111---101 | Rdd = combine (#3, #u2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183f47) {
					// Instruction: 5: 010111-0-ii11ddd0011111101---111 | Rdd = combine (#3, #u2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183fc7) {
					// Instruction: 5: 010111-0-ii11ddd0011111111---111 | Rdd = combine (#3, #u2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183f44) {
					// Instruction: 5: 010111-0-ii11ddd0011111101---100 | Rdd = combine (#3, #u2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183fc4) {
					// Instruction: 5: 010111-0-ii11ddd0011111111---100 | Rdd = combine (#3, #u2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183f46) {
					// Instruction: 5: 010111-0-ii11ddd0011111101---110 | Rdd = combine (#3, #u2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc7) == 0x5c183fc6) {
					// Instruction: 5: 010111-0-ii11ddd0011111111---110 | Rdd = combine (#3, #u2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ffc4) == 0x5c183fc0) {
					// Instruction: 5: 010111-0-ii11ddd0011111111---0-- | Rdd = combine (#3, #u2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d083f40) {
					// Instruction: 5: 010111-1ssss1ddd0011111101---0-- | Rdd = combine (Rs, #0) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d083f00) {
					// Instruction: 5: 010111-1ssss1ddd0011111100---0-- | Rdd = combine (Rs, #0) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; deallocframe", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083f45) {
					// Instruction: 5: 010111-1ssss1ddd0011111101---101 | Rdd = combine (Rs, #0) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (! p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083fc5) {
					// Instruction: 5: 010111-1ssss1ddd0011111111---101 | Rdd = combine (Rs, #0) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (! p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083f47) {
					// Instruction: 5: 010111-1ssss1ddd0011111101---111 | Rdd = combine (Rs, #0) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (! p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083fc7) {
					// Instruction: 5: 010111-1ssss1ddd0011111111---111 | Rdd = combine (Rs, #0) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083f44) {
					// Instruction: 5: 010111-1ssss1ddd0011111101---100 | Rdd = combine (Rs, #0) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (p0) dealloc_return", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083fc4) {
					// Instruction: 5: 010111-1ssss1ddd0011111111---100 | Rdd = combine (Rs, #0) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (p0) jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083f46) {
					// Instruction: 5: 010111-1ssss1ddd0011111101---110 | Rdd = combine (Rs, #0) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (p0.new) dealloc_return:nt", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc7) == 0x5d083fc6) {
					// Instruction: 5: 010111-1ssss1ddd0011111111---110 | Rdd = combine (Rs, #0) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; if (p0.new) jumpr:nt Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ffc4) == 0x5d083fc0) {
					// Instruction: 5: 010111-1ssss1ddd0011111111---0-- | Rdd = combine (Rs, #0) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; jumpr Lr", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40f800) == 0x5a003000) {
					// Instruction: 5: 0101101--0--eeee00110iiissssdddd | Re = #-1 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMB__RS____U3_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40f800) == 0x5a002000) {
					// Instruction: 5: 0101101--0--eeee00100iiissssdddd | Re = #-1 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40f800) == 0x5a002800) {
					// Instruction: 5: 0101101--0--eeee00101iiissssdddd | Re = #-1 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMUH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fe00) == 0x5a003c00) {
					// Instruction: 5: 0101101--0--eeee0011110iiiiidddd | Re = #-1 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RD___MEMW__SP____U5_2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40ff00) == 0x5a003e00) {
					// Instruction: 5: 0101101--0--eeee00111110iiiiiddd | Re = #-1 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE_____1___RDD___MEMD__SP____U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x48003000) {
					// Instruction: 5: 010010IIIIIIeeee00110iiissssdddd | Re = #U6 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x48002000) {
					// Instruction: 5: 010010IIIIIIeeee00100iiissssdddd | Re = #U6 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x48002800) {
					// Instruction: 5: 010010IIIIIIeeee00101iiissssdddd | Re = #U6 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x48003c00) {
					// Instruction: 5: 010010IIIIIIeeee0011110iiiiidddd | Re = #U6 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x48003e00) {
					// Instruction: 5: 010010IIIIIIeeee00111110iiiiiddd | Re = #U6 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE____U6___RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x50003c00) {
					// Instruction: 5: 01010000sssseeee0011110iiiiidddd | Re = Rs ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x50003e00) {
					// Instruction: 5: 01010000sssseeee00111110iiiiiddd | Re = Rs ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___RS___RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x50003000) {
					// Instruction: 5: 01010000uuuueeee00110iiissssdddd | Re = Ru ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x50002000) {
					// Instruction: 5: 01010000uuuueeee00100iiissssdddd | Re = Ru ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x50002800) {
					// Instruction: 5: 01010000uuuueeee00101iiissssdddd | Re = Ru ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___RU___RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x53003c00) {
					// Instruction: 5: 01010011sssseeee0011110iiiiidddd | Re = add (Rs, #-1) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x53003e00) {
					// Instruction: 5: 01010011sssseeee00111110iiiiiddd | Re = add (Rs, #-1) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS____1____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x51003c00) {
					// Instruction: 5: 01010001sssseeee0011110iiiiidddd | Re = add (Rs, #1) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x51003e00) {
					// Instruction: 5: 01010001sssseeee00111110iiiiiddd | Re = add (Rs, #1) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RS___1____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x53003000) {
					// Instruction: 5: 01010011uuuueeee00110iiissssdddd | Re = add (Ru, #-1) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x53002000) {
					// Instruction: 5: 01010011uuuueeee00100iiissssdddd | Re = add (Ru, #-1) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x53002800) {
					// Instruction: 5: 01010011uuuueeee00101iiissssdddd | Re = add (Ru, #-1) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU____1____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x51003000) {
					// Instruction: 5: 01010001uuuueeee00110iiissssdddd | Re = add (Ru, #1) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x51002000) {
					// Instruction: 5: 01010001uuuueeee00100iiissssdddd | Re = add (Ru, #1) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x51002800) {
					// Instruction: 5: 01010001uuuueeee00101iiissssdddd | Re = add (Ru, #1) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__RU___1____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x4c003000) {
					// Instruction: 5: 010011IIIIIIeeee00110iiissssdddd | Re = add (Sp, #U6:2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x4c002000) {
					// Instruction: 5: 010011IIIIIIeeee00100iiissssdddd | Re = add (Sp, #U6:2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x4c002800) {
					// Instruction: 5: 010011IIIIIIeeee00101iiissssdddd | Re = add (Sp, #U6:2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x4c003c00) {
					// Instruction: 5: 010011IIIIIIeeee0011110iiiiidddd | Re = add (Sp, #U6:2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x4c003e00) {
					// Instruction: 5: 010011IIIIIIeeee00111110iiiiiddd | Re = add (Sp, #U6:2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___ADD__SP___U6_2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x52003c00) {
					// Instruction: 5: 01010010sssseeee0011110iiiiidddd | Re = and (Rs, #1) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x52003e00) {
					// Instruction: 5: 01010010sssseeee00111110iiiiiddd | Re = and (Rs, #1) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___1____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x57003c00) {
					// Instruction: 5: 01010111sssseeee0011110iiiiidddd | Re = and (Rs, #255) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x57003e00) {
					// Instruction: 5: 01010111sssseeee00111110iiiiiddd | Re = and (Rs, #255) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RS___255____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x52003000) {
					// Instruction: 5: 01010010uuuueeee00110iiissssdddd | Re = and (Ru, #1) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x52002000) {
					// Instruction: 5: 01010010uuuueeee00100iiissssdddd | Re = and (Ru, #1) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x52002800) {
					// Instruction: 5: 01010010uuuueeee00101iiissssdddd | Re = and (Ru, #1) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___1____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x57003000) {
					// Instruction: 5: 01010111uuuueeee00110iiissssdddd | Re = and (Ru, #255) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x57002000) {
					// Instruction: 5: 01010111uuuueeee00100iiissssdddd | Re = and (Ru, #255) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x57002800) {
					// Instruction: 5: 01010111uuuueeee00101iiissssdddd | Re = and (Ru, #255) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___AND__RU___255____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x55003c00) {
					// Instruction: 5: 01010101sssseeee0011110iiiiidddd | Re = sxtb (Rs) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x55003e00) {
					// Instruction: 5: 01010101sssseeee00111110iiiiiddd | Re = sxtb (Rs) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RS____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x55003000) {
					// Instruction: 5: 01010101uuuueeee00110iiissssdddd | Re = sxtb (Ru) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x55002000) {
					// Instruction: 5: 01010101uuuueeee00100iiissssdddd | Re = sxtb (Ru) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x55002800) {
					// Instruction: 5: 01010101uuuueeee00101iiissssdddd | Re = sxtb (Ru) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTB__RU____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x54003c00) {
					// Instruction: 5: 01010100sssseeee0011110iiiiidddd | Re = sxth (Rs) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x54003e00) {
					// Instruction: 5: 01010100sssseeee00111110iiiiiddd | Re = sxth (Rs) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RS____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x54003000) {
					// Instruction: 5: 01010100uuuueeee00110iiissssdddd | Re = sxth (Ru) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x54002000) {
					// Instruction: 5: 01010100uuuueeee00100iiissssdddd | Re = sxth (Ru) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x54002800) {
					// Instruction: 5: 01010100uuuueeee00101iiissssdddd | Re = sxth (Ru) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___SXTH__RU____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x56003c00) {
					// Instruction: 5: 01010110sssseeee0011110iiiiidddd | Re = zxth (Rs) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x56003e00) {
					// Instruction: 5: 01010110sssseeee00111110iiiiiddd | Re = zxth (Rs) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RS____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x56003000) {
					// Instruction: 5: 01010110uuuueeee00110iiissssdddd | Re = zxth (Ru) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x56002000) {
					// Instruction: 5: 01010110uuuueeee00100iiissssdddd | Re = zxth (Ru) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x56002800) {
					// Instruction: 5: 01010110uuuueeee00101iiissssdddd | Re = zxth (Ru) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RE___ZXTH__RU____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c003000) {
					// Instruction: 5: 010111-0-II00eee00110iiissssdddd | Ree = combine (#0, #U2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c002000) {
					// Instruction: 5: 010111-0-II00eee00100iiissssdddd | Ree = combine (#0, #U2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c002800) {
					// Instruction: 5: 010111-0-II00eee00101iiissssdddd | Ree = combine (#0, #U2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x5c003c00) {
					// Instruction: 5: 010111-0-II00eee0011110iiiiidddd | Ree = combine (#0, #U2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x5c003e00) {
					// Instruction: 5: 010111-0-II00eee00111110iiiiiddd | Ree = combine (#0, #U2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0___U2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x5d003c00) {
					// Instruction: 5: 010111-1ssss0eee0011110iiiiidddd | Ree = combine (#0, Rs) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RS____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x5d003e00) {
					// Instruction: 5: 010111-1ssss0eee00111110iiiiiddd | Ree = combine (#0, Rs) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RS____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d003000) {
					// Instruction: 5: 010111-1uuuu0eee00110iiissssdddd | Ree = combine (#0, Ru) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d002000) {
					// Instruction: 5: 010111-1uuuu0eee00100iiissssdddd | Ree = combine (#0, Ru) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d002800) {
					// Instruction: 5: 010111-1uuuu0eee00101iiissssdddd | Ree = combine (#0, Ru) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___0__RU____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c083000) {
					// Instruction: 5: 010111-0-II01eee00110iiissssdddd | Ree = combine (#1, #U2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c082000) {
					// Instruction: 5: 010111-0-II01eee00100iiissssdddd | Ree = combine (#1, #U2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c082800) {
					// Instruction: 5: 010111-0-II01eee00101iiissssdddd | Ree = combine (#1, #U2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x5c083c00) {
					// Instruction: 5: 010111-0-II01eee0011110iiiiidddd | Ree = combine (#1, #U2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x5c083e00) {
					// Instruction: 5: 010111-0-II01eee00111110iiiiiddd | Ree = combine (#1, #U2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___1___U2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c103000) {
					// Instruction: 5: 010111-0-II10eee00110iiissssdddd | Ree = combine (#2, #U2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c102000) {
					// Instruction: 5: 010111-0-II10eee00100iiissssdddd | Ree = combine (#2, #U2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c102800) {
					// Instruction: 5: 010111-0-II10eee00101iiissssdddd | Ree = combine (#2, #U2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x5c103c00) {
					// Instruction: 5: 010111-0-II10eee0011110iiiiidddd | Ree = combine (#2, #U2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x5c103e00) {
					// Instruction: 5: 010111-0-II10eee00111110iiiiiddd | Ree = combine (#2, #U2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___2___U2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c183000) {
					// Instruction: 5: 010111-0-II11eee00110iiissssdddd | Ree = combine (#3, #U2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c182000) {
					// Instruction: 5: 010111-0-II11eee00100iiissssdddd | Ree = combine (#3, #U2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x5c182800) {
					// Instruction: 5: 010111-0-II11eee00101iiissssdddd | Ree = combine (#3, #U2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x5c183c00) {
					// Instruction: 5: 010111-0-II11eee0011110iiiiidddd | Ree = combine (#3, #U2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x5c183e00) {
					// Instruction: 5: 010111-0-II11eee00111110iiiiiddd | Ree = combine (#3, #U2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE___3___U2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x5d083c00) {
					// Instruction: 5: 010111-1ssss1eee0011110iiiiidddd | Ree = combine (Rs, #0) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RS___0____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memw (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x5d083e00) {
					// Instruction: 5: 010111-1ssss1eee00111110iiiiiddd | Ree = combine (Rs, #0) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RS___0____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memd (Sp + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d083000) {
					// Instruction: 5: 010111-1uuuu1eee00110iiissssdddd | Ree = combine (Ru, #0) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memb (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d082000) {
					// Instruction: 5: 010111-1uuuu1eee00100iiissssdddd | Ree = combine (Ru, #0) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x5d082800) {
					// Instruction: 5: 010111-1uuuu1eee00101iiissssdddd | Ree = combine (Ru, #0) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_REE___COMBINE__RU___0____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; %s = memuh (%s + 0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x58003c00) {
					// Instruction: 5: 01011000ssssxxxx0011110iiiiidddd | Rx = add (Rs, Rx) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x58003e00) {
					// Instruction: 5: 01011000ssssxxxx00111110iiiiiddd | Rx = add (Rs, Rx) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003f40) {
					// Instruction: 5: 01011000ssssxxxx0011111101---0-- | Rx = add (Rs, Rx) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003f00) {
					// Instruction: 5: 01011000ssssxxxx0011111100---0-- | Rx = add (Rs, Rx) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f45) {
					// Instruction: 5: 01011000ssssxxxx0011111101---101 | Rx = add (Rs, Rx) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc5) {
					// Instruction: 5: 01011000ssssxxxx0011111111---101 | Rx = add (Rs, Rx) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f47) {
					// Instruction: 5: 01011000ssssxxxx0011111101---111 | Rx = add (Rs, Rx) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc7) {
					// Instruction: 5: 01011000ssssxxxx0011111111---111 | Rx = add (Rs, Rx) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f44) {
					// Instruction: 5: 01011000ssssxxxx0011111101---100 | Rx = add (Rs, Rx) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc4) {
					// Instruction: 5: 01011000ssssxxxx0011111111---100 | Rx = add (Rs, Rx) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f46) {
					// Instruction: 5: 01011000ssssxxxx0011111101---110 | Rx = add (Rs, Rx) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc6) {
					// Instruction: 5: 01011000ssssxxxx0011111111---110 | Rx = add (Rs, Rx) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003fc0) {
					// Instruction: 5: 01011000ssssxxxx0011111111---0-- | Rx = add (Rs, Rx) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58003000) {
					// Instruction: 5: 01011000uuuuxxxx00110iiissssdddd | Rx = add (Ru, Rx) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58002000) {
					// Instruction: 5: 01011000uuuuxxxx00100iiissssdddd | Rx = add (Ru, Rx) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58002800) {
					// Instruction: 5: 01011000uuuuxxxx00101iiissssdddd | Rx = add (Ru, Rx) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x40003000) {
					// Instruction: 5: 01000IIIIIIIxxxx00110iiissssdddd | Rx = add (Rx, #S7) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x40002000) {
					// Instruction: 5: 01000IIIIIIIxxxx00100iiissssdddd | Rx = add (Rx, #S7) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x40002800) {
					// Instruction: 5: 01000IIIIIIIxxxx00101iiissssdddd | Rx = add (Rx, #S7) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x40003c00) {
					// Instruction: 5: 01000IIIIIIIxxxx0011110iiiiidddd | Rx = add (Rx, #S7) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x40003e00) {
					// Instruction: 5: 01000IIIIIIIxxxx00111110iiiiiddd | Rx = add (Rx, #S7) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x40003f40) {
					// Instruction: 5: 01000iiiiiiixxxx0011111101---0-- | Rx = add (Rx, #s7) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x40003f00) {
					// Instruction: 5: 01000iiiiiiixxxx0011111100---0-- | Rx = add (Rx, #s7) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003f45) {
					// Instruction: 5: 01000iiiiiiixxxx0011111101---101 | Rx = add (Rx, #s7) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003fc5) {
					// Instruction: 5: 01000iiiiiiixxxx0011111111---101 | Rx = add (Rx, #s7) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003f47) {
					// Instruction: 5: 01000iiiiiiixxxx0011111101---111 | Rx = add (Rx, #s7) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003fc7) {
					// Instruction: 5: 01000iiiiiiixxxx0011111111---111 | Rx = add (Rx, #s7) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003f44) {
					// Instruction: 5: 01000iiiiiiixxxx0011111101---100 | Rx = add (Rx, #s7) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003fc4) {
					// Instruction: 5: 01000iiiiiiixxxx0011111111---100 | Rx = add (Rx, #s7) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003f46) {
					// Instruction: 5: 01000iiiiiiixxxx0011111101---110 | Rx = add (Rx, #s7) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc7) == 0x40003fc6) {
					// Instruction: 5: 01000iiiiiiixxxx0011111111---110 | Rx = add (Rx, #s7) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ffc4) == 0x40003fc0) {
					// Instruction: 5: 01000iiiiiiixxxx0011111111---0-- | Rx = add (Rx, #s7) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x58003c00) {
					// Instruction: 5: 01011000ssssxxxx0011110iiiiidddd | Rx = add (Rx, Rs) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x58003e00) {
					// Instruction: 5: 01011000ssssxxxx00111110iiiiiddd | Rx = add (Rx, Rs) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003f40) {
					// Instruction: 5: 01011000ssssxxxx0011111101---0-- | Rx = add (Rx, Rs) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003f00) {
					// Instruction: 5: 01011000ssssxxxx0011111100---0-- | Rx = add (Rx, Rs) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f45) {
					// Instruction: 5: 01011000ssssxxxx0011111101---101 | Rx = add (Rx, Rs) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc5) {
					// Instruction: 5: 01011000ssssxxxx0011111111---101 | Rx = add (Rx, Rs) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f47) {
					// Instruction: 5: 01011000ssssxxxx0011111101---111 | Rx = add (Rx, Rs) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc7) {
					// Instruction: 5: 01011000ssssxxxx0011111111---111 | Rx = add (Rx, Rs) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f44) {
					// Instruction: 5: 01011000ssssxxxx0011111101---100 | Rx = add (Rx, Rs) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc4) {
					// Instruction: 5: 01011000ssssxxxx0011111111---100 | Rx = add (Rx, Rs) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003f46) {
					// Instruction: 5: 01011000ssssxxxx0011111101---110 | Rx = add (Rx, Rs) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x58003fc6) {
					// Instruction: 5: 01011000ssssxxxx0011111111---110 | Rx = add (Rx, Rs) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x58003fc0) {
					// Instruction: 5: 01011000ssssxxxx0011111111---0-- | Rx = add (Rx, Rs) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58003000) {
					// Instruction: 5: 01011000uuuuxxxx00110iiissssdddd | Rx = add (Rx, Ru) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58002000) {
					// Instruction: 5: 01011000uuuuxxxx00100iiissssdddd | Rx = add (Rx, Ru) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x58002800) {
					// Instruction: 5: 01011000uuuuxxxx00101iiissssdddd | Rx = add (Rx, Ru) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a703f40) {
					// Instruction: 5: 0101101--111dddd0011111101---0-- | if (! p0) Rd = #0 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a703f00) {
					// Instruction: 5: 0101101--111dddd0011111100---0-- | if (! p0) Rd = #0 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___DEALLOCFRAME;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703f45) {
					// Instruction: 5: 0101101--111dddd0011111101---101 | if (! p0) Rd = #0 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703fc5) {
					// Instruction: 5: 0101101--111dddd0011111111---101 | if (! p0) Rd = #0 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703f47) {
					// Instruction: 5: 0101101--111dddd0011111101---111 | if (! p0) Rd = #0 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703fc7) {
					// Instruction: 5: 0101101--111dddd0011111111---111 | if (! p0) Rd = #0 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703f44) {
					// Instruction: 5: 0101101--111dddd0011111101---100 | if (! p0) Rd = #0 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703fc4) {
					// Instruction: 5: 0101101--111dddd0011111111---100 | if (! p0) Rd = #0 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703f46) {
					// Instruction: 5: 0101101--111dddd0011111101---110 | if (! p0) Rd = #0 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a703fc6) {
					// Instruction: 5: 0101101--111dddd0011111111---110 | if (! p0) Rd = #0 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a703fc0) {
					// Instruction: 5: 0101101--111dddd0011111111---0-- | if (! p0) Rd = #0 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a703000) {
					// Instruction: 5: 0101101--111eeee00110iiissssdddd | if (! p0) Re = #0 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMB__RS____U3_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a702000) {
					// Instruction: 5: 0101101--111eeee00100iiissssdddd | if (! p0) Re = #0 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a702800) {
					// Instruction: 5: 0101101--111eeee00101iiissssdddd | if (! p0) Re = #0 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMUH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x5a703c00) {
					// Instruction: 5: 0101101--111eeee0011110iiiiidddd | if (! p0) Re = #0 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RD___MEMW__SP____U5_2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x5a703e00) {
					// Instruction: 5: 0101101--111eeee00111110iiiiiddd | if (! p0) Re = #0 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RE____0___RDD___MEMD__SP____U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a503f40) {
					// Instruction: 5: 0101101--101dddd0011111101---0-- | if (! p0.new) Rd = #0 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a503f00) {
					// Instruction: 5: 0101101--101dddd0011111100---0-- | if (! p0.new) Rd = #0 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___DEALLOCFRAME;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503f45) {
					// Instruction: 5: 0101101--101dddd0011111101---101 | if (! p0.new) Rd = #0 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503fc5) {
					// Instruction: 5: 0101101--101dddd0011111111---101 | if (! p0.new) Rd = #0 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503f47) {
					// Instruction: 5: 0101101--101dddd0011111101---111 | if (! p0.new) Rd = #0 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503fc7) {
					// Instruction: 5: 0101101--101dddd0011111111---111 | if (! p0.new) Rd = #0 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503f44) {
					// Instruction: 5: 0101101--101dddd0011111101---100 | if (! p0.new) Rd = #0 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503fc4) {
					// Instruction: 5: 0101101--101dddd0011111111---100 | if (! p0.new) Rd = #0 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503f46) {
					// Instruction: 5: 0101101--101dddd0011111101---110 | if (! p0.new) Rd = #0 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a503fc6) {
					// Instruction: 5: 0101101--101dddd0011111111---110 | if (! p0.new) Rd = #0 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a503fc0) {
					// Instruction: 5: 0101101--101dddd0011111111---0-- | if (! p0.new) Rd = #0 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a503000) {
					// Instruction: 5: 0101101--101eeee00110iiissssdddd | if (! p0.new) Re = #0 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMB__RS____U3_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a502000) {
					// Instruction: 5: 0101101--101eeee00100iiissssdddd | if (! p0.new) Re = #0 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a502800) {
					// Instruction: 5: 0101101--101eeee00101iiissssdddd | if (! p0.new) Re = #0 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMUH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x5a503c00) {
					// Instruction: 5: 0101101--101eeee0011110iiiiidddd | if (! p0.new) Re = #0 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RD___MEMW__SP____U5_2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x5a503e00) {
					// Instruction: 5: 0101101--101eeee00111110iiiiiddd | if (! p0.new) Re = #0 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RE____0___RDD___MEMD__SP____U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a603f40) {
					// Instruction: 5: 0101101--110dddd0011111101---0-- | if (p0) Rd = #0 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a603f00) {
					// Instruction: 5: 0101101--110dddd0011111100---0-- | if (p0) Rd = #0 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___DEALLOCFRAME;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603f45) {
					// Instruction: 5: 0101101--110dddd0011111101---101 | if (p0) Rd = #0 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603fc5) {
					// Instruction: 5: 0101101--110dddd0011111111---101 | if (p0) Rd = #0 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603f47) {
					// Instruction: 5: 0101101--110dddd0011111101---111 | if (p0) Rd = #0 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603fc7) {
					// Instruction: 5: 0101101--110dddd0011111111---111 | if (p0) Rd = #0 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603f44) {
					// Instruction: 5: 0101101--110dddd0011111101---100 | if (p0) Rd = #0 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603fc4) {
					// Instruction: 5: 0101101--110dddd0011111111---100 | if (p0) Rd = #0 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603f46) {
					// Instruction: 5: 0101101--110dddd0011111101---110 | if (p0) Rd = #0 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a603fc6) {
					// Instruction: 5: 0101101--110dddd0011111111---110 | if (p0) Rd = #0 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a603fc0) {
					// Instruction: 5: 0101101--110dddd0011111111---0-- | if (p0) Rd = #0 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a603000) {
					// Instruction: 5: 0101101--110eeee00110iiissssdddd | if (p0) Re = #0 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMB__RS____U3_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a602000) {
					// Instruction: 5: 0101101--110eeee00100iiissssdddd | if (p0) Re = #0 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a602800) {
					// Instruction: 5: 0101101--110eeee00101iiissssdddd | if (p0) Re = #0 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMUH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x5a603c00) {
					// Instruction: 5: 0101101--110eeee0011110iiiiidddd | if (p0) Re = #0 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RD___MEMW__SP____U5_2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x5a603e00) {
					// Instruction: 5: 0101101--110eeee00111110iiiiiddd | if (p0) Re = #0 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RE____0___RDD___MEMD__SP____U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a403f40) {
					// Instruction: 5: 0101101--100dddd0011111101---0-- | if (p0.new) Rd = #0 ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a403f00) {
					// Instruction: 5: 0101101--100dddd0011111100---0-- | if (p0.new) Rd = #0 ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___DEALLOCFRAME;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403f45) {
					// Instruction: 5: 0101101--100dddd0011111101---101 | if (p0.new) Rd = #0 ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403fc5) {
					// Instruction: 5: 0101101--100dddd0011111111---101 | if (p0.new) Rd = #0 ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF___NOT__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403f47) {
					// Instruction: 5: 0101101--100dddd0011111101---111 | if (p0.new) Rd = #0 ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403fc7) {
					// Instruction: 5: 0101101--100dddd0011111111---111 | if (p0.new) Rd = #0 ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403f44) {
					// Instruction: 5: 0101101--100dddd0011111101---100 | if (p0.new) Rd = #0 ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF__P0__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403fc4) {
					// Instruction: 5: 0101101--100dddd0011111111---100 | if (p0.new) Rd = #0 ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF__P0__JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403f46) {
					// Instruction: 5: 0101101--100dddd0011111101---110 | if (p0.new) Rd = #0 ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc7) == 0x5a403fc6) {
					// Instruction: 5: 0101101--100dddd0011111111---110 | if (p0.new) Rd = #0 ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ffc4) == 0x5a403fc0) {
					// Instruction: 5: 0101101--100dddd0011111111---0-- | if (p0.new) Rd = #0 ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___JUMPR_LR;
					hi->op_count = 1;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a403000) {
					// Instruction: 5: 0101101--100eeee00110iiissssdddd | if (p0.new) Re = #0 ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMB__RS____U3_0_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a402000) {
					// Instruction: 5: 0101101--100eeee00100iiissssdddd | if (p0.new) Re = #0 ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x5a402800) {
					// Instruction: 5: 0101101--100eeee00101iiissssdddd | if (p0.new) Re = #0 ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMUH__RS____U3_1_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x5a403c00) {
					// Instruction: 5: 0101101--100eeee0011110iiiiidddd | if (p0.new) Re = #0 ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RD___MEMW__SP____U5_2_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x5a403e00) {
					// Instruction: 5: 0101101--100eeee00111110iiiiiddd | if (p0.new) Re = #0 ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RE____0___RDD___MEMD__SP____U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x59003c00) {
					// Instruction: 5: 01011001ssss--II0011110iiiiidddd | p0 = cmp.eq (Rs, #U2) ; Rd = memw (Sp + #u5:2)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RD___MEMW__SP____U5_2_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memw (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x59003e00) {
					// Instruction: 5: 01011001ssss--II00111110iiiiiddd | p0 = cmp.eq (Rs, #U2) ; Rdd = memd (Sp + #u5:3)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____RDD___MEMD__SP____U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf8) >> 3) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memd (Sp + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x59003f40) {
					// Instruction: 5: 01011001ssss--ii0011111101---0-- | p0 = cmp.eq (Rs, #u2) ; dealloc_return
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x59003f00) {
					// Instruction: 5: 01011001ssss--ii0011111100---0-- | p0 = cmp.eq (Rs, #u2) ; deallocframe
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____DEALLOCFRAME;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; deallocframe", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003f45) {
					// Instruction: 5: 01011001ssss--ii0011111101---101 | p0 = cmp.eq (Rs, #u2) ; if (! p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003fc5) {
					// Instruction: 5: 01011001ssss--ii0011111111---101 | p0 = cmp.eq (Rs, #u2) ; if (! p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003f47) {
					// Instruction: 5: 01011001ssss--ii0011111101---111 | p0 = cmp.eq (Rs, #u2) ; if (! p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003fc7) {
					// Instruction: 5: 01011001ssss--ii0011111111---111 | p0 = cmp.eq (Rs, #u2) ; if (! p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF___NOT__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (! p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003f44) {
					// Instruction: 5: 01011001ssss--ii0011111101---100 | p0 = cmp.eq (Rs, #u2) ; if (p0) dealloc_return
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0__DEALLOC_RETURN;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0) dealloc_return", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003fc4) {
					// Instruction: 5: 01011001ssss--ii0011111111---100 | p0 = cmp.eq (Rs, #u2) ; if (p0) jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0__JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0) jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003f46) {
					// Instruction: 5: 01011001ssss--ii0011111101---110 | p0 = cmp.eq (Rs, #u2) ; if (p0.new) dealloc_return:nt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0.new) dealloc_return:nt", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc7) == 0x59003fc6) {
					// Instruction: 5: 01011001ssss--ii0011111111---110 | p0 = cmp.eq (Rs, #u2) ; if (p0.new) jumpr:nt Lr
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____IF__P0_NEW__JUMPR_NT_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; if (p0.new) jumpr:nt Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ffc4) == 0x59003fc0) {
					// Instruction: 5: 01011001ssss--ii0011111111---0-- | p0 = cmp.eq (Rs, #u2) ; jumpr Lr
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____JUMPR_LR;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; jumpr Lr", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x59003000) {
					// Instruction: 5: 01011001uuuu--II00110iiissssdddd | p0 = cmp.eq (Ru, #U2) ; Rd = memb (Rs + #u3:0)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RD___MEMB__RS____U3_0_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memb (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x59002000) {
					// Instruction: 5: 01011001uuuu--II00100iiissssdddd | p0 = cmp.eq (Ru, #U2) ; Rd = memh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RD___MEMH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x59002800) {
					// Instruction: 5: 01011001uuuu--II00101iiissssdddd | p0 = cmp.eq (Ru, #U2) ; Rd = memuh (Rs + #u3:1)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____RD___MEMUH__RS____U3_1_;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rd
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; %s = memuh (%s + 0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				break;
			}
			case 0x6: {
				if ((hi_u32 & 0xfe40f000) == 0x7a001000) {
					// Instruction: 6: 0111101--0--dddd0001iiiisssstttt | Rd = #-1 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMB__RS____U4_0____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40f000) == 0x7a000000) {
					// Instruction: 6: 0111101--0--dddd0000iiiisssstttt | Rd = #-1 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMW__RS____U4_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x68001000) {
					// Instruction: 6: 011010IIIIIIdddd0001iiiisssstttt | Rd = #U6 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x68000000) {
					// Instruction: 6: 011010IIIIIIdddd0000iiiisssstttt | Rd = #U6 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x70001000) {
					// Instruction: 6: 01110000uuuudddd0001iiiisssstttt | Rd = Ru ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x70000000) {
					// Instruction: 6: 01110000uuuudddd0000iiiisssstttt | Rd = Ru ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x73001000) {
					// Instruction: 6: 01110011uuuudddd0001iiiisssstttt | Rd = add (Ru, #-1) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x73000000) {
					// Instruction: 6: 01110011uuuudddd0000iiiisssstttt | Rd = add (Ru, #-1) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x71001000) {
					// Instruction: 6: 01110001uuuudddd0001iiiisssstttt | Rd = add (Ru, #1) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x71000000) {
					// Instruction: 6: 01110001uuuudddd0000iiiisssstttt | Rd = add (Ru, #1) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x6c001000) {
					// Instruction: 6: 011011IIIIIIdddd0001iiiisssstttt | Rd = add (Sp, #U6:2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f000) == 0x6c000000) {
					// Instruction: 6: 011011IIIIIIdddd0000iiiisssstttt | Rd = add (Sp, #U6:2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x72001000) {
					// Instruction: 6: 01110010uuuudddd0001iiiisssstttt | Rd = and (Ru, #1) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x72000000) {
					// Instruction: 6: 01110010uuuudddd0000iiiisssstttt | Rd = and (Ru, #1) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x77001000) {
					// Instruction: 6: 01110111uuuudddd0001iiiisssstttt | Rd = and (Ru, #255) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x77000000) {
					// Instruction: 6: 01110111uuuudddd0000iiiisssstttt | Rd = and (Ru, #255) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x75001000) {
					// Instruction: 6: 01110101uuuudddd0001iiiisssstttt | Rd = sxtb (Ru) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x75000000) {
					// Instruction: 6: 01110101uuuudddd0000iiiisssstttt | Rd = sxtb (Ru) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x74001000) {
					// Instruction: 6: 01110100uuuudddd0001iiiisssstttt | Rd = sxth (Ru) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x74000000) {
					// Instruction: 6: 01110100uuuudddd0000iiiisssstttt | Rd = sxth (Ru) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x76001000) {
					// Instruction: 6: 01110110uuuudddd0001iiiisssstttt | Rd = zxth (Ru) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x76000000) {
					// Instruction: 6: 01110110uuuudddd0000iiiisssstttt | Rd = zxth (Ru) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c001000) {
					// Instruction: 6: 011111-0-II00ddd0001iiiisssstttt | Rdd = combine (#0, #U2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c000000) {
					// Instruction: 6: 011111-0-II00ddd0000iiiisssstttt | Rdd = combine (#0, #U2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x7d001000) {
					// Instruction: 6: 011111-1uuuu0ddd0001iiiisssstttt | Rdd = combine (#0, Ru) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x7d000000) {
					// Instruction: 6: 011111-1uuuu0ddd0000iiiisssstttt | Rdd = combine (#0, Ru) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c081000) {
					// Instruction: 6: 011111-0-II01ddd0001iiiisssstttt | Rdd = combine (#1, #U2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c080000) {
					// Instruction: 6: 011111-0-II01ddd0000iiiisssstttt | Rdd = combine (#1, #U2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c101000) {
					// Instruction: 6: 011111-0-II10ddd0001iiiisssstttt | Rdd = combine (#2, #U2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c100000) {
					// Instruction: 6: 011111-0-II10ddd0000iiiisssstttt | Rdd = combine (#2, #U2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c181000) {
					// Instruction: 6: 011111-0-II11ddd0001iiiisssstttt | Rdd = combine (#3, #U2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f000) == 0x7c180000) {
					// Instruction: 6: 011111-0-II11ddd0000iiiisssstttt | Rdd = combine (#3, #U2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x7d081000) {
					// Instruction: 6: 011111-1uuuu1ddd0001iiiisssstttt | Rdd = combine (Ru, #0) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08f000) == 0x7d080000) {
					// Instruction: 6: 011111-1uuuu1ddd0000iiiisssstttt | Rdd = combine (Ru, #0) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x78001000) {
					// Instruction: 6: 01111000uuuuxxxx0001iiiisssstttt | Rx = add (Ru, Rx) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x78000000) {
					// Instruction: 6: 01111000uuuuxxxx0000iiiisssstttt | Rx = add (Ru, Rx) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x60001000) {
					// Instruction: 6: 01100IIIIIIIxxxx0001iiiisssstttt | Rx = add (Rx, #S7) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x60000000) {
					// Instruction: 6: 01100IIIIIIIxxxx0000iiiisssstttt | Rx = add (Rx, #S7) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x78001000) {
					// Instruction: 6: 01111000uuuuxxxx0001iiiisssstttt | Rx = add (Rx, Ru) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x78000000) {
					// Instruction: 6: 01111000uuuuxxxx0000iiiisssstttt | Rx = add (Rx, Ru) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a701000) {
					// Instruction: 6: 0111101--111dddd0001iiiisssstttt | if (! p0) Rd = #0 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMB__RS____U4_0____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a700000) {
					// Instruction: 6: 0111101--111dddd0000iiiisssstttt | if (! p0) Rd = #0 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMW__RS____U4_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a501000) {
					// Instruction: 6: 0111101--101dddd0001iiiisssstttt | if (! p0.new) Rd = #0 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMB__RS____U4_0____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a500000) {
					// Instruction: 6: 0111101--101dddd0000iiiisssstttt | if (! p0.new) Rd = #0 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMW__RS____U4_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a601000) {
					// Instruction: 6: 0111101--110dddd0001iiiisssstttt | if (p0) Rd = #0 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMB__RS____U4_0____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a600000) {
					// Instruction: 6: 0111101--110dddd0000iiiisssstttt | if (p0) Rd = #0 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMW__RS____U4_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a401000) {
					// Instruction: 6: 0111101--100dddd0001iiiisssstttt | if (p0.new) Rd = #0 ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMB__RS____U4_0____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f000) == 0x7a400000) {
					// Instruction: 6: 0111101--100dddd0000iiiisssstttt | if (p0.new) Rd = #0 ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMW__RS____U4_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x79001000) {
					// Instruction: 6: 01111001uuuu--II0001iiiisssstttt | p0 = cmp.eq (Ru, #U2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x79000000) {
					// Instruction: 6: 01111001uuuu--II0000iiiisssstttt | p0 = cmp.eq (Ru, #U2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				break;
			}
			case 0x7: {
				if ((hi_u32 & 0xfe40fe00) == 0x7a003c00) {
					// Instruction: 7: 0111101--0--dddd0011110iiiii---- | Rd = #-1 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD_____1___ALLOCFRAME___U5_3_;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40ff00) == 0x7a003200) {
					// Instruction: 7: 0111101--0--dddd00110010ssssiiii | Rd = #-1 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMB__RS____U4_0_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40ff00) == 0x7a003300) {
					// Instruction: 7: 0111101--0--dddd00110011ssssiiii | Rd = #-1 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMB__RS____U4_0_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fe00) == 0x7a002a00) {
					// Instruction: 7: 0111101--0--dddd0010101iiiiiittt | Rd = #-1 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMD__SP____S6_3____RTT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 8)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40f800) == 0x7a002000) {
					// Instruction: 7: 0111101--0--dddd00100iiisssstttt | Rd = #-1 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMH__RS____U3_1____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe40ff00) == 0x7a003000) {
					// Instruction: 7: 0111101--0--dddd00110000ssssiiii | Rd = #-1 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMW__RS____U4_2_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40ff00) == 0x7a003100) {
					// Instruction: 7: 0111101--0--dddd00110001ssssiiii | Rd = #-1 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMW__RS____U4_2_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe40fe00) == 0x7a002800) {
					// Instruction: 7: 0111101--0--dddd0010100iiiiitttt | Rd = #-1 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD_____1___MEMW__SP____U5_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = #-1 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x68003c00) {
					// Instruction: 7: 011010IIIIIIdddd0011110iiiii---- | Rd = #U6 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD____U6___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x68003200) {
					// Instruction: 7: 011010IIIIIIdddd00110010ssssiiii | Rd = #U6 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x68003300) {
					// Instruction: 7: 011010IIIIIIdddd00110011ssssiiii | Rd = #U6 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x68002a00) {
					// Instruction: 7: 011010IIIIIIdddd0010101iiiiiittt | Rd = #U6 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x68002000) {
					// Instruction: 7: 011010IIIIIIdddd00100iiisssstttt | Rd = #U6 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x68003000) {
					// Instruction: 7: 011010IIIIIIdddd00110000ssssiiii | Rd = #U6 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x68003100) {
					// Instruction: 7: 011010IIIIIIdddd00110001ssssiiii | Rd = #U6 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x68002800) {
					// Instruction: 7: 011010IIIIIIdddd0010100iiiiitttt | Rd = #U6 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD____U6___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = 0x%x ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x70003c00) {
					// Instruction: 7: 01110000ssssdddd0011110iiiii---- | Rd = Rs ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___RS___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x70002a00) {
					// Instruction: 7: 01110000ssssdddd0010101iiiiiittt | Rd = Rs ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___RS___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x70002800) {
					// Instruction: 7: 01110000ssssdddd0010100iiiiitttt | Rd = Rs ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___RS___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x70003200) {
					// Instruction: 7: 01110000uuuudddd00110010ssssiiii | Rd = Ru ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x70003300) {
					// Instruction: 7: 01110000uuuudddd00110011ssssiiii | Rd = Ru ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x70002000) {
					// Instruction: 7: 01110000uuuudddd00100iiisssstttt | Rd = Ru ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x70003000) {
					// Instruction: 7: 01110000uuuudddd00110000ssssiiii | Rd = Ru ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x70003100) {
					// Instruction: 7: 01110000uuuudddd00110001ssssiiii | Rd = Ru ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___RU___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = %s ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x73003c00) {
					// Instruction: 7: 01110011ssssdddd0011110iiiii---- | Rd = add (Rs, #-1) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x73002a00) {
					// Instruction: 7: 01110011ssssdddd0010101iiiiiittt | Rd = add (Rs, #-1) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x73002800) {
					// Instruction: 7: 01110011ssssdddd0010100iiiiitttt | Rd = add (Rs, #-1) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS____1____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x71003c00) {
					// Instruction: 7: 01110001ssssdddd0011110iiiii---- | Rd = add (Rs, #1) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x71002a00) {
					// Instruction: 7: 01110001ssssdddd0010101iiiiiittt | Rd = add (Rs, #1) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x71002800) {
					// Instruction: 7: 01110001ssssdddd0010100iiiiitttt | Rd = add (Rs, #1) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RS___1____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x73003200) {
					// Instruction: 7: 01110011uuuudddd00110010ssssiiii | Rd = add (Ru, #-1) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x73003300) {
					// Instruction: 7: 01110011uuuudddd00110011ssssiiii | Rd = add (Ru, #-1) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x73002000) {
					// Instruction: 7: 01110011uuuudddd00100iiisssstttt | Rd = add (Ru, #-1) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x73003000) {
					// Instruction: 7: 01110011uuuudddd00110000ssssiiii | Rd = add (Ru, #-1) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x73003100) {
					// Instruction: 7: 01110011uuuudddd00110001ssssiiii | Rd = add (Ru, #-1) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU____1____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #-1) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x71003200) {
					// Instruction: 7: 01110001uuuudddd00110010ssssiiii | Rd = add (Ru, #1) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x71003300) {
					// Instruction: 7: 01110001uuuudddd00110011ssssiiii | Rd = add (Ru, #1) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x71002000) {
					// Instruction: 7: 01110001uuuudddd00100iiisssstttt | Rd = add (Ru, #1) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x71003000) {
					// Instruction: 7: 01110001uuuudddd00110000ssssiiii | Rd = add (Ru, #1) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x71003100) {
					// Instruction: 7: 01110001uuuudddd00110001ssssiiii | Rd = add (Ru, #1) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__RU___1____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, #1) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x6c003c00) {
					// Instruction: 7: 011011IIIIIIdddd0011110iiiii---- | Rd = add (Sp, #U6:2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x6c003200) {
					// Instruction: 7: 011011IIIIIIdddd00110010ssssiiii | Rd = add (Sp, #U6:2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x6c003300) {
					// Instruction: 7: 011011IIIIIIdddd00110011ssssiiii | Rd = add (Sp, #U6:2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x6c002a00) {
					// Instruction: 7: 011011IIIIIIdddd0010101iiiiiittt | Rd = add (Sp, #U6:2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00f800) == 0x6c002000) {
					// Instruction: 7: 011011IIIIIIdddd00100iiisssstttt | Rd = add (Sp, #U6:2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x6c003000) {
					// Instruction: 7: 011011IIIIIIdddd00110000ssssiiii | Rd = add (Sp, #U6:2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00ff00) == 0x6c003100) {
					// Instruction: 7: 011011IIIIIIdddd00110001ssssiiii | Rd = add (Sp, #U6:2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00fe00) == 0x6c002800) {
					// Instruction: 7: 011011IIIIIIdddd0010100iiiiitttt | Rd = add (Sp, #U6:2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ADD__SP___U6_2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Sp, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x72003c00) {
					// Instruction: 7: 01110010ssssdddd0011110iiiii---- | Rd = and (Rs, #1) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x72002a00) {
					// Instruction: 7: 01110010ssssdddd0010101iiiiiittt | Rd = and (Rs, #1) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x72002800) {
					// Instruction: 7: 01110010ssssdddd0010100iiiiitttt | Rd = and (Rs, #1) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___1____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x77003c00) {
					// Instruction: 7: 01110111ssssdddd0011110iiiii---- | Rd = and (Rs, #255) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x77002a00) {
					// Instruction: 7: 01110111ssssdddd0010101iiiiiittt | Rd = and (Rs, #255) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x77002800) {
					// Instruction: 7: 01110111ssssdddd0010100iiiiitttt | Rd = and (Rs, #255) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RS___255____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x72003200) {
					// Instruction: 7: 01110010uuuudddd00110010ssssiiii | Rd = and (Ru, #1) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x72003300) {
					// Instruction: 7: 01110010uuuudddd00110011ssssiiii | Rd = and (Ru, #1) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x72002000) {
					// Instruction: 7: 01110010uuuudddd00100iiisssstttt | Rd = and (Ru, #1) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x72003000) {
					// Instruction: 7: 01110010uuuudddd00110000ssssiiii | Rd = and (Ru, #1) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x72003100) {
					// Instruction: 7: 01110010uuuudddd00110001ssssiiii | Rd = and (Ru, #1) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___1____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #1) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x77003200) {
					// Instruction: 7: 01110111uuuudddd00110010ssssiiii | Rd = and (Ru, #255) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x77003300) {
					// Instruction: 7: 01110111uuuudddd00110011ssssiiii | Rd = and (Ru, #255) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x77002000) {
					// Instruction: 7: 01110111uuuudddd00100iiisssstttt | Rd = and (Ru, #255) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x77003000) {
					// Instruction: 7: 01110111uuuudddd00110000ssssiiii | Rd = and (Ru, #255) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x77003100) {
					// Instruction: 7: 01110111uuuudddd00110001ssssiiii | Rd = and (Ru, #255) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___AND__RU___255____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = and (%s, #255) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x75003c00) {
					// Instruction: 7: 01110101ssssdddd0011110iiiii---- | Rd = sxtb (Rs) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x75002a00) {
					// Instruction: 7: 01110101ssssdddd0010101iiiiiittt | Rd = sxtb (Rs) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x75002800) {
					// Instruction: 7: 01110101ssssdddd0010100iiiiitttt | Rd = sxtb (Rs) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RS____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x75003200) {
					// Instruction: 7: 01110101uuuudddd00110010ssssiiii | Rd = sxtb (Ru) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x75003300) {
					// Instruction: 7: 01110101uuuudddd00110011ssssiiii | Rd = sxtb (Ru) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x75002000) {
					// Instruction: 7: 01110101uuuudddd00100iiisssstttt | Rd = sxtb (Ru) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x75003000) {
					// Instruction: 7: 01110101uuuudddd00110000ssssiiii | Rd = sxtb (Ru) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x75003100) {
					// Instruction: 7: 01110101uuuudddd00110001ssssiiii | Rd = sxtb (Ru) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___SXTB__RU____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxtb (%s) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x74003c00) {
					// Instruction: 7: 01110100ssssdddd0011110iiiii---- | Rd = sxth (Rs) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x74002a00) {
					// Instruction: 7: 01110100ssssdddd0010101iiiiiittt | Rd = sxth (Rs) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x74002800) {
					// Instruction: 7: 01110100ssssdddd0010100iiiiitttt | Rd = sxth (Rs) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RS____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x74003200) {
					// Instruction: 7: 01110100uuuudddd00110010ssssiiii | Rd = sxth (Ru) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x74003300) {
					// Instruction: 7: 01110100uuuudddd00110011ssssiiii | Rd = sxth (Ru) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x74002000) {
					// Instruction: 7: 01110100uuuudddd00100iiisssstttt | Rd = sxth (Ru) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x74003000) {
					// Instruction: 7: 01110100uuuudddd00110000ssssiiii | Rd = sxth (Ru) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x74003100) {
					// Instruction: 7: 01110100uuuudddd00110001ssssiiii | Rd = sxth (Ru) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___SXTH__RU____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = sxth (%s) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x76003c00) {
					// Instruction: 7: 01110110ssssdddd0011110iiiii---- | Rd = zxth (Rs) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x76002a00) {
					// Instruction: 7: 01110110ssssdddd0010101iiiiiittt | Rd = zxth (Rs) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x76002800) {
					// Instruction: 7: 01110110ssssdddd0010100iiiiitttt | Rd = zxth (Rs) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RS____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x76003200) {
					// Instruction: 7: 01110110uuuudddd00110010ssssiiii | Rd = zxth (Ru) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x76003300) {
					// Instruction: 7: 01110110uuuudddd00110011ssssiiii | Rd = zxth (Ru) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x76002000) {
					// Instruction: 7: 01110110uuuudddd00100iiisssstttt | Rd = zxth (Ru) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x76003000) {
					// Instruction: 7: 01110110uuuudddd00110000ssssiiii | Rd = zxth (Ru) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x76003100) {
					// Instruction: 7: 01110110uuuudddd00110001ssssiiii | Rd = zxth (Ru) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___ZXTH__RU____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = zxth (%s) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c003c00) {
					// Instruction: 7: 011111-0-II00ddd0011110iiiii---- | Rdd = combine (#0, #U2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c003200) {
					// Instruction: 7: 011111-0-II00ddd00110010ssssiiii | Rdd = combine (#0, #U2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c003300) {
					// Instruction: 7: 011111-0-II00ddd00110011ssssiiii | Rdd = combine (#0, #U2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c002a00) {
					// Instruction: 7: 011111-0-II00ddd0010101iiiiiittt | Rdd = combine (#0, #U2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x7c002000) {
					// Instruction: 7: 011111-0-II00ddd00100iiisssstttt | Rdd = combine (#0, #U2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c003000) {
					// Instruction: 7: 011111-0-II00ddd00110000ssssiiii | Rdd = combine (#0, #U2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c003100) {
					// Instruction: 7: 011111-0-II00ddd00110001ssssiiii | Rdd = combine (#0, #U2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c002800) {
					// Instruction: 7: 011111-0-II00ddd0010100iiiiitttt | Rdd = combine (#0, #U2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0___U2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d003c00) {
					// Instruction: 7: 011111-1ssss0ddd0011110iiiii---- | Rdd = combine (#0, Rs) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d002a00) {
					// Instruction: 7: 011111-1ssss0ddd0010101iiiiiittt | Rdd = combine (#0, Rs) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d002800) {
					// Instruction: 7: 011111-1ssss0ddd0010100iiiiitttt | Rdd = combine (#0, Rs) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RS____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d003200) {
					// Instruction: 7: 011111-1uuuu0ddd00110010ssssiiii | Rdd = combine (#0, Ru) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d003300) {
					// Instruction: 7: 011111-1uuuu0ddd00110011ssssiiii | Rdd = combine (#0, Ru) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x7d002000) {
					// Instruction: 7: 011111-1uuuu0ddd00100iiisssstttt | Rdd = combine (#0, Ru) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d003000) {
					// Instruction: 7: 011111-1uuuu0ddd00110000ssssiiii | Rdd = combine (#0, Ru) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d003100) {
					// Instruction: 7: 011111-1uuuu0ddd00110001ssssiiii | Rdd = combine (#0, Ru) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___0__RU____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#0, %s) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c083c00) {
					// Instruction: 7: 011111-0-II01ddd0011110iiiii---- | Rdd = combine (#1, #U2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c083200) {
					// Instruction: 7: 011111-0-II01ddd00110010ssssiiii | Rdd = combine (#1, #U2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c083300) {
					// Instruction: 7: 011111-0-II01ddd00110011ssssiiii | Rdd = combine (#1, #U2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c082a00) {
					// Instruction: 7: 011111-0-II01ddd0010101iiiiiittt | Rdd = combine (#1, #U2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x7c082000) {
					// Instruction: 7: 011111-0-II01ddd00100iiisssstttt | Rdd = combine (#1, #U2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c083000) {
					// Instruction: 7: 011111-0-II01ddd00110000ssssiiii | Rdd = combine (#1, #U2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c083100) {
					// Instruction: 7: 011111-0-II01ddd00110001ssssiiii | Rdd = combine (#1, #U2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c082800) {
					// Instruction: 7: 011111-0-II01ddd0010100iiiiitttt | Rdd = combine (#1, #U2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___1___U2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#1, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c103c00) {
					// Instruction: 7: 011111-0-II10ddd0011110iiiii---- | Rdd = combine (#2, #U2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c103200) {
					// Instruction: 7: 011111-0-II10ddd00110010ssssiiii | Rdd = combine (#2, #U2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c103300) {
					// Instruction: 7: 011111-0-II10ddd00110011ssssiiii | Rdd = combine (#2, #U2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c102a00) {
					// Instruction: 7: 011111-0-II10ddd0010101iiiiiittt | Rdd = combine (#2, #U2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x7c102000) {
					// Instruction: 7: 011111-0-II10ddd00100iiisssstttt | Rdd = combine (#2, #U2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c103000) {
					// Instruction: 7: 011111-0-II10ddd00110000ssssiiii | Rdd = combine (#2, #U2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c103100) {
					// Instruction: 7: 011111-0-II10ddd00110001ssssiiii | Rdd = combine (#2, #U2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c102800) {
					// Instruction: 7: 011111-0-II10ddd0010100iiiiitttt | Rdd = combine (#2, #U2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___2___U2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#2, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c183c00) {
					// Instruction: 7: 011111-0-II11ddd0011110iiiii---- | Rdd = combine (#3, #U2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c183200) {
					// Instruction: 7: 011111-0-II11ddd00110010ssssiiii | Rdd = combine (#3, #U2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c183300) {
					// Instruction: 7: 011111-0-II11ddd00110011ssssiiii | Rdd = combine (#3, #U2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c182a00) {
					// Instruction: 7: 011111-0-II11ddd0010101iiiiiittt | Rdd = combine (#3, #U2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18f800) == 0x7c182000) {
					// Instruction: 7: 011111-0-II11ddd00100iiisssstttt | Rdd = combine (#3, #U2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c183000) {
					// Instruction: 7: 011111-0-II11ddd00110000ssssiiii | Rdd = combine (#3, #U2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18ff00) == 0x7c183100) {
					// Instruction: 7: 011111-0-II11ddd00110001ssssiiii | Rdd = combine (#3, #U2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd18fe00) == 0x7c182800) {
					// Instruction: 7: 011111-0-II11ddd0010100iiiiitttt | Rdd = combine (#3, #U2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE___3___U2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (#3, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d083c00) {
					// Instruction: 7: 011111-1ssss1ddd0011110iiiii---- | Rdd = combine (Rs, #0) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d082a00) {
					// Instruction: 7: 011111-1ssss1ddd0010101iiiiiittt | Rdd = combine (Rs, #0) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08fe00) == 0x7d082800) {
					// Instruction: 7: 011111-1ssss1ddd0010100iiiiitttt | Rdd = combine (Rs, #0) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RS___0____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d083200) {
					// Instruction: 7: 011111-1uuuu1ddd00110010ssssiiii | Rdd = combine (Ru, #0) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d083300) {
					// Instruction: 7: 011111-1uuuu1ddd00110011ssssiiii | Rdd = combine (Ru, #0) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08f800) == 0x7d082000) {
					// Instruction: 7: 011111-1uuuu1ddd00100iiisssstttt | Rdd = combine (Ru, #0) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d083000) {
					// Instruction: 7: 011111-1uuuu1ddd00110000ssssiiii | Rdd = combine (Ru, #0) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfd08ff00) == 0x7d083100) {
					// Instruction: 7: 011111-1uuuu1ddd00110001ssssiiii | Rdd = combine (Ru, #0) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___COMBINE__RU___0____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = combine (%s, #0) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78003c00) {
					// Instruction: 7: 01111000ssssxxxx0011110iiiii---- | Rx = add (Rs, Rx) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78002a00) {
					// Instruction: 7: 01111000ssssxxxx0010101iiiiiittt | Rx = add (Rs, Rx) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78002800) {
					// Instruction: 7: 01111000ssssxxxx0010100iiiiitttt | Rx = add (Rs, Rx) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RS__RX____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003200) {
					// Instruction: 7: 01111000uuuuxxxx00110010ssssiiii | Rx = add (Ru, Rx) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003300) {
					// Instruction: 7: 01111000uuuuxxxx00110011ssssiiii | Rx = add (Ru, Rx) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x78002000) {
					// Instruction: 7: 01111000uuuuxxxx00100iiisssstttt | Rx = add (Ru, Rx) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003000) {
					// Instruction: 7: 01111000uuuuxxxx00110000ssssiiii | Rx = add (Ru, Rx) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003100) {
					// Instruction: 7: 01111000uuuuxxxx00110001ssssiiii | Rx = add (Ru, Rx) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RU__RX____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (%s, Rx) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x60003c00) {
					// Instruction: 7: 01100IIIIIIIxxxx0011110iiiii---- | Rx = add (Rx, #S7) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x60003200) {
					// Instruction: 7: 01100IIIIIIIxxxx00110010ssssiiii | Rx = add (Rx, #S7) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x60003300) {
					// Instruction: 7: 01100IIIIIIIxxxx00110011ssssiiii | Rx = add (Rx, #S7) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x60002a00) {
					// Instruction: 7: 01100IIIIIIIxxxx0010101iiiiiittt | Rx = add (Rx, #S7) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0x60002000) {
					// Instruction: 7: 01100IIIIIIIxxxx00100iiisssstttt | Rx = add (Rx, #S7) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x60003000) {
					// Instruction: 7: 01100IIIIIIIxxxx00110000ssssiiii | Rx = add (Rx, #S7) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0x60003100) {
					// Instruction: 7: 01100IIIIIIIxxxx00110001ssssiiii | Rx = add (Rx, #S7) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0x60002800) {
					// Instruction: 7: 01100IIIIIIIxxxx0010100iiiiitttt | Rx = add (Rx, #S7) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX___S7____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7f00000) >> 20);
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "%s = add (Rx, %d) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78003c00) {
					// Instruction: 7: 01111000ssssxxxx0011110iiiii---- | Rx = add (Rx, Rs) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78002a00) {
					// Instruction: 7: 01111000ssssxxxx0010101iiiiiittt | Rx = add (Rx, Rs) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x78002800) {
					// Instruction: 7: 01111000ssssxxxx0010100iiiiitttt | Rx = add (Rx, Rs) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RS____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003200) {
					// Instruction: 7: 01111000uuuuxxxx00110010ssssiiii | Rx = add (Rx, Ru) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003300) {
					// Instruction: 7: 01111000uuuuxxxx00110011ssssiiii | Rx = add (Rx, Ru) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x78002000) {
					// Instruction: 7: 01111000uuuuxxxx00100iiisssstttt | Rx = add (Rx, Ru) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003000) {
					// Instruction: 7: 01111000uuuuxxxx00110000ssssiiii | Rx = add (Rx, Ru) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x78003100) {
					// Instruction: 7: 01111000uuuuxxxx00110001ssssiiii | Rx = add (Rx, Ru) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RX___ADD__RX__RU____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = add (Rx, %s) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a703c00) {
					// Instruction: 7: 0111101--111dddd0011110iiiii---- | if (! p0) Rd = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___ALLOCFRAME___U5_3_;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a703200) {
					// Instruction: 7: 0111101--111dddd00110010ssssiiii | if (! p0) Rd = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMB__RS____U4_0_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a703300) {
					// Instruction: 7: 0111101--111dddd00110011ssssiiii | if (! p0) Rd = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMB__RS____U4_0_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a702a00) {
					// Instruction: 7: 0111101--111dddd0010101iiiiiittt | if (! p0) Rd = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 8)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x7a702000) {
					// Instruction: 7: 0111101--111dddd00100iiisssstttt | if (! p0) Rd = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMH__RS____U3_1____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a703000) {
					// Instruction: 7: 0111101--111dddd00110000ssssiiii | if (! p0) Rd = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMW__RS____U4_2_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a703100) {
					// Instruction: 7: 0111101--111dddd00110001ssssiiii | if (! p0) Rd = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMW__RS____U4_2_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a702800) {
					// Instruction: 7: 0111101--111dddd0010100iiiiitttt | if (! p0) Rd = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0__RD____0___MEMW__SP____U5_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0) %s = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a503c00) {
					// Instruction: 7: 0111101--101dddd0011110iiiii---- | if (! p0.new) Rd = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___ALLOCFRAME___U5_3_;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a503200) {
					// Instruction: 7: 0111101--101dddd00110010ssssiiii | if (! p0.new) Rd = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMB__RS____U4_0_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a503300) {
					// Instruction: 7: 0111101--101dddd00110011ssssiiii | if (! p0.new) Rd = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMB__RS____U4_0_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a502a00) {
					// Instruction: 7: 0111101--101dddd0010101iiiiiittt | if (! p0.new) Rd = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 8)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x7a502000) {
					// Instruction: 7: 0111101--101dddd00100iiisssstttt | if (! p0.new) Rd = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMH__RS____U3_1____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a503000) {
					// Instruction: 7: 0111101--101dddd00110000ssssiiii | if (! p0.new) Rd = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMW__RS____U4_2_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a503100) {
					// Instruction: 7: 0111101--101dddd00110001ssssiiii | if (! p0.new) Rd = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMW__RS____U4_2_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a502800) {
					// Instruction: 7: 0111101--101dddd0010100iiiiitttt | if (! p0.new) Rd = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF___NOT__P0_NEW__RD____0___MEMW__SP____U5_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (! p0.new) %s = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a603c00) {
					// Instruction: 7: 0111101--110dddd0011110iiiii---- | if (p0) Rd = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___ALLOCFRAME___U5_3_;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a603200) {
					// Instruction: 7: 0111101--110dddd00110010ssssiiii | if (p0) Rd = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMB__RS____U4_0_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a603300) {
					// Instruction: 7: 0111101--110dddd00110011ssssiiii | if (p0) Rd = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMB__RS____U4_0_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a602a00) {
					// Instruction: 7: 0111101--110dddd0010101iiiiiittt | if (p0) Rd = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 8)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x7a602000) {
					// Instruction: 7: 0111101--110dddd00100iiisssstttt | if (p0) Rd = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMH__RS____U3_1____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a603000) {
					// Instruction: 7: 0111101--110dddd00110000ssssiiii | if (p0) Rd = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMW__RS____U4_2_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a603100) {
					// Instruction: 7: 0111101--110dddd00110001ssssiiii | if (p0) Rd = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMW__RS____U4_2_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a602800) {
					// Instruction: 7: 0111101--110dddd0010100iiiiitttt | if (p0) Rd = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0__RD____0___MEMW__SP____U5_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0) %s = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a403c00) {
					// Instruction: 7: 0111101--100dddd0011110iiiii---- | if (p0.new) Rd = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___ALLOCFRAME___U5_3_;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a403200) {
					// Instruction: 7: 0111101--100dddd00110010ssssiiii | if (p0.new) Rd = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMB__RS____U4_0_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a403300) {
					// Instruction: 7: 0111101--100dddd00110011ssssiiii | if (p0.new) Rd = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMB__RS____U4_0_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a402a00) {
					// Instruction: 7: 0111101--100dddd0010101iiiiiittt | if (p0.new) Rd = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 8)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), (st32) hi->ops[1].op.imm, hex_get_sub_regpair(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70f800) == 0x7a402000) {
					// Instruction: 7: 0111101--100dddd00100iiisssstttt | if (p0.new) Rd = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMH__RS____U3_1____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a403000) {
					// Instruction: 7: 0111101--100dddd00110000ssssiiii | if (p0.new) Rd = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMW__RS____U4_2_____0;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70ff00) == 0x7a403100) {
					// Instruction: 7: 0111101--100dddd00110001ssssiiii | if (p0.new) Rd = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMW__RS____U4_2_____1;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe70fe00) == 0x7a402800) {
					// Instruction: 7: 0111101--100dddd0010100iiiiitttt | if (p0.new) Rd = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_IF__P0_NEW__RD____0___MEMW__SP____U5_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (p0.new) %s = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x79003c00) {
					// Instruction: 7: 01111001ssss--II0011110iiiii---- | p0 = cmp.eq (Rs, #U2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x79002a00) {
					// Instruction: 7: 01111001ssss--II0010101iiiiiittt | p0 = cmp.eq (Rs, #U2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0x79002800) {
					// Instruction: 7: 01111001ssss--II0010100iiiiitttt | p0 = cmp.eq (Rs, #U2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RS___U2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x79003200) {
					// Instruction: 7: 01111001uuuu--II00110010ssssiiii | p0 = cmp.eq (Ru, #U2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x79003300) {
					// Instruction: 7: 01111001uuuu--II00110011ssssiiii | p0 = cmp.eq (Ru, #U2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0x79002000) {
					// Instruction: 7: 01111001uuuu--II00100iiisssstttt | p0 = cmp.eq (Ru, #U2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x79003000) {
					// Instruction: 7: 01111001uuuu--II00110000ssssiiii | p0 = cmp.eq (Ru, #U2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0x79003100) {
					// Instruction: 7: 01111001uuuu--II00110001ssssiiii | p0 = cmp.eq (Ru, #U2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_P0___CMP_EQ__RU___U2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (%s, 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				break;
			}
			case 0x8: {
				if ((hi_u32 & 0xf000f000) == 0x90001000) {
					// Instruction: 8: 1001IIIIuuuudddd0001iiiisssstttt | Rd = memub (Ru + #U4:0) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0x90000000) {
					// Instruction: 8: 1001IIIIuuuudddd0000iiiisssstttt | Rd = memub (Ru + #U4:0) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0x80001000) {
					// Instruction: 8: 1000IIIIuuuudddd0001iiiisssstttt | Rd = memw (Ru + #U4:2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0x80000000) {
					// Instruction: 8: 1000IIIIuuuudddd0000iiiisssstttt | Rd = memw (Ru + #U4:2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				break;
			}
			case 0x9: {
				if ((hi_u32 & 0xf800f000) == 0x90003000) {
					// Instruction: 9: 10010IIIuuuudddd0011iiiisssstttt | Rd = memb (Ru + #U3:0) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x90002000) {
					// Instruction: 9: 10010IIIuuuudddd0010iiiisssstttt | Rd = memb (Ru + #U3:0) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x80003000) {
					// Instruction: 9: 10000IIIuuuudddd0011iiiisssstttt | Rd = memh (Ru + #U3:1) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x80002000) {
					// Instruction: 9: 10000IIIuuuudddd0010iiiisssstttt | Rd = memh (Ru + #U3:1) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x88003000) {
					// Instruction: 9: 10001IIIuuuudddd0011iiiisssstttt | Rd = memuh (Ru + #U3:1) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800f000) == 0x88002000) {
					// Instruction: 9: 10001IIIuuuudddd0010iiiisssstttt | Rd = memuh (Ru + #U3:1) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00f000) == 0x9c003000) {
					// Instruction: 9: 1001110IIIIIdddd0011iiiisssstttt | Rd = memw (Sp + #U5:2) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00f000) == 0x9c002000) {
					// Instruction: 9: 1001110IIIIIdddd0010iiiisssstttt | Rd = memw (Sp + #U5:2) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x9e003000) {
					// Instruction: 9: 10011110IIIIIddd0011iiiisssstttt | Rdd = memd (Sp + #U5:3) ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMB__RS____U4_0____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memb (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f000) == 0x9e002000) {
					// Instruction: 9: 10011110IIIIIddd0010iiiisssstttt | Rdd = memd (Sp + #U5:3) ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMW__RS____U4_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memw (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xffc4f000) == 0x9f003000) {
					// Instruction: 9: 1001111100---0--0011iiiisssstttt | deallocframe ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMB__RS____U4_0____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xffc4f000) == 0x9f002000) {
					// Instruction: 9: 1001111100---0--0010iiiisssstttt | deallocframe ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMW__RS____U4_2____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				break;
			}
			case 0xa: {
				if ((hi_u32 & 0xf000f000) == 0xb0001000) {
					// Instruction: 10: 1011IIIIuuuuvvvv0001iiiisssstttt | memb (Ru + #U4:0) = Rv ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RV___MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0xb0000000) {
					// Instruction: 10: 1011IIIIuuuuvvvv0000iiiisssstttt | memb (Ru + #U4:0) = Rv ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RV___MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0xa0001000) {
					// Instruction: 10: 1010IIIIuuuuvvvv0001iiiisssstttt | memw (Ru + #U4:2) = Rv ; memb (Rs + #u4:0) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RV___MEMB__RS____U4_0____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memb (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000f000) == 0xa0000000) {
					// Instruction: 10: 1010IIIIuuuuvvvv0000iiiisssstttt | memw (Ru + #U4:2) = Rv ; memw (Rs + #u4:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RV___MEMW__RS____U4_2____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf00) >> 8) << 2; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memw (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				break;
			}
			case 0xb: {
				if ((hi_u32 & 0xf000fe00) == 0xb0003c00) {
					// Instruction: 11: 1011IIIIsssstttt0011110iiiii---- | memb (Rs + #U4:0) = Rt ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0____RT___ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xb0002a00) {
					// Instruction: 11: 1011IIIIssssvvvv0010101iiiiiittt | memb (Rs + #U4:0) = Rv ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0____RV___MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xb0002800) {
					// Instruction: 11: 1011IIIIssssvvvv0010100iiiiitttt | memb (Rs + #U4:0) = Rv ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0____RV___MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xb0003200) {
					// Instruction: 11: 1011IIIIuuuutttt00110010ssssiiii | memb (Ru + #U4:0) = Rt ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RT___MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xb0003300) {
					// Instruction: 11: 1011IIIIuuuutttt00110011ssssiiii | memb (Ru + #U4:0) = Rt ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RT___MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xb0003000) {
					// Instruction: 11: 1011IIIIuuuutttt00110000ssssiiii | memb (Ru + #U4:0) = Rt ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RT___MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xb0003100) {
					// Instruction: 11: 1011IIIIuuuutttt00110001ssssiiii | memb (Ru + #U4:0) = Rt ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RT___MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0xb0002000) {
					// Instruction: 11: 1011IIIIuuuuvvvv00100iiisssstttt | memb (Ru + #U4:0) = Rv ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0____RV___MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = %s ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xa0003c00) {
					// Instruction: 11: 1010IIIIsssstttt0011110iiiii---- | memw (Rs + #U4:2) = Rt ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2____RT___ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xa0002a00) {
					// Instruction: 11: 1010IIIIssssvvvv0010101iiiiiittt | memw (Rs + #U4:2) = Rv ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2____RV___MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xa0002800) {
					// Instruction: 11: 1010IIIIssssvvvv0010100iiiiitttt | memw (Rs + #U4:2) = Rv ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2____RV___MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xa0003200) {
					// Instruction: 11: 1010IIIIuuuutttt00110010ssssiiii | memw (Ru + #U4:2) = Rt ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RT___MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xa0003300) {
					// Instruction: 11: 1010IIIIuuuutttt00110011ssssiiii | memw (Ru + #U4:2) = Rt ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RT___MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xa0003000) {
					// Instruction: 11: 1010IIIIuuuutttt00110000ssssiiii | memw (Ru + #U4:2) = Rt ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RT___MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xa0003100) {
					// Instruction: 11: 1010IIIIuuuutttt00110001ssssiiii | memw (Ru + #U4:2) = Rt ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RT___MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0xa0002000) {
					// Instruction: 11: 1010IIIIuuuuvvvv00100iiisssstttt | memw (Ru + #U4:2) = Rv ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2____RV___MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = %s ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				break;
			}
			case 0xc: {
				if ((hi_u32 & 0xf000fe00) == 0xd0001c00) {
					// Instruction: 12: 1101IIIIssssdddd0001110iiiii---- | Rd = memub (Rs + #U4:0) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xd0000a00) {
					// Instruction: 12: 1101IIIIssssdddd0000101iiiiiittt | Rd = memub (Rs + #U4:0) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xd0000800) {
					// Instruction: 12: 1101IIIIssssdddd0000100iiiiitttt | Rd = memub (Rs + #U4:0) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RS____U4_0____MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xd0001200) {
					// Instruction: 12: 1101IIIIuuuudddd00010010ssssiiii | Rd = memub (Ru + #U4:0) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xd0001300) {
					// Instruction: 12: 1101IIIIuuuudddd00010011ssssiiii | Rd = memub (Ru + #U4:0) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0xd0000000) {
					// Instruction: 12: 1101IIIIuuuudddd00000iiisssstttt | Rd = memub (Ru + #U4:0) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xd0001000) {
					// Instruction: 12: 1101IIIIuuuudddd00010000ssssiiii | Rd = memub (Ru + #U4:0) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xd0001100) {
					// Instruction: 12: 1101IIIIuuuudddd00010001ssssiiii | Rd = memub (Ru + #U4:0) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUB__RU____U4_0____MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memub (%s + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xc0001c00) {
					// Instruction: 12: 1100IIIIssssdddd0001110iiiii---- | Rd = memw (Rs + #U4:2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xc0000a00) {
					// Instruction: 12: 1100IIIIssssdddd0000101iiiiiittt | Rd = memw (Rs + #U4:2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000fe00) == 0xc0000800) {
					// Instruction: 12: 1100IIIIssssdddd0000100iiiiitttt | Rd = memw (Rs + #U4:2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RS____U4_2____MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xc0001200) {
					// Instruction: 12: 1100IIIIuuuudddd00010010ssssiiii | Rd = memw (Ru + #U4:2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xc0001300) {
					// Instruction: 12: 1100IIIIuuuudddd00010011ssssiiii | Rd = memw (Ru + #U4:2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000f800) == 0xc0000000) {
					// Instruction: 12: 1100IIIIuuuudddd00000iiisssstttt | Rd = memw (Ru + #U4:2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xc0001000) {
					// Instruction: 12: 1100IIIIuuuudddd00010000ssssiiii | Rd = memw (Ru + #U4:2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000ff00) == 0xc0001100) {
					// Instruction: 12: 1100IIIIuuuudddd00010001ssssiiii | Rd = memw (Ru + #U4:2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__RU____U4_2____MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf000000) >> 24) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (%s + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				break;
			}
			case 0xd: {
				if ((hi_u32 & 0xf800fe00) == 0xd0003c00) {
					// Instruction: 13: 11010IIIssssdddd0011110iiiii---- | Rd = memb (Rs + #U3:0) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xd0002a00) {
					// Instruction: 13: 11010IIIssssdddd0010101iiiiiittt | Rd = memb (Rs + #U3:0) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xd0002800) {
					// Instruction: 13: 11010IIIssssdddd0010100iiiiitttt | Rd = memb (Rs + #U3:0) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RS____U3_0____MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xd0003200) {
					// Instruction: 13: 11010IIIuuuudddd00110010ssssiiii | Rd = memb (Ru + #U3:0) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xd0003300) {
					// Instruction: 13: 11010IIIuuuudddd00110011ssssiiii | Rd = memb (Ru + #U3:0) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0xd0002000) {
					// Instruction: 13: 11010IIIuuuudddd00100iiisssstttt | Rd = memb (Ru + #U3:0) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xd0003000) {
					// Instruction: 13: 11010IIIuuuudddd00110000ssssiiii | Rd = memb (Ru + #U3:0) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xd0003100) {
					// Instruction: 13: 11010IIIuuuudddd00110001ssssiiii | Rd = memb (Ru + #U3:0) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMB__RU____U3_0____MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memb (%s + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc0003c00) {
					// Instruction: 13: 11000IIIssssdddd0011110iiiii---- | Rd = memh (Rs + #U3:1) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc0002a00) {
					// Instruction: 13: 11000IIIssssdddd0010101iiiiiittt | Rd = memh (Rs + #U3:1) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc0002800) {
					// Instruction: 13: 11000IIIssssdddd0010100iiiiitttt | Rd = memh (Rs + #U3:1) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RS____U3_1____MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc0003200) {
					// Instruction: 13: 11000IIIuuuudddd00110010ssssiiii | Rd = memh (Ru + #U3:1) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc0003300) {
					// Instruction: 13: 11000IIIuuuudddd00110011ssssiiii | Rd = memh (Ru + #U3:1) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0xc0002000) {
					// Instruction: 13: 11000IIIuuuudddd00100iiisssstttt | Rd = memh (Ru + #U3:1) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc0003000) {
					// Instruction: 13: 11000IIIuuuudddd00110000ssssiiii | Rd = memh (Ru + #U3:1) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc0003100) {
					// Instruction: 13: 11000IIIuuuudddd00110001ssssiiii | Rd = memh (Ru + #U3:1) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMH__RU____U3_1____MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memh (%s + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc8003c00) {
					// Instruction: 13: 11001IIIssssdddd0011110iiiii---- | Rd = memuh (Rs + #U3:1) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc8002a00) {
					// Instruction: 13: 11001IIIssssdddd0010101iiiiiittt | Rd = memuh (Rs + #U3:1) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xc8002800) {
					// Instruction: 13: 11001IIIssssdddd0010100iiiiitttt | Rd = memuh (Rs + #U3:1) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RS____U3_1____MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc8003200) {
					// Instruction: 13: 11001IIIuuuudddd00110010ssssiiii | Rd = memuh (Ru + #U3:1) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc8003300) {
					// Instruction: 13: 11001IIIuuuudddd00110011ssssiiii | Rd = memuh (Ru + #U3:1) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0xc8002000) {
					// Instruction: 13: 11001IIIuuuudddd00100iiisssstttt | Rd = memuh (Ru + #U3:1) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc8003000) {
					// Instruction: 13: 11001IIIuuuudddd00110000ssssiiii | Rd = memuh (Ru + #U3:1) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xc8003100) {
					// Instruction: 13: 11001IIIuuuudddd00110001ssssiiii | Rd = memuh (Ru + #U3:1) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMUH__RU____U3_1____MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memuh (%s + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xdc003c00) {
					// Instruction: 13: 1101110IIIIIdddd0011110iiiii---- | Rd = memw (Sp + #U5:2) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xdc003200) {
					// Instruction: 13: 1101110IIIIIdddd00110010ssssiiii | Rd = memw (Sp + #U5:2) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xdc003300) {
					// Instruction: 13: 1101110IIIIIdddd00110011ssssiiii | Rd = memw (Sp + #U5:2) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xdc002a00) {
					// Instruction: 13: 1101110IIIIIdddd0010101iiiiiittt | Rd = memw (Sp + #U5:2) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00f800) == 0xdc002000) {
					// Instruction: 13: 1101110IIIIIdddd00100iiisssstttt | Rd = memw (Sp + #U5:2) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xdc003000) {
					// Instruction: 13: 1101110IIIIIdddd00110000ssssiiii | Rd = memw (Sp + #U5:2) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xdc003100) {
					// Instruction: 13: 1101110IIIIIdddd00110001ssssiiii | Rd = memw (Sp + #U5:2) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xdc002800) {
					// Instruction: 13: 1101110IIIIIdddd0010100iiiiitttt | Rd = memw (Sp + #U5:2) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RD___MEMW__SP____U5_2____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memw (Sp + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xde003c00) {
					// Instruction: 13: 11011110IIIIIddd0011110iiiii---- | Rdd = memd (Sp + #U5:3) ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; allocframe (0x%x)", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xde003200) {
					// Instruction: 13: 11011110IIIIIddd00110010ssssiiii | Rdd = memd (Sp + #U5:3) ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memb (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xde003300) {
					// Instruction: 13: 11011110IIIIIddd00110011ssssiiii | Rdd = memd (Sp + #U5:3) ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memb (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xde002a00) {
					// Instruction: 13: 11011110IIIIIddd0010101iiiiiittt | Rdd = memd (Sp + #U5:3) ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memd (Sp + %d) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0xde002000) {
					// Instruction: 13: 11011110IIIIIddd00100iiisssstttt | Rdd = memd (Sp + #U5:3) ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memh (%s + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xde003000) {
					// Instruction: 13: 11011110IIIIIddd00110000ssssiiii | Rdd = memd (Sp + #U5:3) ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memw (%s + 0x%x) = #0", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xde003100) {
					// Instruction: 13: 11011110IIIIIddd00110001ssssiiii | Rdd = memd (Sp + #U5:3) ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memw (%s + 0x%x) = #1", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xde002800) {
					// Instruction: 13: 11011110IIIIIddd0010100iiiiitttt | Rdd = memd (Sp + #U5:3) ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_RDD___MEMD__SP____U5_3____MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf80000) >> 19) << 3; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = memd (Sp + 0x%x) ; memw (Sp + 0x%x) = %s", hex_get_sub_regpair(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xffc4ff00) == 0xdf003200) {
					// Instruction: 13: 1101111100---0--00110010ssssiiii | deallocframe ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMB__RS____U4_0_____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xffc4ff00) == 0xdf003300) {
					// Instruction: 13: 1101111100---0--00110011ssssiiii | deallocframe ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMB__RS____U4_0_____1;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xffc4fe00) == 0xdf002a00) {
					// Instruction: 13: 1101111100---0--0010101iiiiiittt | deallocframe ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMD__SP____S6_3____RTT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memd (Sp + %d) = %s", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg));
					break;
				}
				if ((hi_u32 & 0xffc4f800) == 0xdf002000) {
					// Instruction: 13: 1101111100---0--00100iiisssstttt | deallocframe ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMH__RS____U3_1____RT;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg));
					break;
				}
				if ((hi_u32 & 0xffc4ff00) == 0xdf003000) {
					// Instruction: 13: 1101111100---0--00110000ssssiiii | deallocframe ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMW__RS____U4_2_____0;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xffc4ff00) == 0xdf003100) {
					// Instruction: 13: 1101111100---0--00110001ssssiiii | deallocframe ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMW__RS____U4_2_____1;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xffc4fe00) == 0xdf002800) {
					// Instruction: 13: 1101111100---0--0010100iiiiitttt | deallocframe ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_DEALLOCFRAME___MEMW__SP____U5_2____RT;
					hi->op_count = 2;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe ; memw (Sp + 0x%x) = %s", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg));
					break;
				}
				break;
			}
			case 0xe: {
				if ((hi_u32 & 0xff00fe00) == 0xf2001c00) {
					// Instruction: 14: 11110010ssssIIII0001110iiiii---- | memb (Rs + #U4:0) = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____0___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf2000a00) {
					// Instruction: 14: 11110010ssssIIII0000101iiiiiittt | memb (Rs + #U4:0) = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf2000800) {
					// Instruction: 14: 11110010ssssIIII0000100iiiiitttt | memb (Rs + #U4:0) = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____0___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf3001c00) {
					// Instruction: 14: 11110011ssssIIII0001110iiiii---- | memb (Rs + #U4:0) = #1 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____1___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf3000a00) {
					// Instruction: 14: 11110011ssssIIII0000101iiiiiittt | memb (Rs + #U4:0) = #1 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____1___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf3000800) {
					// Instruction: 14: 11110011ssssIIII0000100iiiiitttt | memb (Rs + #U4:0) = #1 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RS____U4_0_____1___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf2001200) {
					// Instruction: 14: 11110010uuuuIIII00010010ssssiiii | memb (Ru + #U4:0) = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____0___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf2001300) {
					// Instruction: 14: 11110010uuuuIIII00010011ssssiiii | memb (Ru + #U4:0) = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____0___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0xf2000000) {
					// Instruction: 14: 11110010uuuuIIII00000iiisssstttt | memb (Ru + #U4:0) = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____0___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf2001000) {
					// Instruction: 14: 11110010uuuuIIII00010000ssssiiii | memb (Ru + #U4:0) = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____0___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf2001100) {
					// Instruction: 14: 11110010uuuuIIII00010001ssssiiii | memb (Ru + #U4:0) = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____0___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf3001200) {
					// Instruction: 14: 11110011uuuuIIII00010010ssssiiii | memb (Ru + #U4:0) = #1 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____1___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf3001300) {
					// Instruction: 14: 11110011uuuuIIII00010011ssssiiii | memb (Ru + #U4:0) = #1 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____1___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0xf3000000) {
					// Instruction: 14: 11110011uuuuIIII00000iiisssstttt | memb (Ru + #U4:0) = #1 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____1___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf3001000) {
					// Instruction: 14: 11110011uuuuIIII00010000ssssiiii | memb (Ru + #U4:0) = #1 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____1___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf3001100) {
					// Instruction: 14: 11110011uuuuIIII00010001ssssiiii | memb (Ru + #U4:0) = #1 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMB__RU____U4_0_____1___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (%s + 0x%x) = #1 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xea001c00) {
					// Instruction: 14: 1110101IIIIIIttt0001110iiiii---- | memd (Sp + #S6:3) = Rtt ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RTT___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; allocframe (0x%x)", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xea001200) {
					// Instruction: 14: 1110101IIIIIIttt00010010ssssiiii | memd (Sp + #S6:3) = Rtt ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RTT___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memb (%s + 0x%x) = #0", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xea001300) {
					// Instruction: 14: 1110101IIIIIIttt00010011ssssiiii | memd (Sp + #S6:3) = Rtt ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RTT___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memb (%s + 0x%x) = #1", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xea001000) {
					// Instruction: 14: 1110101IIIIIIttt00010000ssssiiii | memd (Sp + #S6:3) = Rtt ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RTT___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memw (%s + 0x%x) = #0", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xea001100) {
					// Instruction: 14: 1110101IIIIIIttt00010001ssssiiii | memd (Sp + #S6:3) = Rtt ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RTT___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memw (%s + 0x%x) = #1", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xea000a00) {
					// Instruction: 14: 1110101IIIIIIvvv0000101iiiiiittt | memd (Sp + #S6:3) = Rvv ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RVV___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memd (Sp + %d) = %s", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00f800) == 0xea000000) {
					// Instruction: 14: 1110101IIIIIIvvv00000iiisssstttt | memd (Sp + #S6:3) = Rvv ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RVV___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memh (%s + 0x%x) = %s", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xea000800) {
					// Instruction: 14: 1110101IIIIIIvvv0000100iiiiitttt | memd (Sp + #S6:3) = Rvv ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMD__SP____S6_3____RVV___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f80000) >> 19) << 3; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (Sp + %d) = %s ; memw (Sp + 0x%x) = %s", (st32) hi->ops[0].op.imm, hex_get_sub_regpair(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xe0001c00) {
					// Instruction: 14: 11100IIIsssstttt0001110iiiii---- | memh (Rs + #U3:1) = Rt ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMH__RS____U3_1____RT___ALLOCFRAME___U5_3_;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xe0000a00) {
					// Instruction: 14: 11100IIIssssvvvv0000101iiiiiittt | memh (Rs + #U3:1) = Rv ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMH__RS____U3_1____RV___MEMD__SP____S6_3____RTT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 8)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), (st32) hi->ops[3].op.imm, hex_get_sub_regpair(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800fe00) == 0xe0000800) {
					// Instruction: 14: 11100IIIssssvvvv0000100iiiiitttt | memh (Rs + #U3:1) = Rv ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMH__RS____U3_1____RV___MEMW__SP____U5_2____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xe0001200) {
					// Instruction: 14: 11100IIIuuuutttt00010010ssssiiii | memh (Ru + #U3:1) = Rt ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMH__RU____U3_1____RT___MEMB__RS____U4_0_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xe0001300) {
					// Instruction: 14: 11100IIIuuuutttt00010011ssssiiii | memh (Ru + #U3:1) = Rt ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMH__RU____U3_1____RT___MEMB__RS____U4_0_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xe0001000) {
					// Instruction: 14: 11100IIIuuuutttt00010000ssssiiii | memh (Ru + #U3:1) = Rt ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMH__RU____U3_1____RT___MEMW__RS____U4_2_____0;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800ff00) == 0xe0001100) {
					// Instruction: 14: 11100IIIuuuutttt00010001ssssiiii | memh (Ru + #U3:1) = Rt ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMH__RU____U3_1____RT___MEMW__RS____U4_2_____1;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800f800) == 0xe0000000) {
					// Instruction: 14: 11100IIIuuuuvvvv00000iiisssstttt | memh (Ru + #U3:1) = Rv ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMH__RU____U3_1____RV___MEMH__RS____U3_1____RT;
					hi->op_count = 6;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7000000) >> 24) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[5].type = HEX_OP_TYPE_REG;
					hi->ops[5].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (%s + 0x%x) = %s ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hex_get_sub_reg(hi->ops[3].op.reg), hi->ops[4].op.imm, hex_get_sub_reg(hi->ops[5].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf0001c00) {
					// Instruction: 14: 11110000ssssIIII0001110iiiii---- | memw (Rs + #U4:2) = #0 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____0___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf0000a00) {
					// Instruction: 14: 11110000ssssIIII0000101iiiiiittt | memw (Rs + #U4:2) = #0 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____0___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf0000800) {
					// Instruction: 14: 11110000ssssIIII0000100iiiiitttt | memw (Rs + #U4:2) = #0 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____0___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf1001c00) {
					// Instruction: 14: 11110001ssssIIII0001110iiiii---- | memw (Rs + #U4:2) = #1 ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____1___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; allocframe (0x%x)", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf1000a00) {
					// Instruction: 14: 11110001ssssIIII0000101iiiiiittt | memw (Rs + #U4:2) = #1 ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____1___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memd (Sp + %d) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00fe00) == 0xf1000800) {
					// Instruction: 14: 11110001ssssIIII0000100iiiiitttt | memw (Rs + #U4:2) = #1 ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RS____U4_2_____1___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memw (Sp + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf0001200) {
					// Instruction: 14: 11110000uuuuIIII00010010ssssiiii | memw (Ru + #U4:2) = #0 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____0___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf0001300) {
					// Instruction: 14: 11110000uuuuIIII00010011ssssiiii | memw (Ru + #U4:2) = #0 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____0___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0xf0000000) {
					// Instruction: 14: 11110000uuuuIIII00000iiisssstttt | memw (Ru + #U4:2) = #0 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____0___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf0001000) {
					// Instruction: 14: 11110000uuuuIIII00010000ssssiiii | memw (Ru + #U4:2) = #0 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____0___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf0001100) {
					// Instruction: 14: 11110000uuuuIIII00010001ssssiiii | memw (Ru + #U4:2) = #0 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____0___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #0 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf1001200) {
					// Instruction: 14: 11110001uuuuIIII00010010ssssiiii | memw (Ru + #U4:2) = #1 ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____1___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memb (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf1001300) {
					// Instruction: 14: 11110001uuuuIIII00010011ssssiiii | memw (Ru + #U4:2) = #1 ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____1___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memb (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00f800) == 0xf1000000) {
					// Instruction: 14: 11110001uuuuIIII00000iiisssstttt | memw (Ru + #U4:2) = #1 ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____1___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memh (%s + 0x%x) = %s", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf1001000) {
					// Instruction: 14: 11110001uuuuIIII00010000ssssiiii | memw (Ru + #U4:2) = #1 ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____1___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memw (%s + 0x%x) = #0", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xff00ff00) == 0xf1001100) {
					// Instruction: 14: 11110001uuuuIIII00010001ssssiiii | memw (Ru + #U4:2) = #1 ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__RU____U4_2_____1___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00000) >> 20); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0xf0000) >> 16) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (%s + 0x%x) = #1 ; memw (%s + 0x%x) = #1", hex_get_sub_reg(hi->ops[0].op.reg), hi->ops[1].op.imm, hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xe8001c00) {
					// Instruction: 14: 1110100IIIIItttt0001110iiiii---- | memw (Sp + #U5:2) = Rt ; allocframe (#u5:3)
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RT___ALLOCFRAME___U5_3_;
					hi->op_count = 3;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; allocframe (0x%x)", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xe8001200) {
					// Instruction: 14: 1110100IIIIItttt00010010ssssiiii | memw (Sp + #U5:2) = Rt ; memb (Rs + #u4:0) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RT___MEMB__RS____U4_0_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memb (%s + 0x%x) = #0", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xe8001300) {
					// Instruction: 14: 1110100IIIIItttt00010011ssssiiii | memw (Sp + #U5:2) = Rt ; memb (Rs + #u4:0) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RT___MEMB__RS____U4_0_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memb (%s + 0x%x) = #1", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xe8001000) {
					// Instruction: 14: 1110100IIIIItttt00010000ssssiiii | memw (Sp + #U5:2) = Rt ; memw (Rs + #u4:2) = #0
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RT___MEMW__RS____U4_2_____0;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memw (%s + 0x%x) = #0", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00ff00) == 0xe8001100) {
					// Instruction: 14: 1110100IIIIItttt00010001ssssiiii | memw (Sp + #U5:2) = Rt ; memw (Rs + #u4:2) = #1
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RT___MEMW__RS____U4_2_____1;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xf) >> 0) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memw (%s + 0x%x) = #1", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xe8000a00) {
					// Instruction: 14: 1110100IIIIIvvvv0000101iiiiiittt | memw (Sp + #U5:2) = Rv ; memd (Sp + #s6:3) = Rtt
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RV___MEMD__SP____S6_3____RTT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f8) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 8)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memd (Sp + %d) = %s", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), (st32) hi->ops[2].op.imm, hex_get_sub_regpair(hi->ops[3].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00f800) == 0xe8000000) {
					// Instruction: 14: 1110100IIIIIvvvv00000iiisssstttt | memw (Sp + #U5:2) = Rv ; memh (Rs + #u3:1) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RV___MEMH__RS____U3_1____RT;
					hi->op_count = 5;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0xf0) >> 4); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x700) >> 8) << 1; // scaled
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memh (%s + 0x%x) = %s", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hex_get_sub_reg(hi->ops[2].op.reg), hi->ops[3].op.imm, hex_get_sub_reg(hi->ops[4].op.reg));
					break;
				}
				if ((hi_u32 & 0xfe00fe00) == 0xe8000800) {
					// Instruction: 14: 1110100IIIIIvvvv0000100iiiiitttt | memw (Sp + #U5:2) = Rv ; memw (Sp + #u5:2) = Rt
					hi->instruction = HEX_INS_DUPLEX_MEMW__SP____U5_2____RV___MEMW__SP____U5_2____RT;
					hi->op_count = 4;
					hi->duplex = true;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x1f00000) >> 20) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rv
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f0) >> 4) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0xf) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (Sp + 0x%x) = %s ; memw (Sp + 0x%x) = %s", hi->ops[0].op.imm, hex_get_sub_reg(hi->ops[1].op.reg), hi->ops[2].op.imm, hex_get_sub_reg(hi->ops[3].op.reg));
					break;
				}
				break;
			}
		}
	}
	else {
		switch ((hi_u32 >> 28) & 0xF) {
			case 0x0: {
				// Handle constant extender
				hi->instruction = HEX_INS_IMMEXT;
				hi->op_count = 1;
				hi->ops[0].type = HEX_OP_TYPE_IMM;
				hi->ops[0].attr |= HEX_OP_CONST_EXT;
				hi->ops[0].op.imm = ((hi_u32 & 0x3FFF) | (((hi_u32 >> 16) & 0xFFF) << 14)) << 6;
				constant_extender = hi->ops[0].op.imm;
				sprintf(hi->mnem, "immext(#0x%x)", hi->ops[0].op.imm);
				break;
			}
			case 0x1: {
				if ((hi_u32 & 0xfc02300) == 0x1800000) {
					// Instruction: 1: 0001000110iissssPP0---00iiiiiii- | p0 = cmp.eq (Rs, #-1) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS____1____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, #-1) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1800100) {
					// Instruction: 1: 0001000110iissssPP0---01iiiiiii- | p0 = cmp.gt (Rs, #-1) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS____1____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, #-1) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1800300) {
					// Instruction: 1: 0001000110iissssPP0---11iiiiiii- | p0 = tstbit (Rs, #0) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___TSTBIT__RS___0____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = tstbit (R%d, #0) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1802000) {
					// Instruction: 1: 0001000110iissssPP1---00iiiiiii- | p0 = cmp.eq (Rs, #-1) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS____1____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, #-1) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1802100) {
					// Instruction: 1: 0001000110iissssPP1---01iiiiiii- | p0 = cmp.gt (Rs, #-1) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS____1____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, #-1) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1802300) {
					// Instruction: 1: 0001000110iissssPP1---11iiiiiii- | p0 = tstbit (Rs, #0) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___TSTBIT__RS___0____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = tstbit (R%d, #0) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c00000) {
					// Instruction: 1: 0001000111iissssPP0---00iiiiiii- | p0 = cmp.eq (Rs, #-1) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS____1____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, #-1) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c00100) {
					// Instruction: 1: 0001000111iissssPP0---01iiiiiii- | p0 = cmp.gt (Rs, #-1) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS____1____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, #-1) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c00300) {
					// Instruction: 1: 0001000111iissssPP0---11iiiiiii- | p0 = tstbit (Rs, #0) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___TSTBIT__RS___0____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = tstbit (R%d, #0) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c02000) {
					// Instruction: 1: 0001000111iissssPP1---00iiiiiii- | p0 = cmp.eq (Rs, #-1) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS____1____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, #-1) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c02100) {
					// Instruction: 1: 0001000111iissssPP1---01iiiiiii- | p0 = cmp.gt (Rs, #-1) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS____1____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, #-1) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x1c02300) {
					// Instruction: 1: 0001000111iissssPP1---11iiiiiii- | p0 = tstbit (Rs, #0) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___TSTBIT__RS___0____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = tstbit (R%d, #0) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x0) {
					// Instruction: 1: 0001000000iissssPP0IIIIIiiiiiii- | p0 = cmp.eq (Rs, #U5) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS___U5____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, 0x%x) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2000) {
					// Instruction: 1: 0001000000iissssPP1IIIIIiiiiiii- | p0 = cmp.eq (Rs, #U5) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS___U5____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, 0x%x) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x400000) {
					// Instruction: 1: 0001000001iissssPP0IIIIIiiiiiii- | p0 = cmp.eq (Rs, #U5) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS___U5____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, 0x%x) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x402000) {
					// Instruction: 1: 0001000001iissssPP1IIIIIiiiiiii- | p0 = cmp.eq (Rs, #U5) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS___U5____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, 0x%x) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x800000) {
					// Instruction: 1: 0001000010iissssPP0IIIIIiiiiiii- | p0 = cmp.gt (Rs, #U5) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS___U5____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, 0x%x) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x802000) {
					// Instruction: 1: 0001000010iissssPP1IIIIIiiiiiii- | p0 = cmp.gt (Rs, #U5) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS___U5____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, 0x%x) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0xc00000) {
					// Instruction: 1: 0001000011iissssPP0IIIIIiiiiiii- | p0 = cmp.gt (Rs, #U5) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS___U5____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, 0x%x) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0xc02000) {
					// Instruction: 1: 0001000011iissssPP1IIIIIiiiiiii- | p0 = cmp.gt (Rs, #U5) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS___U5____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, 0x%x) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1000000) {
					// Instruction: 1: 0001000100iissssPP0IIIIIiiiiiii- | p0 = cmp.gtu (Rs, #U5) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS___U5____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, 0x%x) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1002000) {
					// Instruction: 1: 0001000100iissssPP1IIIIIiiiiiii- | p0 = cmp.gtu (Rs, #U5) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS___U5____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, 0x%x) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1400000) {
					// Instruction: 1: 0001000101iissssPP0IIIIIiiiiiii- | p0 = cmp.gtu (Rs, #U5) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS___U5____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, 0x%x) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1402000) {
					// Instruction: 1: 0001000101iissssPP1IIIIIiiiiiii- | p0 = cmp.gtu (Rs, #U5) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS___U5____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, 0x%x) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3800000) {
					// Instruction: 1: 0001001110iissssPP0---00iiiiiii- | p1 = cmp.eq (Rs, #-1) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS____1____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, #-1) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3800100) {
					// Instruction: 1: 0001001110iissssPP0---01iiiiiii- | p1 = cmp.gt (Rs, #-1) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS____1____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, #-1) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3800300) {
					// Instruction: 1: 0001001110iissssPP0---11iiiiiii- | p1 = tstbit (Rs, #0) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___TSTBIT__RS___0____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = tstbit (R%d, #0) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3802000) {
					// Instruction: 1: 0001001110iissssPP1---00iiiiiii- | p1 = cmp.eq (Rs, #-1) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS____1____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, #-1) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3802100) {
					// Instruction: 1: 0001001110iissssPP1---01iiiiiii- | p1 = cmp.gt (Rs, #-1) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS____1____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, #-1) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3802300) {
					// Instruction: 1: 0001001110iissssPP1---11iiiiiii- | p1 = tstbit (Rs, #0) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___TSTBIT__RS___0____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = tstbit (R%d, #0) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c00000) {
					// Instruction: 1: 0001001111iissssPP0---00iiiiiii- | p1 = cmp.eq (Rs, #-1) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS____1____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, #-1) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c00100) {
					// Instruction: 1: 0001001111iissssPP0---01iiiiiii- | p1 = cmp.gt (Rs, #-1) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS____1____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, #-1) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c00300) {
					// Instruction: 1: 0001001111iissssPP0---11iiiiiii- | p1 = tstbit (Rs, #0) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___TSTBIT__RS___0____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = tstbit (R%d, #0) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c02000) {
					// Instruction: 1: 0001001111iissssPP1---00iiiiiii- | p1 = cmp.eq (Rs, #-1) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS____1____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, #-1) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c02100) {
					// Instruction: 1: 0001001111iissssPP1---01iiiiiii- | p1 = cmp.gt (Rs, #-1) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS____1____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, #-1) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02300) == 0x3c02300) {
					// Instruction: 1: 0001001111iissssPP1---11iiiiiii- | p1 = tstbit (Rs, #0) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___TSTBIT__RS___0____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = tstbit (R%d, #0) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2000000) {
					// Instruction: 1: 0001001000iissssPP0IIIIIiiiiiii- | p1 = cmp.eq (Rs, #U5) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS___U5____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, 0x%x) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2002000) {
					// Instruction: 1: 0001001000iissssPP1IIIIIiiiiiii- | p1 = cmp.eq (Rs, #U5) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS___U5____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, 0x%x) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2400000) {
					// Instruction: 1: 0001001001iissssPP0IIIIIiiiiiii- | p1 = cmp.eq (Rs, #U5) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS___U5____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, 0x%x) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2402000) {
					// Instruction: 1: 0001001001iissssPP1IIIIIiiiiiii- | p1 = cmp.eq (Rs, #U5) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS___U5____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, 0x%x) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2800000) {
					// Instruction: 1: 0001001010iissssPP0IIIIIiiiiiii- | p1 = cmp.gt (Rs, #U5) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS___U5____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, 0x%x) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2802000) {
					// Instruction: 1: 0001001010iissssPP1IIIIIiiiiiii- | p1 = cmp.gt (Rs, #U5) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS___U5____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, 0x%x) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2c00000) {
					// Instruction: 1: 0001001011iissssPP0IIIIIiiiiiii- | p1 = cmp.gt (Rs, #U5) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS___U5____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, 0x%x) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2c02000) {
					// Instruction: 1: 0001001011iissssPP1IIIIIiiiiiii- | p1 = cmp.gt (Rs, #U5) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS___U5____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, 0x%x) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x3000000) {
					// Instruction: 1: 0001001100iissssPP0IIIIIiiiiiii- | p1 = cmp.gtu (Rs, #U5) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS___U5____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, 0x%x) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x3002000) {
					// Instruction: 1: 0001001100iissssPP1IIIIIiiiiiii- | p1 = cmp.gtu (Rs, #U5) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS___U5____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, 0x%x) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x3400000) {
					// Instruction: 1: 0001001101iissssPP0IIIIIiiiiiii- | p1 = cmp.gtu (Rs, #U5) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS___U5____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, 0x%x) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x3402000) {
					// Instruction: 1: 0001001101iissssPP1IIIIIiiiiiii- | p1 = cmp.gtu (Rs, #U5) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS___U5____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, 0x%x) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4000000) {
					// Instruction: 1: 0001010000iissssPP00ttttiiiiiii- | p0 = cmp.eq (Rs, Rt) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS__RT____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, R%d) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4001000) {
					// Instruction: 1: 0001010000iissssPP01ttttiiiiiii- | p1 = cmp.eq (Rs, Rt) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS__RT____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, R%d) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4002000) {
					// Instruction: 1: 0001010000iissssPP10ttttiiiiiii- | p0 = cmp.eq (Rs, Rt) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS__RT____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, R%d) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4003000) {
					// Instruction: 1: 0001010000iissssPP11ttttiiiiiii- | p1 = cmp.eq (Rs, Rt) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS__RT____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, R%d) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4400000) {
					// Instruction: 1: 0001010001iissssPP00ttttiiiiiii- | p0 = cmp.eq (Rs, Rt) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS__RT____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, R%d) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4401000) {
					// Instruction: 1: 0001010001iissssPP01ttttiiiiiii- | p1 = cmp.eq (Rs, Rt) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS__RT____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, R%d) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4402000) {
					// Instruction: 1: 0001010001iissssPP10ttttiiiiiii- | p0 = cmp.eq (Rs, Rt) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_EQ__RS__RT____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.eq (R%d, R%d) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4403000) {
					// Instruction: 1: 0001010001iissssPP11ttttiiiiiii- | p1 = cmp.eq (Rs, Rt) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_EQ__RS__RT____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.eq (R%d, R%d) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4800000) {
					// Instruction: 1: 0001010010iissssPP00ttttiiiiiii- | p0 = cmp.gt (Rs, Rt) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS__RT____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, R%d) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4801000) {
					// Instruction: 1: 0001010010iissssPP01ttttiiiiiii- | p1 = cmp.gt (Rs, Rt) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS__RT____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, R%d) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4802000) {
					// Instruction: 1: 0001010010iissssPP10ttttiiiiiii- | p0 = cmp.gt (Rs, Rt) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS__RT____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, R%d) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4803000) {
					// Instruction: 1: 0001010010iissssPP11ttttiiiiiii- | p1 = cmp.gt (Rs, Rt) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS__RT____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, R%d) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4c00000) {
					// Instruction: 1: 0001010011iissssPP00ttttiiiiiii- | p0 = cmp.gt (Rs, Rt) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS__RT____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, R%d) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4c01000) {
					// Instruction: 1: 0001010011iissssPP01ttttiiiiiii- | p1 = cmp.gt (Rs, Rt) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS__RT____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, R%d) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4c02000) {
					// Instruction: 1: 0001010011iissssPP10ttttiiiiiii- | p0 = cmp.gt (Rs, Rt) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GT__RS__RT____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gt (R%d, R%d) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x4c03000) {
					// Instruction: 1: 0001010011iissssPP11ttttiiiiiii- | p1 = cmp.gt (Rs, Rt) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GT__RS__RT____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gt (R%d, R%d) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5000000) {
					// Instruction: 1: 0001010100iissssPP00ttttiiiiiii- | p0 = cmp.gtu (Rs, Rt) ; if (p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS__RT____IF__P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, R%d) ; if (p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5001000) {
					// Instruction: 1: 0001010100iissssPP01ttttiiiiiii- | p1 = cmp.gtu (Rs, Rt) ; if (p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS__RT____IF__P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, R%d) ; if (p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5002000) {
					// Instruction: 1: 0001010100iissssPP10ttttiiiiiii- | p0 = cmp.gtu (Rs, Rt) ; if (p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS__RT____IF__P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, R%d) ; if (p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5003000) {
					// Instruction: 1: 0001010100iissssPP11ttttiiiiiii- | p1 = cmp.gtu (Rs, Rt) ; if (p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS__RT____IF__P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, R%d) ; if (p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5400000) {
					// Instruction: 1: 0001010101iissssPP00ttttiiiiiii- | p0 = cmp.gtu (Rs, Rt) ; if (!p0.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS__RT____IF___NOT_P0_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, R%d) ; if (!p0.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5401000) {
					// Instruction: 1: 0001010101iissssPP01ttttiiiiiii- | p1 = cmp.gtu (Rs, Rt) ; if (!p1.new) jump:nt #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS__RT____IF___NOT_P1_NEW__JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, R%d) ; if (!p1.new) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5402000) {
					// Instruction: 1: 0001010101iissssPP10ttttiiiiiii- | p0 = cmp.gtu (Rs, Rt) ; if (!p0.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P0___CMP_GTU__RS__RT____IF___NOT_P0_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p0 = cmp.gtu (R%d, R%d) ; if (!p0.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc03000) == 0x5403000) {
					// Instruction: 1: 0001010101iissssPP11ttttiiiiiii- | p1 = cmp.gtu (Rs, Rt) ; if (!p1.new) jump:t #r9:2
					hi->instruction = HEX_INS_MULT_P1___CMP_GTU__RS__RT____IF___NOT_P1_NEW__JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p1 = cmp.gtu (R%d, R%d) ; if (!p1.new) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x6000000) {
					// Instruction: 1: 00010110--iiddddPPIIIIIIiiiiiii- | Rd = #U6 ; jump #r9:2
					hi->instruction = HEX_INS_MULT_RD____U6___JUMP__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = 0x%x ; jump 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x7000000) {
					// Instruction: 1: 00010111--iissssPP--ddddiiiiiii- | Rd = Rs ; jump #r9:2
					hi->instruction = HEX_INS_MULT_RD___RS___JUMP__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0xf00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0xf0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = R%d ; jump 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				break;
			}
			case 0x2: {
				if ((hi_u32 & 0xfc02000) == 0x0) {
					// Instruction: 2: 0010000000ii-sssPP0tttttiiiiiii- | if (cmp.eq (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.eq (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2000) {
					// Instruction: 2: 0010000000ii-sssPP1tttttiiiiiii- | if (cmp.eq (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.eq (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x400000) {
					// Instruction: 2: 0010000001ii-sssPP0tttttiiiiiii- | if (!cmp.eq (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.eq (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x402000) {
					// Instruction: 2: 0010000001ii-sssPP1tttttiiiiiii- | if (!cmp.eq (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.eq (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x800000) {
					// Instruction: 2: 0010000010ii-sssPP0tttttiiiiiii- | if (cmp.gt (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x802000) {
					// Instruction: 2: 0010000010ii-sssPP1tttttiiiiiii- | if (cmp.gt (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0xc00000) {
					// Instruction: 2: 0010000011ii-sssPP0tttttiiiiiii- | if (!cmp.gt (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0xc02000) {
					// Instruction: 2: 0010000011ii-sssPP1tttttiiiiiii- | if (!cmp.gt (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1000000) {
					// Instruction: 2: 0010000100ii-sssPP0tttttiiiiiii- | if (cmp.gtu (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1002000) {
					// Instruction: 2: 0010000100ii-sssPP1tttttiiiiiii- | if (cmp.gtu (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1400000) {
					// Instruction: 2: 0010000101ii-sssPP0tttttiiiiiii- | if (!cmp.gtu (Ns.new, Rt)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__NS_NEW__RT___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1402000) {
					// Instruction: 2: 0010000101ii-sssPP1tttttiiiiiii- | if (!cmp.gtu (Ns.new, Rt)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__NS_NEW__RT___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1800000) {
					// Instruction: 2: 0010000110ii-sssPP0tttttiiiiiii- | if (cmp.gt (Rt, Ns.new)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__RT__NS_NEW___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1802000) {
					// Instruction: 2: 0010000110ii-sssPP1tttttiiiiiii- | if (cmp.gt (Rt, Ns.new)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__RT__NS_NEW___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1c00000) {
					// Instruction: 2: 0010000111ii-sssPP0tttttiiiiiii- | if (!cmp.gt (Rt, Ns.new)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__RT__NS_NEW___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x1c02000) {
					// Instruction: 2: 0010000111ii-sssPP1tttttiiiiiii- | if (!cmp.gt (Rt, Ns.new)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__RT__NS_NEW___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2000000) {
					// Instruction: 2: 0010001000ii-sssPP0tttttiiiiiii- | if (cmp.gtu (Rt, Ns.new)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__RT__NS_NEW___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2002000) {
					// Instruction: 2: 0010001000ii-sssPP1tttttiiiiiii- | if (cmp.gtu (Rt, Ns.new)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__RT__NS_NEW___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2400000) {
					// Instruction: 2: 0010001001ii-sssPP0tttttiiiiiii- | if (!cmp.gtu (Rt, Ns.new)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__RT__NS_NEW___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, R%d)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x2402000) {
					// Instruction: 2: 0010001001ii-sssPP1tttttiiiiiii- | if (!cmp.gtu (Rt, Ns.new)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__RT__NS_NEW___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, R%d)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.reg, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4000000) {
					// Instruction: 2: 0010010000ii-sssPP0IIIIIiiiiiii- | if (cmp.eq (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (cmp.eq (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4002000) {
					// Instruction: 2: 0010010000ii-sssPP1IIIIIiiiiiii- | if (cmp.eq (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (cmp.eq (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4400000) {
					// Instruction: 2: 0010010001ii-sssPP0IIIIIiiiiiii- | if (!cmp.eq (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (!cmp.eq (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4402000) {
					// Instruction: 2: 0010010001ii-sssPP1IIIIIiiiiiii- | if (!cmp.eq (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (!cmp.eq (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4800000) {
					// Instruction: 2: 0010010010ii-sssPP0IIIIIiiiiiii- | if (cmp.gt (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (cmp.gt (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4802000) {
					// Instruction: 2: 0010010010ii-sssPP1IIIIIiiiiiii- | if (cmp.gt (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (cmp.gt (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4c00000) {
					// Instruction: 2: 0010010011ii-sssPP0IIIIIiiiiiii- | if (!cmp.gt (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (!cmp.gt (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x4c02000) {
					// Instruction: 2: 0010010011ii-sssPP1IIIIIiiiiiii- | if (!cmp.gt (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (!cmp.gt (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5000000) {
					// Instruction: 2: 0010010100ii-sssPP0IIIIIiiiiiii- | if (cmp.gtu (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5002000) {
					// Instruction: 2: 0010010100ii-sssPP1IIIIIiiiiiii- | if (cmp.gtu (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GTU__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gtu (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5400000) {
					// Instruction: 2: 0010010101ii-sssPP0IIIIIiiiiiii- | if (!cmp.gtu (Ns.new, #U5)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__NS_NEW___U5___JUMP_NT__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, 0x%x)) jump:nt 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5402000) {
					// Instruction: 2: 0010010101ii-sssPP1IIIIIiiiiiii- | if (!cmp.gtu (Ns.new, #U5)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GTU__NS_NEW___U5___JUMP_T__R9_2;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gtu (R%d, 0x%x)) jump:t 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, addr + (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5800000) {
					// Instruction: 2: 0010010110ii-sssPP0-----iiiiiii- | if (tstbit (Ns.new, #0)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__TSTBIT__NS_NEW___0___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (tstbit (R%d, #0)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5802000) {
					// Instruction: 2: 0010010110ii-sssPP1-----iiiiiii- | if (tstbit (Ns.new, #0)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__TSTBIT__NS_NEW___0___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (tstbit (R%d, #0)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5c00000) {
					// Instruction: 2: 0010010111ii-sssPP0-----iiiiiii- | if (!tstbit (Ns.new, #0)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_TSTBIT__NS_NEW___0___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!tstbit (R%d, #0)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x5c02000) {
					// Instruction: 2: 0010010111ii-sssPP1-----iiiiiii- | if (!tstbit (Ns.new, #0)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_TSTBIT__NS_NEW___0___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!tstbit (R%d, #0)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6000000) {
					// Instruction: 2: 0010011000ii-sssPP0-----iiiiiii- | if (cmp.eq (Ns.new, #-1)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW____1___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.eq (R%d, #-1)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6002000) {
					// Instruction: 2: 0010011000ii-sssPP1-----iiiiiii- | if (cmp.eq (Ns.new, #-1)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_EQ__NS_NEW____1___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.eq (R%d, #-1)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6400000) {
					// Instruction: 2: 0010011001ii-sssPP0-----iiiiiii- | if (!cmp.eq (Ns.new, #-1)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW____1___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.eq (R%d, #-1)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6402000) {
					// Instruction: 2: 0010011001ii-sssPP1-----iiiiiii- | if (!cmp.eq (Ns.new, #-1)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_EQ__NS_NEW____1___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.eq (R%d, #-1)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6800000) {
					// Instruction: 2: 0010011010ii-sssPP0-----iiiiiii- | if (cmp.gt (Ns.new, #-1)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW____1___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, #-1)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6802000) {
					// Instruction: 2: 0010011010ii-sssPP1-----iiiiiii- | if (cmp.gt (Ns.new, #-1)) jump:t #r9:2
					hi->instruction = HEX_INS_IF__CMP_GT__NS_NEW____1___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (cmp.gt (R%d, #-1)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6c00000) {
					// Instruction: 2: 0010011011ii-sssPP0-----iiiiiii- | if (!cmp.gt (Ns.new, #-1)) jump:nt #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW____1___JUMP_NT__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, #-1)) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc02000) == 0x6c02000) {
					// Instruction: 2: 0010011011ii-sssPP1-----iiiiiii- | if (!cmp.gt (Ns.new, #-1)) jump:t #r9:2
					hi->instruction = HEX_INS_IF___NOT_CMP_GT__NS_NEW____1___JUMP_T__R9_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x70000) >> 16); // Ns.new
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x300000) >> 13) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (!cmp.gt (R%d, #-1)) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				break;
			}
			case 0x3: {
				if ((hi_u32 & 0xfe00000) == 0xac00000) {
					// Instruction: 3: 00111010110sssssPPittttti--ddddd | Rdd = memd (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RDD___MEMD__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d + R%d << 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xc00000) {
					// Instruction: 3: 00110000110sssssPPitttttivvddddd | if (Pv) Rdd = memd (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RDD___MEMD__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d:R%d = memd (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1c00000) {
					// Instruction: 3: 00110001110sssssPPitttttivvddddd | if !Pv Rdd = memd (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RDD___MEMD__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d:R%d = memd (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2c00000) {
					// Instruction: 3: 00110010110sssssPPitttttivvddddd | if (Pv.new) Rdd = memd (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RDD___MEMD__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d:R%d = memd (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3c00000) {
					// Instruction: 3: 00110011110sssssPPitttttivvddddd | if !Pv.new Rdd = memd (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RDD___MEMD__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d:R%d = memd (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa000000) {
					// Instruction: 3: 00111010000sssssPPittttti--ddddd | Rd = memb (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RD___MEMB__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d + R%d << 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x0) {
					// Instruction: 3: 00110000000sssssPPitttttivvddddd | if (Pv) Rd = memb (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RD___MEMB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d = memb (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1000000) {
					// Instruction: 3: 00110001000sssssPPitttttivvddddd | if !Pv Rd = memb (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RD___MEMB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d = memb (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2000000) {
					// Instruction: 3: 00110010000sssssPPitttttivvddddd | if (Pv.new) Rd = memb (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RD___MEMB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memb (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3000000) {
					// Instruction: 3: 00110011000sssssPPitttttivvddddd | if !Pv.new Rd = memb (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RD___MEMB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d = memb (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa400000) {
					// Instruction: 3: 00111010010sssssPPittttti--ddddd | Rd = memh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RD___MEMH__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d + R%d << 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x400000) {
					// Instruction: 3: 00110000010sssssPPitttttivvddddd | if (Pv) Rd = memh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RD___MEMH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d = memh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1400000) {
					// Instruction: 3: 00110001010sssssPPitttttivvddddd | if !Pv Rd = memh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RD___MEMH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d = memh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2400000) {
					// Instruction: 3: 00110010010sssssPPitttttivvddddd | if (Pv.new) Rd = memh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RD___MEMH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3400000) {
					// Instruction: 3: 00110011010sssssPPitttttivvddddd | if !Pv.new Rd = memh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RD___MEMH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d = memh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa200000) {
					// Instruction: 3: 00111010001sssssPPittttti--ddddd | Rd = memub (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RD___MEMUB__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d + R%d << 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x200000) {
					// Instruction: 3: 00110000001sssssPPitttttivvddddd | if (Pv) Rd = memub (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RD___MEMUB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d = memub (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1200000) {
					// Instruction: 3: 00110001001sssssPPitttttivvddddd | if !Pv Rd = memub (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RD___MEMUB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d = memub (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2200000) {
					// Instruction: 3: 00110010001sssssPPitttttivvddddd | if (Pv.new) Rd = memub (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RD___MEMUB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memub (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3200000) {
					// Instruction: 3: 00110011001sssssPPitttttivvddddd | if !Pv.new Rd = memub (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RD___MEMUB__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d = memub (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa600000) {
					// Instruction: 3: 00111010011sssssPPittttti--ddddd | Rd = memuh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RD___MEMUH__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d + R%d << 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x600000) {
					// Instruction: 3: 00110000011sssssPPitttttivvddddd | if (Pv) Rd = memuh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RD___MEMUH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d = memuh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1600000) {
					// Instruction: 3: 00110001011sssssPPitttttivvddddd | if !Pv Rd = memuh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RD___MEMUH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d = memuh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2600000) {
					// Instruction: 3: 00110010011sssssPPitttttivvddddd | if (Pv.new) Rd = memuh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RD___MEMUH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memuh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3600000) {
					// Instruction: 3: 00110011011sssssPPitttttivvddddd | if !Pv.new Rd = memuh (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RD___MEMUH__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d = memuh (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa800000) {
					// Instruction: 3: 00111010100sssssPPittttti--ddddd | Rd = memw (Rs + Rt << #u2)
					hi->instruction = HEX_INS_RD___MEMW__RS___RT_____U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d + R%d << 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x800000) {
					// Instruction: 3: 00110000100sssssPPitttttivvddddd | if (Pv) Rd = memw (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV__RD___MEMW__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) R%d = memw (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1800000) {
					// Instruction: 3: 00110001100sssssPPitttttivvddddd | if !Pv Rd = memw (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_RD___MEMW__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d R%d = memw (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2800000) {
					// Instruction: 3: 00110010100sssssPPitttttivvddddd | if (Pv.new) Rd = memw (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__PV_NEW__RD___MEMW__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memw (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3800000) {
					// Instruction: 3: 00110011100sssssPPitttttivvddddd | if !Pv.new Rd = memw (Rs + Rt << #u2)
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_RD___MEMW__RS___RT_____U2_;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[4].type = HEX_OP_TYPE_IMM;
					hi->ops[4].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new R%d = memw (R%d + R%d << 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg, hi->ops[4].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe000000) {
					// Instruction: 3: 00111110-00sssssPP0iiiiii00ttttt | memb (Rs + #u6:0) += Rt
					hi->instruction = HEX_INS_MEMB__RS____U6_0___PLUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) += R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe000020) {
					// Instruction: 3: 00111110-00sssssPP0iiiiii01ttttt | memb (Rs + #u6:0) -= Rt
					hi->instruction = HEX_INS_MEMB__RS____U6_0___MINUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) -= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe000040) {
					// Instruction: 3: 00111110-00sssssPP0iiiiii10ttttt | memb (Rs + #u6:0) &= Rt
					hi->instruction = HEX_INS_MEMB__RS____U6_0___AND_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) &= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe000060) {
					// Instruction: 3: 00111110-00sssssPP0iiiiii11ttttt | memb (Rs + #u6:0) |= Rt
					hi->instruction = HEX_INS_MEMB__RS____U6_0___OR_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) |= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf000000) {
					// Instruction: 3: 00111111-00sssssPP0iiiiii00IIIII | memb (Rs + #u6:0) += #U5
					hi->instruction = HEX_INS_MEMB__RS____U6_0___PLUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) += 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf000020) {
					// Instruction: 3: 00111111-00sssssPP0iiiiii01IIIII | memb (Rs + #u6:0) -= #U5
					hi->instruction = HEX_INS_MEMB__RS____U6_0___MINUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) -= 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf000040) {
					// Instruction: 3: 00111111-00sssssPP0iiiiii10IIIII | memb (Rs + #u6:0) = clrbit (#U5)
					hi->instruction = HEX_INS_MEMB__RS____U6_0____CLRBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) = clrbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf000060) {
					// Instruction: 3: 00111111-00sssssPP0iiiiii11IIIII | memb (Rs + #u6:0) = setbit (#U5)
					hi->instruction = HEX_INS_MEMB__RS____U6_0____SETBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + 0x%x) = setbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe200000) {
					// Instruction: 3: 00111110-01sssssPP0iiiiii00ttttt | memh (Rs + #u6:1) += Rt
					hi->instruction = HEX_INS_MEMH__RS____U6_1___PLUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) += R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe200020) {
					// Instruction: 3: 00111110-01sssssPP0iiiiii01ttttt | memh (Rs + #u6:1) -= Rt
					hi->instruction = HEX_INS_MEMH__RS____U6_1___MINUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) -= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe200040) {
					// Instruction: 3: 00111110-01sssssPP0iiiiii10ttttt | memh (Rs + #u6:1) &= Rt
					hi->instruction = HEX_INS_MEMH__RS____U6_1___AND_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) &= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe200060) {
					// Instruction: 3: 00111110-01sssssPP0iiiiii11ttttt | memh (Rs + #u6:1) |= Rt
					hi->instruction = HEX_INS_MEMH__RS____U6_1___OR_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) |= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf200000) {
					// Instruction: 3: 00111111-01sssssPP0iiiiii00IIIII | memh (Rs + #u6:1) += #U5
					hi->instruction = HEX_INS_MEMH__RS____U6_1___PLUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) += 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf200020) {
					// Instruction: 3: 00111111-01sssssPP0iiiiii01IIIII | memh (Rs + #u6:1) -= #U5
					hi->instruction = HEX_INS_MEMH__RS____U6_1___MINUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) -= 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf200040) {
					// Instruction: 3: 00111111-01sssssPP0iiiiii10IIIII | memh (Rs + #u6:1) = clrbit (#U5)
					hi->instruction = HEX_INS_MEMH__RS____U6_1____CLRBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) = clrbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf200060) {
					// Instruction: 3: 00111111-01sssssPP0iiiiii11IIIII | memh (Rs + #u6:1) = setbit (#U5)
					hi->instruction = HEX_INS_MEMH__RS____U6_1____SETBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + 0x%x) = setbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe400000) {
					// Instruction: 3: 00111110-10sssssPP0iiiiii00ttttt | memw (Rs + #u6:2) += Rt
					hi->instruction = HEX_INS_MEMW__RS____U6_2___PLUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) += R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe400020) {
					// Instruction: 3: 00111110-10sssssPP0iiiiii01ttttt | memw (Rs + #u6:2) -= Rt
					hi->instruction = HEX_INS_MEMW__RS____U6_2___MINUS_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) -= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe400040) {
					// Instruction: 3: 00111110-10sssssPP0iiiiii10ttttt | memw (Rs + #u6:2) &= Rt
					hi->instruction = HEX_INS_MEMW__RS____U6_2___AND_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) &= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xe400060) {
					// Instruction: 3: 00111110-10sssssPP0iiiiii11ttttt | memw (Rs + #u6:2) |= Rt
					hi->instruction = HEX_INS_MEMW__RS____U6_2___OR_EQ__RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) |= R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf400000) {
					// Instruction: 3: 00111111-10sssssPP0iiiiii00IIIII | memw (Rs + #u6:2) += #U5
					hi->instruction = HEX_INS_MEMW__RS____U6_2___PLUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) += 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf400020) {
					// Instruction: 3: 00111111-10sssssPP0iiiiii01IIIII | memw (Rs + #u6:2) -= #U5
					hi->instruction = HEX_INS_MEMW__RS____U6_2___MINUS_EQ___U5;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) -= 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf400040) {
					// Instruction: 3: 00111111-10sssssPP0iiiiii10IIIII | memw (Rs + #u6:2) = clrbit (#U5)
					hi->instruction = HEX_INS_MEMW__RS____U6_2____CLRBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) = clrbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602060) == 0xf400060) {
					// Instruction: 3: 00111111-10sssssPP0iiiiii11IIIII | memw (Rs + #u6:2) = setbit (#U5)
					hi->instruction = HEX_INS_MEMW__RS____U6_2____SETBIT___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + 0x%x) = setbit (0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xba00000) {
					// Instruction: 3: 00111011101sssssPPiuuuuui--00ttt | memb (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_MEMB__RS___RU_____U2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x4a00000) {
					// Instruction: 3: 00110100101sssssPPiuuuuuivv00ttt | if (Pv) memb (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMB__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x5a00000) {
					// Instruction: 3: 00110101101sssssPPiuuuuuivv00ttt | if !Pv memb (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x6a00000) {
					// Instruction: 3: 00110110101sssssPPiuuuuuivv00ttt | if (Pv.new) memb (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x7a00000) {
					// Instruction: 3: 00110111101sssssPPiuuuuuivv00ttt | if !Pv.new memb (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xba00008) {
					// Instruction: 3: 00111011101sssssPPiuuuuui--01ttt | memh (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_MEMH__RS___RU_____U2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x4a00008) {
					// Instruction: 3: 00110100101sssssPPiuuuuuivv01ttt | if (Pv) memh (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMH__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x5a00008) {
					// Instruction: 3: 00110101101sssssPPiuuuuuivv01ttt | if !Pv memh (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x6a00008) {
					// Instruction: 3: 00110110101sssssPPiuuuuuivv01ttt | if (Pv.new) memh (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x7a00008) {
					// Instruction: 3: 00110111101sssssPPiuuuuuivv01ttt | if !Pv.new memh (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xba00010) {
					// Instruction: 3: 00111011101sssssPPiuuuuui--10ttt | memw (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_MEMW__RS___RU_____U2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x4a00010) {
					// Instruction: 3: 00110100101sssssPPiuuuuuivv10ttt | if (Pv) memw (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMW__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x5a00010) {
					// Instruction: 3: 00110101101sssssPPiuuuuuivv10ttt | if !Pv memw (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x6a00010) {
					// Instruction: 3: 00110110101sssssPPiuuuuuivv10ttt | if (Pv.new) memw (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0x7a00010) {
					// Instruction: 3: 00110111101sssssPPiuuuuuivv10ttt | if !Pv.new memw (Rs + Ru << #u2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RS___RU_____U2____NT_NEW;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x7) >> 0); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xbc00000) {
					// Instruction: 3: 00111011110sssssPPiuuuuui--ttttt | memd (Rs + Ru << #u2) = Rtt
					hi->instruction = HEX_INS_MEMD__RS___RU_____U2____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d + R%d << 0x%x) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4c00000) {
					// Instruction: 3: 00110100110sssssPPiuuuuuivvttttt | if (Pv) memd (Rs + Ru << #u2) = Rtt
					hi->instruction = HEX_INS_IF__PV__MEMD__RS___RU_____U2____RTT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memd (R%d + R%d << 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg + 1, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5c00000) {
					// Instruction: 3: 00110101110sssssPPiuuuuuivvttttt | if !Pv memd (Rs + Ru << #u2) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMD__RS___RU_____U2____RTT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memd (R%d + R%d << 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg + 1, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6c00000) {
					// Instruction: 3: 00110110110sssssPPiuuuuuivvttttt | if (Pv.new) memd (Rs + Ru << #u2) = Rtt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMD__RS___RU_____U2____RTT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memd (R%d + R%d << 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg + 1, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7c00000) {
					// Instruction: 3: 00110111110sssssPPiuuuuuivvttttt | if !Pv.new memd (Rs + Ru << #u2) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMD__RS___RU_____U2____RTT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].attr |= HEX_OP_REG_PAIR;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memd (R%d + R%d << 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg + 1, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xb000000) {
					// Instruction: 3: 00111011000sssssPPiuuuuui--ttttt | memb (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_MEMB__RS___RU_____U2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xe600000) == 0xc000000) {
					// Instruction: 3: 0011110--00sssssPPIiiiiiiIIIIIII | memb (Rs + #u6:0) = #S8
					hi->instruction = HEX_INS_MEMB__RS____U6_0_____S8;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0x7f) >> 0));
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d + 0x%x) = %d", hi->ops[0].op.reg, hi->ops[1].op.imm, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4000000) {
					// Instruction: 3: 00110100000sssssPPiuuuuuivvttttt | if (Pv) memb (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMB__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5000000) {
					// Instruction: 3: 00110101000sssssPPiuuuuuivvttttt | if !Pv memb (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6000000) {
					// Instruction: 3: 00110110000sssssPPiuuuuuivvttttt | if (Pv.new) memb (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7000000) {
					// Instruction: 3: 00110111000sssssPPiuuuuuivvttttt | if !Pv.new memb (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8000000) {
					// Instruction: 3: 00111000000sssssPPIiiiiiivvIIIII | if (Pv) memb (Rs + #u6:0) = #S6
					hi->instruction = HEX_INS_IF__PV__MEMB__RS____U6_0_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8800000) {
					// Instruction: 3: 00111000100sssssPPIiiiiiivvIIIII | if !Pv memb (Rs + #u6:0) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RS____U6_0_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9000000) {
					// Instruction: 3: 00111001000sssssPPIiiiiiivvIIIII | if (Pv.new) memb (Rs + #u6:0) = #S6
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RS____U6_0_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9800000) {
					// Instruction: 3: 00111001100sssssPPIiiiiiivvIIIII | if !Pv.new memb (Rs + #u6:0) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RS____U6_0_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xb400000) {
					// Instruction: 3: 00111011010sssssPPiuuuuui--ttttt | memh (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_MEMH__RS___RU_____U2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xb600000) {
					// Instruction: 3: 00111011011sssssPPiuuuuui--ttttt | memh (Rs + Ru << #u2) = Rt.H
					hi->instruction = HEX_INS_MEMH__RS___RU_____U2____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + R%d << 0x%x) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xe600000) == 0xc200000) {
					// Instruction: 3: 0011110--01sssssPPIiiiiiiIIIIIII | memh (Rs + #u6:1) = #S8
					hi->instruction = HEX_INS_MEMH__RS____U6_1_____S8;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0x7f) >> 0));
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 1);
					sprintf(hi->mnem, "memh (R%d + 0x%x) = %d", hi->ops[0].op.reg, hi->ops[1].op.imm, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4400000) {
					// Instruction: 3: 00110100010sssssPPiuuuuuivvttttt | if (Pv) memh (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMH__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4600000) {
					// Instruction: 3: 00110100011sssssPPiuuuuuivvttttt | if (Pv) memh (Rs + Ru << #u2) = Rt.H
					hi->instruction = HEX_INS_IF__PV__MEMH__RS___RU_____U2____RT_H;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + R%d << 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5400000) {
					// Instruction: 3: 00110101010sssssPPiuuuuuivvttttt | if !Pv memh (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5600000) {
					// Instruction: 3: 00110101011sssssPPiuuuuuivvttttt | if !Pv memh (Rs + Ru << #u2) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS___RU_____U2____RT_H;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + R%d << 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6400000) {
					// Instruction: 3: 00110110010sssssPPiuuuuuivvttttt | if (Pv.new) memh (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6600000) {
					// Instruction: 3: 00110110011sssssPPiuuuuuivvttttt | if (Pv.new) memh (Rs + Ru << #u2) = Rt.H
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS___RU_____U2____RT_H;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + R%d << 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7400000) {
					// Instruction: 3: 00110111010sssssPPiuuuuuivvttttt | if !Pv.new memh (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7600000) {
					// Instruction: 3: 00110111011sssssPPiuuuuuivvttttt | if !Pv.new memh (Rs + Ru << #u2) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS___RU_____U2____RT_H;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + R%d << 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8200000) {
					// Instruction: 3: 00111000001sssssPPIiiiiiivvIIIII | if (Pv) memh (Rs + #u6:1) = #S6
					hi->instruction = HEX_INS_IF__PV__MEMH__RS____U6_1_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8a00000) {
					// Instruction: 3: 00111000101sssssPPIiiiiiivvIIIII | if !Pv memh (Rs + #u6:1) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS____U6_1_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9200000) {
					// Instruction: 3: 00111001001sssssPPIiiiiiivvIIIII | if (Pv.new) memh (Rs + #u6:1) = #S6
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS____U6_1_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9a00000) {
					// Instruction: 3: 00111001101sssssPPIiiiiiivvIIIII | if !Pv.new memh (Rs + #u6:1) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS____U6_1_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xb800000) {
					// Instruction: 3: 00111011100sssssPPiuuuuui--ttttt | memw (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_MEMW__RS___RU_____U2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xe600000) == 0xc400000) {
					// Instruction: 3: 0011110--10sssssPPIiiiiiiIIIIIII | memw (Rs + #u6:2) = #S8
					hi->instruction = HEX_INS_MEMW__RS____U6_2_____S8;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0x7f) >> 0));
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "memw (R%d + 0x%x) = %d", hi->ops[0].op.reg, hi->ops[1].op.imm, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4800000) {
					// Instruction: 3: 00110100100sssssPPiuuuuuivvttttt | if (Pv) memw (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMW__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5800000) {
					// Instruction: 3: 00110101100sssssPPiuuuuuivvttttt | if !Pv memw (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6800000) {
					// Instruction: 3: 00110110100sssssPPiuuuuuivvttttt | if (Pv.new) memw (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7800000) {
					// Instruction: 3: 00110111100sssssPPiuuuuuivvttttt | if !Pv.new memw (Rs + Ru << #u2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RS___RU_____U2____RT;
					hi->op_count = 5;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[4].type = HEX_OP_TYPE_REG;
					hi->ops[4].op.reg = (((hi_u32) & 0x1f) >> 0); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d + R%d << 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm, hi->ops[4].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8400000) {
					// Instruction: 3: 00111000010sssssPPIiiiiiivvIIIII | if (Pv) memw (Rs + #u6:2) = #S6
					hi->instruction = HEX_INS_IF__PV__MEMW__RS____U6_2_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8c00000) {
					// Instruction: 3: 00111000110sssssPPIiiiiiivvIIIII | if !Pv memw (Rs + #u6:2) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RS____U6_2_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9400000) {
					// Instruction: 3: 00111001010sssssPPIiiiiiivvIIIII | if (Pv.new) memw (Rs + #u6:2) = #S6
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RS____U6_2_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9c00000) {
					// Instruction: 3: 00111001110sssssPPIiiiiiivvIIIII | if !Pv.new memw (Rs + #u6:2) = #S6
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RS____U6_2_____S6;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f80) >> 7) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0x1f) >> 0));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d + 0x%x) = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				break;
			}
			case 0x4: {
				if ((hi_u32 & 0x9e00000) == 0x9c00000) {
					// Instruction: 4: 01001ii1110iiiiiPPiiiiiiiiiddddd | Rdd = memd (gp + #u16:3)
					hi->instruction = HEX_INS_RDD___MEMD__GP____U16_3_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5)) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (gp + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1c00000) {
					// Instruction: 4: 01000001110sssssPP0ttiiiiiiddddd | if (Pt) Rdd = memd (Rs + #u6:3)
					hi->instruction = HEX_INS_IF__PT__RDD___MEMD__RS____U6_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 3; // scaled
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend_off(&hi->ops[3], 3);
					sprintf(hi->mnem, "if (P%d) R%d:R%d = memd (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3c00000) {
					// Instruction: 4: 01000011110sssssPP0ttiiiiiiddddd | if (Pt.new) Rdd = memd (Rs + #u6:3)
					hi->instruction = HEX_INS_IF__PT_NEW__RDD___MEMD__RS____U6_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 3; // scaled
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend_off(&hi->ops[3], 3);
					sprintf(hi->mnem, "if (P%d.new) R%d:R%d = memd (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5c00000) {
					// Instruction: 4: 01000101110sssssPP0ttiiiiiiddddd | if !Pt Rdd = memd (Rs + #u6:3)
					hi->instruction = HEX_INS_IF__NOT_PT_RDD___MEMD__RS____U6_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 3; // scaled
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend_off(&hi->ops[3], 3);
					sprintf(hi->mnem, "if !P%d R%d:R%d = memd (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7c00000) {
					// Instruction: 4: 01000111110sssssPP0ttiiiiiiddddd | if !Pt.new Rdd = memd (Rs + #u6:3)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RDD___MEMD__RS____U6_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 3; // scaled
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend_off(&hi->ops[3], 3);
					sprintf(hi->mnem, "if !P%d.new R%d:R%d = memd (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x9000000) {
					// Instruction: 4: 01001ii1000iiiiiPPiiiiiiiiiddddd | Rd = memb (gp + #u16:0)
					hi->instruction = HEX_INS_RD___MEMB__GP____U16_0_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (gp + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1000000) {
					// Instruction: 4: 01000001000sssssPP0ttiiiiiiddddd | if (Pt) Rd = memb (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__PT__RD___MEMB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d) R%d = memb (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3000000) {
					// Instruction: 4: 01000011000sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memb (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memb (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5000000) {
					// Instruction: 4: 01000101000sssssPP0ttiiiiiiddddd | if !Pt Rd = memb (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d R%d = memb (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7000000) {
					// Instruction: 4: 01000111000sssssPP0ttiiiiiiddddd | if !Pt.new Rd = memb (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d.new R%d = memb (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x9400000) {
					// Instruction: 4: 01001ii1010iiiiiPPiiiiiiiiiddddd | Rd = memh (gp + #u16:1)
					hi->instruction = HEX_INS_RD___MEMH__GP____U16_1_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (gp + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1400000) {
					// Instruction: 4: 01000001010sssssPP0ttiiiiiiddddd | if (Pt) Rd = memh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__PT__RD___MEMH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if (P%d) R%d = memh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3400000) {
					// Instruction: 4: 01000011010sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if (P%d.new) R%d = memh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5400000) {
					// Instruction: 4: 01000101010sssssPP0ttiiiiiiddddd | if !Pt Rd = memh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if !P%d R%d = memh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7400000) {
					// Instruction: 4: 01000111010sssssPP0ttiiiiiiddddd | if !Pt.new Rd = memh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if !P%d.new R%d = memh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x9200000) {
					// Instruction: 4: 01001ii1001iiiiiPPiiiiiiiiiddddd | Rd = memub (gp + #u16:0)
					hi->instruction = HEX_INS_RD___MEMUB__GP____U16_0_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (gp + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1200000) {
					// Instruction: 4: 01000001001sssssPP0ttiiiiiiddddd | if (Pt) Rd = memub (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d) R%d = memub (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3200000) {
					// Instruction: 4: 01000011001sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memub (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memub (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5200000) {
					// Instruction: 4: 01000101001sssssPP0ttiiiiiiddddd | if !Pt Rd = memub (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d R%d = memub (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7200000) {
					// Instruction: 4: 01000111001sssssPP0ttiiiiiiddddd | if !Pt.new Rd = memub (Rs + #u6:0)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUB__RS____U6_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d.new R%d = memub (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x9600000) {
					// Instruction: 4: 01001ii1011iiiiiPPiiiiiiiiiddddd | Rd = memuh (gp + #u16:1)
					hi->instruction = HEX_INS_RD___MEMUH__GP____U16_1_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (gp + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1600000) {
					// Instruction: 4: 01000001011sssssPP0ttiiiiiiddddd | if (Pt) Rd = memuh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if (P%d) R%d = memuh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3600000) {
					// Instruction: 4: 01000011011sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memuh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if (P%d.new) R%d = memuh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5600000) {
					// Instruction: 4: 01000101011sssssPP0ttiiiiiiddddd | if !Pt Rd = memuh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if !P%d R%d = memuh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7600000) {
					// Instruction: 4: 01000111011sssssPP0ttiiiiiiddddd | if !Pt.new Rd = memuh (Rs + #u6:1)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUH__RS____U6_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 1; // scaled
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend_off(&hi->ops[3], 1);
					sprintf(hi->mnem, "if !P%d.new R%d = memuh (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x9800000) {
					// Instruction: 4: 01001ii1100iiiiiPPiiiiiiiiiddddd | Rd = memw (gp + #u16:2)
					hi->instruction = HEX_INS_RD___MEMW__GP____U16_2_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5)) << 2; // scaled
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "R%d = memw (gp + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x1800000) {
					// Instruction: 4: 01000001100sssssPP0ttiiiiiiddddd | if (Pt) Rd = memw (Rs + #u6:2)
					hi->instruction = HEX_INS_IF__PT__RD___MEMW__RS____U6_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 2; // scaled
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend_off(&hi->ops[3], 2);
					sprintf(hi->mnem, "if (P%d) R%d = memw (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x3800000) {
					// Instruction: 4: 01000011100sssssPP0ttiiiiiiddddd | if (Pt.new) Rd = memw (Rs + #u6:2)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMW__RS____U6_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 2; // scaled
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend_off(&hi->ops[3], 2);
					sprintf(hi->mnem, "if (P%d.new) R%d = memw (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5800000) {
					// Instruction: 4: 01000101100sssssPP0ttiiiiiiddddd | if !Pt Rd = memw (Rs + #u6:2)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMW__RS____U6_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 2; // scaled
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend_off(&hi->ops[3], 2);
					sprintf(hi->mnem, "if !P%d R%d = memw (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x7800000) {
					// Instruction: 4: 01000111100sssssPP0ttiiiiiiddddd | if !Pt.new Rd = memw (Rs + #u6:2)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMW__RS____U6_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x1800) >> 11);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x7e0) >> 5) << 2; // scaled
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend_off(&hi->ops[3], 2);
					sprintf(hi->mnem, "if !P%d.new R%d = memw (R%d + 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e01800) == 0x8a00000) {
					// Instruction: 4: 01001ii0101iiiiiPPi00tttiiiiiiii | memb (gp + #u16:0) = Nt.new
					hi->instruction = HEX_INS_MEMB__GP____U16_0____NT_NEW;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0));
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[0]);
					sprintf(hi->mnem, "memb (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0xa00000) {
					// Instruction: 4: 01000000101sssssPPi00tttiiiii0vv | if (Pv) memb (Rs + #u6:0) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMB__RS____U6_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x2a00000) {
					// Instruction: 4: 01000010101sssssPPi00tttiiiii0vv | if (Pv.new) memb (Rs + #u6:0) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RS____U6_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x4a00000) {
					// Instruction: 4: 01000100101sssssPPi00tttiiiii0vv | if !Pv memb (Rs + #u6:0) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RS____U6_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x6a00000) {
					// Instruction: 4: 01000110101sssssPPi00tttiiiii0vv | if !Pv.new memb (Rs + #u6:0) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RS____U6_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e01800) == 0x8a00800) {
					// Instruction: 4: 01001ii0101iiiiiPPi01tttiiiiiiii | memh (gp + #u16:1) = Nt.new
					hi->instruction = HEX_INS_MEMH__GP____U16_1____NT_NEW;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0xa00800) {
					// Instruction: 4: 01000000101sssssPPi01tttiiiii0vv | if (Pv) memh (Rs + #u6:1) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMH__RS____U6_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x2a00800) {
					// Instruction: 4: 01000010101sssssPPi01tttiiiii0vv | if (Pv.new) memh (Rs + #u6:1) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS____U6_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x4a00800) {
					// Instruction: 4: 01000100101sssssPPi01tttiiiii0vv | if !Pv memh (Rs + #u6:1) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS____U6_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x6a00800) {
					// Instruction: 4: 01000110101sssssPPi01tttiiiii0vv | if !Pv.new memh (Rs + #u6:1) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS____U6_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e01800) == 0x8a01000) {
					// Instruction: 4: 01001ii0101iiiiiPPi10tttiiiiiiii | memw (gp + #u16:2) = Nt.new
					hi->instruction = HEX_INS_MEMW__GP____U16_2____NT_NEW;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0xa01000) {
					// Instruction: 4: 01000000101sssssPPi10tttiiiii0vv | if (Pv) memw (Rs + #u6:2) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMW__RS____U6_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x2a01000) {
					// Instruction: 4: 01000010101sssssPPi10tttiiiii0vv | if (Pv.new) memw (Rs + #u6:2) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RS____U6_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x4a01000) {
					// Instruction: 4: 01000100101sssssPPi10tttiiiii0vv | if !Pv memw (Rs + #u6:2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RS____U6_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01804) == 0x6a01000) {
					// Instruction: 4: 01000110101sssssPPi10tttiiiii0vv | if !Pv.new memw (Rs + #u6:2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RS____U6_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x8c00000) {
					// Instruction: 4: 01001ii0110iiiiiPPitttttiiiiiiii | memd (gp + #u16:3) = Rtt
					hi->instruction = HEX_INS_MEMD__GP____U16_3____RTT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 3; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (gp + 0x%x) = R%d:R%d", hi->ops[0].op.imm, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0xc00000) {
					// Instruction: 4: 01000000110sssssPPitttttiiiii0vv | if (Pv) memd (Rs + #u6:3) = Rtt
					hi->instruction = HEX_INS_IF__PV__MEMD__RS____U6_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 3; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend_off(&hi->ops[2], 3);
					sprintf(hi->mnem, "if (P%d) memd (R%d + 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x2c00000) {
					// Instruction: 4: 01000010110sssssPPitttttiiiii0vv | if (Pv.new) memd (Rs + #u6:3) = Rtt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMD__RS____U6_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 3; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend_off(&hi->ops[2], 3);
					sprintf(hi->mnem, "if (P%d.new) memd (R%d + 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x4c00000) {
					// Instruction: 4: 01000100110sssssPPitttttiiiii0vv | if !Pv memd (Rs + #u6:3) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMD__RS____U6_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 3; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend_off(&hi->ops[2], 3);
					sprintf(hi->mnem, "if !P%d memd (R%d + 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x6c00000) {
					// Instruction: 4: 01000110110sssssPPitttttiiiii0vv | if !Pv.new memd (Rs + #u6:3) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMD__RS____U6_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 3; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend_off(&hi->ops[2], 3);
					sprintf(hi->mnem, "if !P%d.new memd (R%d + 0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x8000000) {
					// Instruction: 4: 01001ii0000iiiiiPPitttttiiiiiiii | memb (gp + #u16:0) = Rt
					hi->instruction = HEX_INS_MEMB__GP____U16_0____RT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0));
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[0]);
					sprintf(hi->mnem, "memb (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x0) {
					// Instruction: 4: 01000000000sssssPPitttttiiiii0vv | if (Pv) memb (Rs + #u6:0) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMB__RS____U6_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x2000000) {
					// Instruction: 4: 01000010000sssssPPitttttiiiii0vv | if (Pv.new) memb (Rs + #u6:0) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RS____U6_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x4000000) {
					// Instruction: 4: 01000100000sssssPPitttttiiiii0vv | if !Pv memb (Rs + #u6:0) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RS____U6_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x6000000) {
					// Instruction: 4: 01000110000sssssPPitttttiiiii0vv | if !Pv.new memb (Rs + #u6:0) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RS____U6_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3));
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new memb (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x8400000) {
					// Instruction: 4: 01001ii0010iiiiiPPitttttiiiiiiii | memh (gp + #u16:1) = Rt
					hi->instruction = HEX_INS_MEMH__GP____U16_1____RT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x8600000) {
					// Instruction: 4: 01001ii0011iiiiiPPitttttiiiiiiii | memh (gp + #u16:1) = Rt.H
					hi->instruction = HEX_INS_MEMH__GP____U16_1____RT_H;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (gp + 0x%x) = R%d.H", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x400000) {
					// Instruction: 4: 01000000010sssssPPitttttiiiii0vv | if (Pv) memh (Rs + #u6:1) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMH__RS____U6_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "if (P%d) memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x600000) {
					// Instruction: 4: 01000000011sssssPPitttttiiiii0vv | if (Pv) memh (Rs + #u6:1) = Rt.H
					hi->instruction = HEX_INS_IF__PV__MEMH__RS____U6_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d + 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x2400000) {
					// Instruction: 4: 01000010010sssssPPitttttiiiii0vv | if (Pv.new) memh (Rs + #u6:1) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS____U6_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x2600000) {
					// Instruction: 4: 01000010011sssssPPitttttiiiii0vv | if (Pv.new) memh (Rs + #u6:1) = Rt.H
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RS____U6_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d + 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x4400000) {
					// Instruction: 4: 01000100010sssssPPitttttiiiii0vv | if !Pv memh (Rs + #u6:1) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS____U6_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "if !P%d memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x4600000) {
					// Instruction: 4: 01000100011sssssPPitttttiiiii0vv | if !Pv memh (Rs + #u6:1) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RS____U6_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d + 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x6400000) {
					// Instruction: 4: 01000110010sssssPPitttttiiiii0vv | if !Pv.new memh (Rs + #u6:1) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS____U6_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "if !P%d.new memh (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x6600000) {
					// Instruction: 4: 01000110011sssssPPitttttiiiii0vv | if !Pv.new memh (Rs + #u6:1) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RS____U6_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 1; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d + 0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x8800000) {
					// Instruction: 4: 01001ii0100iiiiiPPitttttiiiiiiii | memw (gp + #u16:2) = Rt
					hi->instruction = HEX_INS_MEMW__GP____U16_2____RT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x6000000) >> 11) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 2; // scaled
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (gp + 0x%x) = R%d", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x800000) {
					// Instruction: 4: 01000000100sssssPPitttttiiiii0vv | if (Pv) memw (Rs + #u6:2) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMW__RS____U6_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (P%d) memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x2800000) {
					// Instruction: 4: 01000010100sssssPPitttttiiiii0vv | if (Pv.new) memw (Rs + #u6:2) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RS____U6_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if (P%d.new) memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x4800000) {
					// Instruction: 4: 01000100100sssssPPitttttiiiii0vv | if !Pv memw (Rs + #u6:2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RS____U6_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if !P%d memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00004) == 0x6800000) {
					// Instruction: 4: 01000110100sssssPPitttttiiiii0vv | if !Pv.new memw (Rs + #u6:2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RS____U6_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 8) | ((hi_u32 & 0xf8) >> 3)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "if !P%d.new memw (R%d + 0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				break;
			}
			case 0x5: {
				if ((hi_u32 & 0xfe00000) == 0xa00000) {
					// Instruction: 5: 01010000101sssssPP-------------- | callr Rs
					hi->instruction = HEX_INS_CALLR_RS;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "callr R%d", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1000000) {
					// Instruction: 5: 01010001000sssssPP----uu-------- | if (Pu) callr Rs
					hi->instruction = HEX_INS_IF__PU__CALLR_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) callr R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1200000) {
					// Instruction: 5: 01010001001sssssPP----uu-------- | if !Pu callr Rs
					hi->instruction = HEX_INS_IF__NOT_PU_CALLR_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d callr R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2a00000) {
					// Instruction: 5: 01010010101sssssPP-------------- | hintjr (Rs)
					hi->instruction = HEX_INS_HINTJR__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "hintjr (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2800000) {
					// Instruction: 5: 01010010100sssssPP-------------- | jumpr Rs
					hi->instruction = HEX_INS_JUMPR_RS;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "jumpr R%d", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3400000) {
					// Instruction: 5: 01010011010sssssPP-00-uu-------- | if (Pu) jumpr:nt Rs
					hi->instruction = HEX_INS_IF__PU__JUMPR_NT_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) jumpr:nt R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3400800) {
					// Instruction: 5: 01010011010sssssPP-01-uu-------- | if (Pu.new) jumpr:nt Rs
					hi->instruction = HEX_INS_IF__PU_NEW__JUMPR_NT_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) jumpr:nt R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3401000) {
					// Instruction: 5: 01010011010sssssPP-10-uu-------- | if (Pu) jumpr:t Rs
					hi->instruction = HEX_INS_IF__PU__JUMPR_T_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) jumpr:t R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3401800) {
					// Instruction: 5: 01010011010sssssPP-11-uu-------- | if (Pu.new) jumpr:t Rs
					hi->instruction = HEX_INS_IF__PU_NEW__JUMPR_T_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) jumpr:t R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3600000) {
					// Instruction: 5: 01010011011sssssPP-00-uu-------- | if !Pu jumpr:nt Rs
					hi->instruction = HEX_INS_IF__NOT_PU_JUMPR_NT_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d jumpr:nt R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3600800) {
					// Instruction: 5: 01010011011sssssPP-01-uu-------- | if !Pu.new jumpr:nt Rs
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_JUMPR_NT_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new jumpr:nt R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3601000) {
					// Instruction: 5: 01010011011sssssPP-10-uu-------- | if !Pu jumpr:t Rs
					hi->instruction = HEX_INS_IF__NOT_PU_JUMPR_T_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d jumpr:t R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01800) == 0x3601800) {
					// Instruction: 5: 01010011011sssssPP-11-uu-------- | if !Pu.new jumpr:t Rs
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_JUMPR_T_RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new jumpr:t R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xe000001) == 0xa000000) {
					// Instruction: 5: 0101101iiiiiiiiiPPiiiiiiiiiiiii0 | call #r22:2
					hi->instruction = HEX_INS_CALL__R22_2;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1ff0000) >> 3) | ((hi_u32 & 0x3ffe) >> 1)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 23)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 23);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "call 0x%x", addr + (st32) hi->ops[0].op.imm);
					break;
				}
				if ((hi_u32 & 0xf200800) == 0xd000000) {
					// Instruction: 5: 01011101ii0iiiiiPPi-0-uuiiiiiii- | if (Pu) call #r15:2
					hi->instruction = HEX_INS_IF__PU__CALL__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "if (P%d) call 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf200800) == 0xd200000) {
					// Instruction: 5: 01011101ii1iiiiiPPi-0-uuiiiiiii- | if !Pu call #r15:2
					hi->instruction = HEX_INS_IF__NOT_PU_CALL__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "if !P%d call 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xe000000) == 0x8000000) {
					// Instruction: 5: 0101100iiiiiiiiiPPiiiiiiiiiiiii- | jump #r22:2
					hi->instruction = HEX_INS_JUMP__R22_2;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1ff0000) >> 3) | ((hi_u32 & 0x3ffe) >> 1)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 23)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 23);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "jump 0x%x", addr + (st32) hi->ops[0].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc000000) {
					// Instruction: 5: 01011100ii0iiiiiPPi00-uuiiiiiii- | if (Pu) jump:nt #r15:2
					hi->instruction = HEX_INS_IF__PU__JUMP_NT__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) jump:nt 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc001000) {
					// Instruction: 5: 01011100ii0iiiiiPPi10-uuiiiiiii- | if (Pu) jump:t #r15:2
					hi->instruction = HEX_INS_IF__PU__JUMP_T__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) jump:t 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc200000) {
					// Instruction: 5: 01011100ii1iiiiiPPi00-uuiiiiiii- | if !Pu jump:nt #r15:2
					hi->instruction = HEX_INS_IF__NOT_PU_JUMP_NT__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d jump:nt 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc201000) {
					// Instruction: 5: 01011100ii1iiiiiPPi10-uuiiiiiii- | if !Pu jump:t #r15:2
					hi->instruction = HEX_INS_IF__NOT_PU_JUMP_T__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d jump:t 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc000800) {
					// Instruction: 5: 01011100ii0iiiiiPPi01-uuiiiiiii- | if (Pu.new) jump:nt #r15:2
					hi->instruction = HEX_INS_IF__PU_NEW__JUMP_NT__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) jump:nt 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc001800) {
					// Instruction: 5: 01011100ii0iiiiiPPi11-uuiiiiiii- | if (Pu.new) jump:t #r15:2
					hi->instruction = HEX_INS_IF__PU_NEW__JUMP_T__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) jump:t 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc200800) {
					// Instruction: 5: 01011100ii1iiiiiPPi01-uuiiiiiii- | if !Pu.new jump:nt #r15:2
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_JUMP_NT__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new jump:nt 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf201800) == 0xc201800) {
					// Instruction: 5: 01011100ii1iiiiiPPi11-uuiiiiiii- | if !Pu.new jump:t #r15:2
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_JUMP_T__R15_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 9) | ((hi_u32 & 0x1f0000) >> 8) | ((hi_u32 & 0x2000) >> 6) | ((hi_u32 & 0xfe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 16)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 16);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new jump:t 0x%x", hi->ops[0].op.pred, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5a00000) {
					// Instruction: 5: 01010101101sssssPP---------ddddd | Rd = icdatar (Rs)
					hi->instruction = HEX_INS_RD___ICDATAR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = icdatar (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5e00000) {
					// Instruction: 5: 01010101111sssssPP---------ddddd | Rd = ictagr (Rs)
					hi->instruction = HEX_INS_RD___ICTAGR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ictagr (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0x6c00800) {
					// Instruction: 5: 01010110110sssssPP001----------- | icinvidx (Rs)
					hi->instruction = HEX_INS_ICINVIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "icinvidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5c00000) {
					// Instruction: 5: 01010101110sssssPP-ttttt-------- | ictagw (Rs, Rt)
					hi->instruction = HEX_INS_ICTAGW__RS__RT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "ictagw (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0x6c01000) {
					// Instruction: 5: 01010110110-----PP010----------- | ickill
					hi->instruction = HEX_INS_ICKILL;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "ickill");
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x7e00000) {
					// Instruction: 5: 01010111111-----PP00----000----- | rte
					hi->instruction = HEX_INS_RTE;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "rte");
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x7e01000) {
					// Instruction: 5: 01010111111-----PP01----000----- | rteunlock
					hi->instruction = HEX_INS_RTEUNLOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "rteunlock");
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0x6c00000) {
					// Instruction: 5: 01010110110sssssPP000----------- | icinva (Rs)
					hi->instruction = HEX_INS_ICINVA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "icinva (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfff23ff) == 0x7c00002) {
					// Instruction: 5: 0101011111000000PP0---0000000010 | isync
					hi->instruction = HEX_INS_ISYNC;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "isync");
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x4400000) {
					// Instruction: 5: 0101010001------PP-iiiii---iii-- | pause (#u8)
					hi->instruction = HEX_INS_PAUSE___U8_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 5) | ((hi_u32 & 0x1c) >> 2));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "pause (0x%x)", hi->ops[0].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x4000000) {
					// Instruction: 5: 0101010000------PP-iiiii---iii-- | trap0 (#u8)
					hi->instruction = HEX_INS_TRAP0___U8_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 5) | ((hi_u32 & 0x1c) >> 2));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "trap0 (0x%x)", hi->ops[0].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x4800000) {
					// Instruction: 5: 0101010010------PP-iiiii---iii-- | trap1 (#u8)
					hi->instruction = HEX_INS_TRAP1___U8_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 5) | ((hi_u32 & 0x1c) >> 2));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "trap1 (0x%x)", hi->ops[0].op.imm);
					break;
				}
				break;
			}
			case 0x6: {
				if ((hi_u32 & 0xff02090) == 0xb002090) {
					// Instruction: 6: 011010110000--ssPP1---tt1--1--dd | Pd = fastcorner9 (Ps, Pt)
					hi->instruction = HEX_INS_PD___FASTCORNER9__PS__PT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = fastcorner9 (P%d, P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02090) == 0xb102090) {
					// Instruction: 6: 011010110001--ssPP1---tt1--1--dd | Pd = !fastcorner9 (Ps, Pt)
					hi->instruction = HEX_INS_PD____NOT_FASTCORNER9__PS__PT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !fastcorner9 (P%d, P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb800000) {
					// Instruction: 6: 011010111000--ssPP0-----------dd | Pd = any8 (Ps)
					hi->instruction = HEX_INS_PD___ANY8__PS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = any8 (P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xba00000) {
					// Instruction: 6: 011010111010--ssPP0-----------dd | Pd = all8 (Ps)
					hi->instruction = HEX_INS_PD___ALL8__PS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = all8 (P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x0) {
					// Instruction: 6: 01100000000sssssPP-iiiii---ii--- | loop0 (#r7:2, Rs)
					hi->instruction = HEX_INS_LOOP0___R7_2__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "loop0 (0x%x, R%d)", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x200000) {
					// Instruction: 6: 01100000001sssssPP-iiiii---ii--- | loop1 (#r7:2, Rs)
					hi->instruction = HEX_INS_LOOP1___R7_2__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "loop1 (0x%x, R%d)", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9000000) {
					// Instruction: 6: 01101001000IIIIIPP-iiiiiIIIii-II | loop0 (#r7:2, #U10)
					hi->instruction = HEX_INS_LOOP0___R7_2___U10_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 11) | ((hi_u32 & 0xe0) >> 3) | ((hi_u32 & 0x3) >> 0));
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "loop0 (0x%x, 0x%x)", hi->ops[0].op.imm, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9200000) {
					// Instruction: 6: 01101001001IIIIIPP-iiiiiIIIii-II | loop1 (#r7:2, #U10)
					hi->instruction = HEX_INS_LOOP1___R7_2___U10_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 11) | ((hi_u32 & 0xe0) >> 3) | ((hi_u32 & 0x3) >> 0));
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[0], 2);
					sprintf(hi->mnem, "loop1 (0x%x, 0x%x)", hi->ops[0].op.imm, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfff0000) == 0xa490000) {
					// Instruction: 6: 0110101001001001PP-iiiiii--ddddd | Rd = add (pc, #u6)
					hi->instruction = HEX_INS_RD___ADD__PC___U6_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1f80) >> 7);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = add (pc, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa00000) {
					// Instruction: 6: 01100000101sssssPP-iiiii---ii--- | p3 = sp1loop0 (#r7:2, Rs)
					hi->instruction = HEX_INS_P3___SP1LOOP0___R7_2__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp1loop0 (0x%x, R%d)", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xc00000) {
					// Instruction: 6: 01100000110sssssPP-iiiii---ii--- | p3 = sp2loop0 (#r7:2, Rs)
					hi->instruction = HEX_INS_P3___SP2LOOP0___R7_2__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp2loop0 (0x%x, R%d)", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xe00000) {
					// Instruction: 6: 01100000111sssssPP-iiiii---ii--- | p3 = sp3loop0 (#r7:2, Rs)
					hi->instruction = HEX_INS_P3___SP3LOOP0___R7_2__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp3loop0 (0x%x, R%d)", hi->ops[0].op.imm, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9a00000) {
					// Instruction: 6: 01101001101IIIIIPP-iiiiiIIIii-II | p3 = sp1loop0 (#r7:2, #U10)
					hi->instruction = HEX_INS_P3___SP1LOOP0___R7_2___U10_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 11) | ((hi_u32 & 0xe0) >> 3) | ((hi_u32 & 0x3) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp1loop0 (0x%x, 0x%x)", hi->ops[0].op.imm, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9c00000) {
					// Instruction: 6: 01101001110IIIIIPP-iiiiiIIIii-II | p3 = sp2loop0 (#r7:2, #U10)
					hi->instruction = HEX_INS_P3___SP2LOOP0___R7_2___U10_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 11) | ((hi_u32 & 0xe0) >> 3) | ((hi_u32 & 0x3) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp2loop0 (0x%x, 0x%x)", hi->ops[0].op.imm, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x9e00000) {
					// Instruction: 6: 01101001111IIIIIPP-iiiiiIIIii-II | p3 = sp3loop0 (#r7:2, #U10)
					hi->instruction = HEX_INS_P3___SP3LOOP0___R7_2___U10_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32 & 0x1f00) >> 6) | ((hi_u32 & 0x18) >> 3)) << 2; // scaled
					if (hi->ops[0].op.imm & (1 << 8)) {
						hi->ops[0].op.imm |= (0xFFFFFFFF << 8);
					}
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 11) | ((hi_u32 & 0xe0) >> 3) | ((hi_u32 & 0x3) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "p3 = sp3loop0 (0x%x, 0x%x)", hi->ops[0].op.imm, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb000000) {
					// Instruction: 6: 011010110000--ssPP0---tt------dd | Pd = and (Pt, Ps)
					hi->instruction = HEX_INS_PD___AND__PT__PS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb100000) {
					// Instruction: 6: 011010110001--ssPP0---ttuu----dd | Pd = and (Ps, and (Pt, Pu))
					hi->instruction = HEX_INS_PD___AND__PS__AND__PT__PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, and (P%d, P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb200000) {
					// Instruction: 6: 011010110010--ssPP0---tt------dd | Pd = or (Pt, Ps)
					hi->instruction = HEX_INS_PD___OR__PT__PS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb300000) {
					// Instruction: 6: 011010110011--ssPP0---ttuu----dd | Pd = and (Ps, or (Pt, Pu))
					hi->instruction = HEX_INS_PD___AND__PS__OR__PT__PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, or (P%d, P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb400000) {
					// Instruction: 6: 011010110100--ssPP0---tt------dd | Pd = xor (Ps, Pt)
					hi->instruction = HEX_INS_PD___XOR__PS__PT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = xor (P%d, P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb500000) {
					// Instruction: 6: 011010110101--ssPP0---ttuu----dd | Pd = or (Ps, and (Pt, Pu))
					hi->instruction = HEX_INS_PD___OR__PS__AND__PT__PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, and (P%d, P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb600000) {
					// Instruction: 6: 011010110110--ssPP0---tt------dd | Pd = and (Pt, !Ps)
					hi->instruction = HEX_INS_PD___AND__PT___NOT_PS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, !P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb700000) {
					// Instruction: 6: 011010110111--ssPP0---ttuu----dd | Pd = or (Ps, or (Pt, Pu))
					hi->instruction = HEX_INS_PD___OR__PS__OR__PT__PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, or (P%d, P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xb900000) {
					// Instruction: 6: 011010111001--ssPP0---ttuu----dd | Pd = and (Ps, and (Pt, !Pu))
					hi->instruction = HEX_INS_PD___AND__PS__AND__PT___NOT_PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, and (P%d, !P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xbb00000) {
					// Instruction: 6: 011010111011--ssPP0---ttuu----dd | Pd = and (Ps, or (Pt, !Pu))
					hi->instruction = HEX_INS_PD___AND__PS__OR__PT___NOT_PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = and (P%d, or (P%d, !P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xbc00000) {
					// Instruction: 6: 011010111100--ssPP0-----------dd | Pd = not (Ps)
					hi->instruction = HEX_INS_PD___NOT__PS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = not (P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xbd00000) {
					// Instruction: 6: 011010111101--ssPP0---ttuu----dd | Pd = or (Ps, and (Pt, !Pu))
					hi->instruction = HEX_INS_PD___OR__PS__AND__PT___NOT_PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, and (P%d, !P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xbe00000) {
					// Instruction: 6: 011010111110--ssPP0---tt------dd | Pd = or (Pt, !Ps)
					hi->instruction = HEX_INS_PD___OR__PT___NOT_PS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, !P%d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xff02000) == 0xbf00000) {
					// Instruction: 6: 011010111111--ssPP0---ttuu----dd | Pd = or (Ps, or (Pt, !Pu))
					hi->instruction = HEX_INS_PD___OR__PS__OR__PT___NOT_PU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0xc0) >> 6);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = or (P%d, or (P%d, !P%d))", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.pred, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2200000) {
					// Instruction: 6: 01100010001sssssPP---------ddddd | Cd = Rs
					hi->instruction = HEX_INS_CD___RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_CONTROL;
					hi->ops[0].op.cr = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = R%d", hex_get_cntl_reg(hi->ops[0].op.cr), hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3200000) {
					// Instruction: 6: 01100011001sssssPP---------ddddd | Cdd = Rss
					hi->instruction = HEX_INS_CDD___RSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_CONTROL;
					hi->ops[0].op.cr = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%sd = R%d:R%d", hex_get_cntl_reg(hi->ops[0].op.cr), hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8000000) {
					// Instruction: 6: 01101000000sssssPP---------ddddd | Rdd = Css
					hi->instruction = HEX_INS_RDD___CSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_CONTROL;
					hi->ops[1].op.cr = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = %ss", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hex_get_cntl_reg(hi->ops[1].op.cr));
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa000000) {
					// Instruction: 6: 01101010000sssssPP---------ddddd | Rd = Cs
					hi->instruction = HEX_INS_RD___CS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_CONTROL;
					hi->ops[1].op.cr = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = %s", hi->ops[0].op.reg, hex_get_cntl_reg(hi->ops[1].op.cr));
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1000000) {
					// Instruction: 6: 0110000100isssssPPi0iiiiiiiiiii- | if (Rs != #0) jump:nt #r13:2
					hi->instruction = HEX_INS_IF__RS__NOT____0__JUMP_NT__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d != #0) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1001000) {
					// Instruction: 6: 0110000100isssssPPi1iiiiiiiiiii- | if (Rs != #0) jump:t #r13:2
					hi->instruction = HEX_INS_IF__RS__NOT____0__JUMP_T__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d != #0) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1400000) {
					// Instruction: 6: 0110000101isssssPPi0iiiiiiiiiii- | if (Rs> = #0) jump:nt #r13:2
					hi->instruction = HEX_INS_IF__RS_GT_EQ___0__JUMP_NT__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d> = #0) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1401000) {
					// Instruction: 6: 0110000101isssssPPi1iiiiiiiiiii- | if (Rs> = #0) jump:t #r13:2
					hi->instruction = HEX_INS_IF__RS_GT_EQ___0__JUMP_T__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d> = #0) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1800000) {
					// Instruction: 6: 0110000110isssssPPi0iiiiiiiiiii- | if (Rs == #0) jump:nt #r13:2
					hi->instruction = HEX_INS_IF__RS__EQ___0__JUMP_NT__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d == #0) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1801000) {
					// Instruction: 6: 0110000110isssssPPi1iiiiiiiiiii- | if (Rs == #0) jump:t #r13:2
					hi->instruction = HEX_INS_IF__RS__EQ___0__JUMP_T__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d == #0) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1c00000) {
					// Instruction: 6: 0110000111isssssPPi0iiiiiiiiiii- | if (Rs< = #0) jump:nt #r13:2
					hi->instruction = HEX_INS_IF__RS_LT_EQ___0__JUMP_NT__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d< = #0) jump:nt 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc01000) == 0x1c01000) {
					// Instruction: 6: 0110000111isssssPPi1iiiiiiiiiii- | if (Rs< = #0) jump:t #r13:2
					hi->instruction = HEX_INS_IF__RS_LT_EQ___0__JUMP_T__R13_2;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 9) | ((hi_u32 & 0x2000) >> 2) | ((hi_u32 & 0xffe) >> 1)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 14)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 14);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (R%d< = #0) jump:t 0x%x", hi->ops[0].op.reg, addr + (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2000000) {
					// Instruction: 6: 01100010000sssssPP---------ddddd | Gd = Rs
					hi->instruction = HEX_INS_GD___RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Gd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3000000) {
					// Instruction: 6: 01100011000sssssPP---------ddddd | Gdd = Rss
					hi->instruction = HEX_INS_GDD___RSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Gd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%dd = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8200000) {
					// Instruction: 6: 01101000001sssssPP---------ddddd | Rdd = Gss
					hi->instruction = HEX_INS_RDD___GSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Gs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = R%ds", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa200000) {
					// Instruction: 6: 01101010001sssssPP---------ddddd | Rd = Gs
					hi->instruction = HEX_INS_RD___GS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Gs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000060) {
					// Instruction: 6: 01100100000sssssPP------011----- | ciad (Rs)
					hi->instruction = HEX_INS_CIAD__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "ciad (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5000000) {
					// Instruction: 6: 01100101000xxxxxPP-------------- | crswap (Rx, sgp0)
					hi->instruction = HEX_INS_CRSWAP__RX__SGP0_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "crswap (R%d, sgp0)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5200000) {
					// Instruction: 6: 01100101001xxxxxPP-------------- | crswap (Rx, sgp1)
					hi->instruction = HEX_INS_CRSWAP__RX__SGP1_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "crswap (R%d, sgp1)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc0001f) == 0xd800000) {
					// Instruction: 6: 0110110110-xxxxxPP---------00000 | crswap (Rxx, sgp1:0)
					hi->instruction = HEX_INS_CRSWAP__RXX__SGP1_0_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "crswap (R%d:R%d, sgp1:0)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000020) {
					// Instruction: 6: 01100100000sssssPP------001----- | cswi (Rs)
					hi->instruction = HEX_INS_CSWI__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "cswi (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6000000) {
					// Instruction: 6: 01100110000sssssPP---------ddddd | Rd = getimask (Rs)
					hi->instruction = HEX_INS_RD___GETIMASK__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = getimask (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200020) {
					// Instruction: 6: 01101100001-----PP------001----- | tlblock
					hi->instruction = HEX_INS_TLBLOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "tlblock");
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200060) {
					// Instruction: 6: 01101100001-----PP------011----- | k0lock
					hi->instruction = HEX_INS_K0LOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "k0lock");
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200040) {
					// Instruction: 6: 01101100001-----PP------010----- | tlbunlock
					hi->instruction = HEX_INS_TLBUNLOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "tlbunlock");
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200080) {
					// Instruction: 6: 01101100001-----PP------100----- | k0unlock
					hi->instruction = HEX_INS_K0UNLOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "k0unlock");
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6600000) {
					// Instruction: 6: 01100110011sssssPP---------ddddd | Rd = iassignr (Rs)
					hi->instruction = HEX_INS_RD___IASSIGNR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = iassignr (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000040) {
					// Instruction: 6: 01100100000sssssPP------010----- | iassignw (Rs)
					hi->instruction = HEX_INS_IASSIGNW__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "iassignw (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4600040) {
					// Instruction: 6: 01100100011sssssPP------010----- | nmi (Rs)
					hi->instruction = HEX_INS_NMI__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "nmi (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4400020) {
					// Instruction: 6: 01100100010sssssPP------001----- | resume (Rs)
					hi->instruction = HEX_INS_RESUME__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "resume (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4800000) {
					// Instruction: 6: 01100100100sssssPP----tt000----- | setimask (Pt, Rs)
					hi->instruction = HEX_INS_SETIMASK__PT__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "setimask (P%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4800060) {
					// Instruction: 6: 01100100100sssssPP------011----- | siad (Rs)
					hi->instruction = HEX_INS_SIAD__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "siad (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4600020) {
					// Instruction: 6: 01100100011sssssPP------001----- | start (Rs)
					hi->instruction = HEX_INS_START__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "start (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4600000) {
					// Instruction: 6: 01100100011sssssPP------000----- | stop (Rs)
					hi->instruction = HEX_INS_STOP__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "stop (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000000) {
					// Instruction: 6: 01100100000sssssPP------000----- | swi (Rs)
					hi->instruction = HEX_INS_SWI__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "swi (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xc000000) {
					// Instruction: 6: 01101100000sssssPP0ttttt-------- | tlbw (Rss, Rt)
					hi->instruction = HEX_INS_TLBW__RSS__RT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "tlbw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xc400000) {
					// Instruction: 6: 01101100010sssssPP---------ddddd | Rdd = tlbr (Rs)
					hi->instruction = HEX_INS_RDD___TLBR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = tlbr (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xc800000) {
					// Instruction: 6: 01101100100sssssPP---------ddddd | Rd = tlbp (Rs)
					hi->instruction = HEX_INS_RD___TLBP__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = tlbp (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xca00000) {
					// Instruction: 6: 01101100101sssssPP-------------- | tlbinvasid (Rs)
					hi->instruction = HEX_INS_TLBINVASID__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "tlbinvasid (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xcc00000) {
					// Instruction: 6: 01101100110sssssPP0ttttt---ddddd | Rd = ctlbw (Rss, Rt)
					hi->instruction = HEX_INS_RD___CTLBW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ctlbw (R%d:R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xce00000) {
					// Instruction: 6: 01101100111sssssPP---------ddddd | Rd = tlboc (Rss)
					hi->instruction = HEX_INS_RD___TLBOC__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = tlboc (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x7000000) {
					// Instruction: 6: 0110011100-sssssPP--------dddddd | Sd = Rs
					hi->instruction = HEX_INS_SD___RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_SYSTEM;
					hi->ops[0].op.sys = (((hi_u32) & 0x3f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s = R%d", hex_get_sys_reg(hi->ops[0].op.sys), hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0xd000000) {
					// Instruction: 6: 0110110100-sssssPP--------dddddd | Sdd = Rss
					hi->instruction = HEX_INS_SDD___RSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_SYSTEM;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.sys = (((hi_u32) & 0x3f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "%s:%s = R%d:R%d", hex_get_sys_reg(hi->ops[0].op.sys + 1), hex_get_sys_reg(hi->ops[0].op.sys), hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xe800000) {
					// Instruction: 6: 011011101-ssssssPP---------ddddd | Rd = Ss
					hi->instruction = HEX_INS_RD___SS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_SYSTEM;
					hi->ops[1].op.sys = (((hi_u32) & 0x3f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = %s", hi->ops[0].op.reg, hex_get_sys_reg(hi->ops[1].op.sys));
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xf000000) {
					// Instruction: 6: 011011110-ssssssPP---------ddddd | Rdd = Sss
					hi->instruction = HEX_INS_RDD___SSS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_SYSTEM;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.sys = (((hi_u32) & 0x3f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = %s:%s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hex_get_sys_reg(hi->ops[1].op.sys + 1), hex_get_sys_reg(hi->ops[1].op.sys));
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4400000) {
					// Instruction: 6: 01100100010sssssPP------000----- | wait (Rs)
					hi->instruction = HEX_INS_WAIT__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "wait (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200000) {
					// Instruction: 6: 01101100001-----PP------000----- | brkpt
					hi->instruction = HEX_INS_BRKPT;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "brkpt");
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2400000) {
					// Instruction: 6: 01100010010sssssPP-------------- | trace (Rs)
					hi->instruction = HEX_INS_TRACE__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "trace (R%d)", hi->ops[0].op.reg);
					break;
				}
				break;
			}
			case 0x7: {
				if ((hi_u32 & 0xfc00000) == 0x6000000) {
					// Instruction: 7: 0111011000isssssPPiiiiiiiiiddddd | Rd = and (Rs, #s10)
					hi->instruction = HEX_INS_RD___AND__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = and (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x6800000) {
					// Instruction: 7: 0111011010isssssPPiiiiiiiiiddddd | Rd = or (Rs, #s10)
					hi->instruction = HEX_INS_RD___OR__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = or (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0xf000000) {
					// Instruction: 7: 01111111--------PP-------------- | nop
					hi->instruction = HEX_INS_NOP;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "nop");
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x6400000) {
					// Instruction: 7: 0111011001isssssPPiiiiiiiiiddddd | Rd = sub (#s10, Rs)
					hi->instruction = HEX_INS_RD___SUB___S10__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[1].op.imm & (1 << 9)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = sub (%d, R%d)", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xa00000) {
					// Instruction: 7: 01110000101sssssPP0--------ddddd | Rd = sxtb (Rs)
					hi->instruction = HEX_INS_RD___SXTB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sxtb (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xe00000) {
					// Instruction: 7: 01110000111sssssPP0--------ddddd | Rd = sxth (Rs)
					hi->instruction = HEX_INS_RD___SXTH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sxth (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf200000) == 0x1200000) {
					// Instruction: 7: 01110001ii1xxxxxPPiiiiiiiiiiiiii | Rx.L = #u16
					hi->instruction = HEX_INS_RX_L____U16;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 8) | ((hi_u32 & 0x3fff) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d.L = 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf200000) == 0x2200000) {
					// Instruction: 7: 01110010ii1xxxxxPPiiiiiiiiiiiiii | Rx.H = #u16
					hi->instruction = HEX_INS_RX_H____U16;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 8) | ((hi_u32 & 0x3fff) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d.H = 0x%x", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x8000000) {
					// Instruction: 7: 01111000ii-iiiiiPPiiiiiiiiiddddd | Rd = #s16
					hi->instruction = HEX_INS_RD____S16;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xc00000) >> 8) | ((hi_u32 & 0x1f0000) >> 7) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[1].op.imm & (1 << 15)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 15);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = %d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x600000) {
					// Instruction: 7: 01110000011sssssPP0--------ddddd | Rd = Rs
					hi->instruction = HEX_INS_RD___RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xc00000) {
					// Instruction: 7: 01110000110sssssPP0--------ddddd | Rd = zxth (Rs)
					hi->instruction = HEX_INS_RD___ZXTH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = zxth (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602000) == 0x3002000) {
					// Instruction: 7: 01110011-00sssssPP1iiiiiiiiddddd | Rdd = combine (Rs, #s8)
					hi->instruction = HEX_INS_RDD___COMBINE__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d:R%d = combine (R%d, %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602000) == 0x3202000) {
					// Instruction: 7: 01110011-01sssssPP1iiiiiiiiddddd | Rdd = combine (#s8, Rs)
					hi->instruction = HEX_INS_RDD___COMBINE___S8__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[1].op.imm & (1 << 7)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d:R%d = combine (%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xc000000) {
					// Instruction: 7: 011111000IIIIIIIPPIiiiiiiiiddddd | Rdd = combine (#s8, #S8)
					hi->instruction = HEX_INS_RDD___COMBINE___S8___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[1].op.imm & (1 << 7)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x7f0000) >> 15) | ((hi_u32 & 0x2000) >> 13));
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d:R%d = combine (%d, %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xc800000) {
					// Instruction: 7: 011111001--IIIIIPPIiiiiiiiiddddd | Rdd = combine (#s8, #U6)
					hi->instruction = HEX_INS_RDD___COMBINE___S8___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[1].op.imm & (1 << 7)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x2000) >> 13));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d:R%d = combine (%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x3000000) {
					// Instruction: 7: 011100110uusssssPP0iiiiiiiiddddd | Rd = mux (Pu, Rs, #s8)
					hi->instruction = HEX_INS_RD___MUX__PU__RS___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "R%d = mux (P%d, R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x3800000) {
					// Instruction: 7: 011100111uusssssPP0iiiiiiiiddddd | Rd = mux (Pu, #s8, Rs)
					hi->instruction = HEX_INS_RD___MUX__PU___S8__RS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = mux (P%d, %d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.pred, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xe000000) == 0xa000000) {
					// Instruction: 7: 0111101uuIIIIIIIPPIiiiiiiiiddddd | Rd = mux (Pu, #s8, #S8)
					hi->instruction = HEX_INS_RD___MUX__PU___S8___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x1800000) >> 23);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x7f0000) >> 15) | ((hi_u32 & 0x2000) >> 13));
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = mux (P%d, %d, %d)", hi->ops[0].op.reg, hi->ops[1].op.pred, (st32) hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x0) {
					// Instruction: 7: 01110000000sssssPP0--------ddddd | Rd = aslh (Rs)
					hi->instruction = HEX_INS_RD___ASLH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = aslh (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x200000) {
					// Instruction: 7: 01110000001sssssPP0--------ddddd | Rd = asrh (Rs)
					hi->instruction = HEX_INS_RD___ASRH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = asrh (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x4000000) {
					// Instruction: 7: 011101000uusssssPP0iiiiiiiiddddd | if (Pu) Rd = add (Rs, #s8)
					hi->instruction = HEX_INS_IF__PU__RD___ADD__RS___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d) R%d = add (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x4002000) {
					// Instruction: 7: 011101000uusssssPP1iiiiiiiiddddd | if (Pu.new) Rd = add (Rs, #s8)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ADD__RS___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if (P%d.new) R%d = add (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x4800000) {
					// Instruction: 7: 011101001uusssssPP0iiiiiiiiddddd | if !Pu Rd = add (Rs, #s8)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ADD__RS___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d R%d = add (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x4802000) {
					// Instruction: 7: 011101001uusssssPP1iiiiiiiiddddd | if !Pu.new Rd = add (Rs, #s8)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ADD__RS___S8_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[3].op.imm & (1 << 7)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "if !P%d.new R%d = add (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x2000) {
					// Instruction: 7: 01110000000sssssPP1-00uu---ddddd | if (Pu) Rd = aslh (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___ASLH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = aslh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x2400) {
					// Instruction: 7: 01110000000sssssPP1-01uu---ddddd | if (Pu.new) Rd = aslh (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ASLH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = aslh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x2800) {
					// Instruction: 7: 01110000000sssssPP1-10uu---ddddd | if !Pu Rd = aslh (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ASLH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = aslh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x2c00) {
					// Instruction: 7: 01110000000sssssPP1-11uu---ddddd | if !Pu.new Rd = aslh (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ASLH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = aslh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x202000) {
					// Instruction: 7: 01110000001sssssPP1-00uu---ddddd | if (Pu) Rd = asrh (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___ASRH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = asrh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x202400) {
					// Instruction: 7: 01110000001sssssPP1-01uu---ddddd | if (Pu.new) Rd = asrh (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ASRH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = asrh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x202800) {
					// Instruction: 7: 01110000001sssssPP1-10uu---ddddd | if !Pu Rd = asrh (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ASRH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = asrh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x202c00) {
					// Instruction: 7: 01110000001sssssPP1-11uu---ddddd | if !Pu.new Rd = asrh (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ASRH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = asrh (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xa02000) {
					// Instruction: 7: 01110000101sssssPP1-00uu---ddddd | if (Pu) Rd = sxtb (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___SXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = sxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xa02400) {
					// Instruction: 7: 01110000101sssssPP1-01uu---ddddd | if (Pu.new) Rd = sxtb (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___SXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = sxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xa02800) {
					// Instruction: 7: 01110000101sssssPP1-10uu---ddddd | if !Pu Rd = sxtb (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___SXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = sxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xa02c00) {
					// Instruction: 7: 01110000101sssssPP1-11uu---ddddd | if !Pu.new Rd = sxtb (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___SXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = sxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xe02000) {
					// Instruction: 7: 01110000111sssssPP1-00uu---ddddd | if (Pu) Rd = sxth (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___SXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = sxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xe02400) {
					// Instruction: 7: 01110000111sssssPP1-01uu---ddddd | if (Pu.new) Rd = sxth (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___SXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = sxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xe02800) {
					// Instruction: 7: 01110000111sssssPP1-10uu---ddddd | if !Pu Rd = sxth (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___SXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = sxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xe02c00) {
					// Instruction: 7: 01110000111sssssPP1-11uu---ddddd | if !Pu.new Rd = sxth (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___SXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = sxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf902000) == 0xe000000) {
					// Instruction: 7: 011111100uu0iiiiPP0iiiiiiiiddddd | if (Pu) Rd = #s12
					hi->instruction = HEX_INS_IF__PU__RD____S12;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf0000) >> 8) | ((hi_u32 & 0x1fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf902000) == 0xe002000) {
					// Instruction: 7: 011111100uu0iiiiPP1iiiiiiiiddddd | if (Pu.new) Rd = #s12
					hi->instruction = HEX_INS_IF__PU_NEW__RD____S12;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf0000) >> 8) | ((hi_u32 & 0x1fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf902000) == 0xe800000) {
					// Instruction: 7: 011111101uu0iiiiPP0iiiiiiiiddddd | if !Pu Rd = #s12
					hi->instruction = HEX_INS_IF__NOT_PU_RD____S12;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf0000) >> 8) | ((hi_u32 & 0x1fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf902000) == 0xe802000) {
					// Instruction: 7: 011111101uu0iiiiPP1iiiiiiiiddddd | if !Pu.new Rd = #s12
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD____S12;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600000) >> 21);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf0000) >> 8) | ((hi_u32 & 0x1fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = %d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x802000) {
					// Instruction: 7: 01110000100sssssPP1-00uu---ddddd | if (Pu) Rd = zxtb (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___ZXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = zxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x802400) {
					// Instruction: 7: 01110000100sssssPP1-01uu---ddddd | if (Pu.new) Rd = zxtb (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ZXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = zxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x802800) {
					// Instruction: 7: 01110000100sssssPP1-10uu---ddddd | if !Pu Rd = zxtb (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ZXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = zxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0x802c00) {
					// Instruction: 7: 01110000100sssssPP1-11uu---ddddd | if !Pu.new Rd = zxtb (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ZXTB__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = zxtb (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xc02000) {
					// Instruction: 7: 01110000110sssssPP1-00uu---ddddd | if (Pu) Rd = zxth (Rs)
					hi->instruction = HEX_INS_IF__PU__RD___ZXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = zxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xc02400) {
					// Instruction: 7: 01110000110sssssPP1-01uu---ddddd | if (Pu.new) Rd = zxth (Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ZXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = zxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xc02800) {
					// Instruction: 7: 01110000110sssssPP1-10uu---ddddd | if !Pu Rd = zxth (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ZXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = zxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02c00) == 0xc02c00) {
					// Instruction: 7: 01110000110sssssPP1-11uu---ddddd | if !Pu.new Rd = zxth (Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ZXTH__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = zxth (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc0001c) == 0x5000000) {
					// Instruction: 7: 0111010100isssssPPiiiiiiiii000dd | Pd = cmp.eq (Rs, #s10)
					hi->instruction = HEX_INS_PD___CMP_EQ__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmp.eq (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc0001c) == 0x5000010) {
					// Instruction: 7: 0111010100isssssPPiiiiiiiii100dd | Pd = !cmp.eq (Rs, #s10)
					hi->instruction = HEX_INS_PD____NOT_CMP_EQ__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = !cmp.eq (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc0001c) == 0x5400000) {
					// Instruction: 7: 0111010101isssssPPiiiiiiiii000dd | Pd = cmp.gt (Rs, #s10)
					hi->instruction = HEX_INS_PD___CMP_GT__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmp.gt (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc0001c) == 0x5400010) {
					// Instruction: 7: 0111010101isssssPPiiiiiiiii100dd | Pd = !cmp.gt (Rs, #s10)
					hi->instruction = HEX_INS_PD____NOT_CMP_GT__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = !cmp.gt (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe0001c) == 0x5800000) {
					// Instruction: 7: 01110101100sssssPPiiiiiiiii000dd | Pd = cmp.gtu (Rs, #u9)
					hi->instruction = HEX_INS_PD___CMP_GTU__RS___U9_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmp.gtu (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe0001c) == 0x5800010) {
					// Instruction: 7: 01110101100sssssPPiiiiiiiii100dd | Pd = !cmp.gtu (Rs, #u9)
					hi->instruction = HEX_INS_PD____NOT_CMP_GTU__RS___U9_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = !cmp.gtu (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602000) == 0x3402000) {
					// Instruction: 7: 01110011-10sssssPP1iiiiiiiiddddd | Rd = cmp.eq (Rs, #s8)
					hi->instruction = HEX_INS_RD___CMP_EQ__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = cmp.eq (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf602000) == 0x3602000) {
					// Instruction: 7: 01110011-11sssssPP1iiiiiiiiddddd | Rd = !cmp.eq (Rs, #s8)
					hi->instruction = HEX_INS_RD____NOT_CMP_EQ__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = !cmp.eq (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				break;
			}
			case 0x8: {
				if ((hi_u32 & 0xfe000e0) == 0x8000c0) {
					// Instruction: 8: 10000000100sssssPP------110ddddd | Rdd = abs (Rss)
					hi->instruction = HEX_INS_RDD___ABS__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = abs (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc800080) {
					// Instruction: 8: 10001100100sssssPP------100ddddd | Rd = abs (Rs)
					hi->instruction = HEX_INS_RD___ABS__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = abs (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc8000a0) {
					// Instruction: 8: 10001100100sssssPP------101ddddd | Rd = abs (Rs) :sat
					hi->instruction = HEX_INS_RD___ABS__RS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = abs (R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x800080) {
					// Instruction: 8: 10000000100sssssPP------100ddddd | Rdd = not (Rss)
					hi->instruction = HEX_INS_RDD___NOT__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = not (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000a0) {
					// Instruction: 8: 10000000100sssssPP------101ddddd | Rdd = neg (Rss)
					hi->instruction = HEX_INS_RDD___NEG__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = neg (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc8000c0) {
					// Instruction: 8: 10001100100sssssPP------110ddddd | Rd = neg (Rs) :sat
					hi->instruction = HEX_INS_RD___NEG__RS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = neg (R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8c00020) {
					// Instruction: 8: 10001000110sssssPP------001ddddd | Rd = round (Rss) :sat
					hi->instruction = HEX_INS_RD___ROUND__RSS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = round (R%d:R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020c0) == 0xce00000) {
					// Instruction: 8: 10001100111sssssPP0iiiii00-ddddd | Rd = cround (Rs, #u5)
					hi->instruction = HEX_INS_RD___CROUND__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cround (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020c0) == 0xce00080) {
					// Instruction: 8: 10001100111sssssPP0iiiii10-ddddd | Rd = round (Rs, #u5)
					hi->instruction = HEX_INS_RD___ROUND__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = round (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020c0) == 0xce000c0) {
					// Instruction: 8: 10001100111sssssPP0iiiii11-ddddd | Rd = round (Rs, #u5) :sat
					hi->instruction = HEX_INS_RD___ROUND__RS___U5___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = round (R%d, 0x%x) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4400000) {
					// Instruction: 8: 1000010001-sssssPP------00-ddddd | Rdd = sxtw (Rs)
					hi->instruction = HEX_INS_RDD___SXTW__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = sxtw (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x400080) {
					// Instruction: 8: 10000000010sssssPP------100ddddd | Rdd = vabsh (Rss)
					hi->instruction = HEX_INS_RDD___VABSH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsh (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000a0) {
					// Instruction: 8: 10000000010sssssPP------101ddddd | Rdd = vabsh (Rss) :sat
					hi->instruction = HEX_INS_RDD___VABSH__RSS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vabsh (R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000c0) {
					// Instruction: 8: 10000000010sssssPP------110ddddd | Rdd = vabsw (Rss)
					hi->instruction = HEX_INS_RDD___VABSW__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsw (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x4000e0) {
					// Instruction: 8: 10000000010sssssPP------111ddddd | Rdd = vabsw (Rss) :sat
					hi->instruction = HEX_INS_RDD___VABSW__RSS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vabsw (R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8400000) {
					// Instruction: 8: 10001000010sssssPP------000ddddd | Rd = clb (Rss)
					hi->instruction = HEX_INS_RD___CLB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = clb (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8400040) {
					// Instruction: 8: 10001000010sssssPP------010ddddd | Rd = cl0 (Rss)
					hi->instruction = HEX_INS_RD___CL0__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cl0 (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8400080) {
					// Instruction: 8: 10001000010sssssPP------100ddddd | Rd = cl1 (Rss)
					hi->instruction = HEX_INS_RD___CL1__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cl1 (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8600000) {
					// Instruction: 8: 10001000011sssssPP------000ddddd | Rd = normamt (Rss)
					hi->instruction = HEX_INS_RD___NORMAMT__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = normamt (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8600040) {
					// Instruction: 8: 10001000011sssssPPiiiiii010ddddd | Rd = add (clb (Rss), #s6)
					hi->instruction = HEX_INS_RD___ADD__CLB__RSS____S6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (clb (R%d:R%d), %d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc200000) {
					// Instruction: 8: 10001100001sssssPPiiiiii000ddddd | Rd = add (clb (Rs), #s6)
					hi->instruction = HEX_INS_RD___ADD__CLB__RS____S6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (clb (R%d), %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc000080) {
					// Instruction: 8: 10001100000sssssPP------100ddddd | Rd = clb (Rs)
					hi->instruction = HEX_INS_RD___CLB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = clb (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc0000a0) {
					// Instruction: 8: 10001100000sssssPP------101ddddd | Rd = cl0 (Rs)
					hi->instruction = HEX_INS_RD___CL0__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cl0 (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc0000c0) {
					// Instruction: 8: 10001100000sssssPP------110ddddd | Rd = cl1 (Rs)
					hi->instruction = HEX_INS_RD___CL1__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cl1 (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc0000e0) {
					// Instruction: 8: 10001100000sssssPP------111ddddd | Rd = normamt (Rs)
					hi->instruction = HEX_INS_RD___NORMAMT__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = normamt (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8600060) {
					// Instruction: 8: 10001000011sssssPP------011ddddd | Rd = popcount (Rss)
					hi->instruction = HEX_INS_RD___POPCOUNT__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = popcount (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8e00040) {
					// Instruction: 8: 10001000111sssssPP------010ddddd | Rd = ct0 (Rss)
					hi->instruction = HEX_INS_RD___CT0__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ct0 (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8e00080) {
					// Instruction: 8: 10001000111sssssPP------100ddddd | Rd = ct1 (Rss)
					hi->instruction = HEX_INS_RD___CT1__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ct1 (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc400080) {
					// Instruction: 8: 10001100010sssssPP------100ddddd | Rd = ct0 (Rs)
					hi->instruction = HEX_INS_RD___CT0__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ct0 (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc4000a0) {
					// Instruction: 8: 10001100010sssssPP------101ddddd | Rd = ct1 (Rs)
					hi->instruction = HEX_INS_RD___CT1__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = ct1 (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x1000000) {
					// Instruction: 8: 10000001IIIsssssPPiiiiiiIIIddddd | Rdd = extractu (Rss, #u6, #U6)
					hi->instruction = HEX_INS_RDD___EXTRACTU__RSS___U6___U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xe00000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = extractu (R%d:R%d, 0x%x, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0xa000000) {
					// Instruction: 8: 10001010IIIsssssPPiiiiiiIIIddddd | Rdd = extract (Rss, #u6, #U6)
					hi->instruction = HEX_INS_RDD___EXTRACT__RSS___U6___U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xe00000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = extract (R%d:R%d, 0x%x, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0xd000000) {
					// Instruction: 8: 100011010IIsssssPP0iiiiiIIIddddd | Rd = extractu (Rs, #u5, #U5)
					hi->instruction = HEX_INS_RD___EXTRACTU__RS___U5___U5_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x600000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = extractu (R%d, 0x%x, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0xd800000) {
					// Instruction: 8: 100011011IIsssssPP0iiiiiIIIddddd | Rd = extract (Rs, #u5, #U5)
					hi->instruction = HEX_INS_RD___EXTRACT__RS___U5___U5_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x600000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = extract (R%d, 0x%x, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x3000000) {
					// Instruction: 8: 10000011IIIsssssPPiiiiiiIIIxxxxx | Rxx = insert (Rss, #u6, #U6)
					hi->instruction = HEX_INS_RXX___INSERT__RSS___U6___U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xe00000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = insert (R%d:R%d, 0x%x, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0xf000000) {
					// Instruction: 8: 100011110IIsssssPP0iiiiiIIIxxxxx | Rx = insert (Rs, #u5, #U5)
					hi->instruction = HEX_INS_RX___INSERT__RS___U5___U5_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x600000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = insert (R%d, 0x%x, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc00080) {
					// Instruction: 8: 10000000110sssssPP------100ddddd | Rdd = deinterleave (Rss)
					hi->instruction = HEX_INS_RDD___DEINTERLEAVE__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = deinterleave (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc000a0) {
					// Instruction: 8: 10000000110sssssPP------101ddddd | Rdd = interleave (Rss)
					hi->instruction = HEX_INS_RDD___INTERLEAVE__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = interleave (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc000c0) {
					// Instruction: 8: 10000000110sssssPP------110ddddd | Rdd = brev (Rss)
					hi->instruction = HEX_INS_RDD___BREV__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = brev (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc4000c0) {
					// Instruction: 8: 10001100010sssssPP------110ddddd | Rd = brev (Rs)
					hi->instruction = HEX_INS_RD___BREV__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = brev (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xcc00000) {
					// Instruction: 8: 10001100110sssssPP0iiiii000ddddd | Rd = setbit (Rs, #u5)
					hi->instruction = HEX_INS_RD___SETBIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = setbit (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xcc00020) {
					// Instruction: 8: 10001100110sssssPP0iiiii001ddddd | Rd = clrbit (Rs, #u5)
					hi->instruction = HEX_INS_RD___CLRBIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = clrbit (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xcc00040) {
					// Instruction: 8: 10001100110sssssPP0iiiii010ddddd | Rd = togglebit (Rs, #u5)
					hi->instruction = HEX_INS_RD___TOGGLEBIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = togglebit (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8c00080) {
					// Instruction: 8: 10001000110sssssPP0iiiii100ddddd | Rdd = bitsplit (Rs, #u5)
					hi->instruction = HEX_INS_RDD___BITSPLIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = bitsplit (R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x7000000) {
					// Instruction: 8: 1000011100isssssPPIIIIIIiiixxxxx | Rx = tableidxb (Rs, #u4, #S6) :raw
					hi->instruction = HEX_INS_RX___TABLEIDXB__RS___U4___S6___RAW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d = tableidxb (R%d, 0x%x, %d) :raw", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x7400000) {
					// Instruction: 8: 1000011101isssssPPIIIIIIiiixxxxx | Rx = tableidxh (Rs, #u4, #S6) :raw
					hi->instruction = HEX_INS_RX___TABLEIDXH__RS___U4___S6___RAW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d = tableidxh (R%d, 0x%x, %d) :raw", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x7800000) {
					// Instruction: 8: 1000011110isssssPPIIIIIIiiixxxxx | Rx = tableidxw (Rs, #u4, #S6) :raw
					hi->instruction = HEX_INS_RX___TABLEIDXW__RS___U4___S6___RAW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d = tableidxw (R%d, 0x%x, %d) :raw", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x7c00000) {
					// Instruction: 8: 1000011111isssssPPIIIIIIiiixxxxx | Rx = tableidxd (Rs, #u4, #S6) :raw
					hi->instruction = HEX_INS_RX___TABLEIDXD__RS___U4___S6___RAW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 18) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x3f00) >> 8);
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d = tableidxd (R%d, 0x%x, %d) :raw", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000e0) {
					// Instruction: 8: 10000000100sssssPP------111ddddd | Rdd = vconj (Rss) :sat
					hi->instruction = HEX_INS_RDD___VCONJ__RSS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vconj (R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5e00000) {
					// Instruction: 8: 10000101111sssssPP0iiiii------dd | Pd = sfclass (Rs, #u5)
					hi->instruction = HEX_INS_PD___SFCLASS__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = sfclass (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x4800000) {
					// Instruction: 8: 100001001--sssssPP------000ddddd | Rdd = convert_sf2df (Rs)
					hi->instruction = HEX_INS_RDD___CONVERT_SF2DF__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_sf2df (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000020) {
					// Instruction: 8: 10001000000sssssPP------001ddddd | Rd = convert_df2sf (Rss)
					hi->instruction = HEX_INS_RD___CONVERT_DF2SF__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_df2sf (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe00040) {
					// Instruction: 8: 10000000111sssssPP0-----010ddddd | Rdd = convert_ud2df (Rss)
					hi->instruction = HEX_INS_RDD___CONVERT_UD2DF__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_ud2df (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe00060) {
					// Instruction: 8: 10000000111sssssPP0-----011ddddd | Rdd = convert_d2df (Rss)
					hi->instruction = HEX_INS_RDD___CONVERT_D2DF__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_d2df (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x4800020) {
					// Instruction: 8: 100001001--sssssPP------001ddddd | Rdd = convert_uw2df (Rs)
					hi->instruction = HEX_INS_RDD___CONVERT_UW2DF__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_uw2df (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x4800040) {
					// Instruction: 8: 100001001--sssssPP------010ddddd | Rdd = convert_w2df (Rs)
					hi->instruction = HEX_INS_RDD___CONVERT_W2DF__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_w2df (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8200020) {
					// Instruction: 8: 10001000001sssssPP------001ddddd | Rd = convert_ud2sf (Rss)
					hi->instruction = HEX_INS_RD___CONVERT_UD2SF__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_ud2sf (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8400020) {
					// Instruction: 8: 10001000010sssssPP------001ddddd | Rd = convert_d2sf (Rss)
					hi->instruction = HEX_INS_RD___CONVERT_D2SF__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_d2sf (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb200000) {
					// Instruction: 8: 10001011001sssssPP------000ddddd | Rd = convert_uw2sf (Rs)
					hi->instruction = HEX_INS_RD___CONVERT_UW2SF__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_uw2sf (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb400000) {
					// Instruction: 8: 10001011010sssssPP------000ddddd | Rd = convert_w2sf (Rs)
					hi->instruction = HEX_INS_RD___CONVERT_W2SF__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_w2sf (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe00000) {
					// Instruction: 8: 10000000111sssssPP0-----000ddddd | Rdd = convert_df2d (Rss)
					hi->instruction = HEX_INS_RDD___CONVERT_DF2D__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_df2d (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe00020) {
					// Instruction: 8: 10000000111sssssPP0-----001ddddd | Rdd = convert_df2ud (Rss)
					hi->instruction = HEX_INS_RDD___CONVERT_DF2UD__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_df2ud (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe000c0) {
					// Instruction: 8: 10000000111sssssPP0-----110ddddd | Rdd = convert_df2d (Rss) :chop
					hi->instruction = HEX_INS_RDD___CONVERT_DF2D__RSS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d:R%d = convert_df2d (R%d:R%d) :chop", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xe000e0) {
					// Instruction: 8: 10000000111sssssPP0-----111ddddd | Rdd = convert_df2ud (Rss) :chop
					hi->instruction = HEX_INS_RDD___CONVERT_DF2UD__RSS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d:R%d = convert_df2ud (R%d:R%d) :chop", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x4800060) {
					// Instruction: 8: 100001001--sssssPP------011ddddd | Rdd = convert_sf2ud (Rs)
					hi->instruction = HEX_INS_RDD___CONVERT_SF2UD__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_sf2ud (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x4800080) {
					// Instruction: 8: 100001001--sssssPP------100ddddd | Rdd = convert_sf2d (Rs)
					hi->instruction = HEX_INS_RDD___CONVERT_SF2D__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_sf2d (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x48000a0) {
					// Instruction: 8: 100001001--sssssPP------101ddddd | Rdd = convert_sf2ud (Rs) :ch
					hi->instruction = HEX_INS_RDD___CONVERT_SF2UD__RS___CH;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = convert_sf2ud (R%d) :ch", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8000e0) == 0x48000c0) {
					// Instruction: 8: 100001001--sssssPP------110ddddd | Rdd = convert_sf2d (Rs) :chop
					hi->instruction = HEX_INS_RDD___CONVERT_SF2D__RS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d:R%d = convert_sf2d (R%d) :chop", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8600020) {
					// Instruction: 8: 10001000011sssssPP------001ddddd | Rd = convert_df2uw (Rss)
					hi->instruction = HEX_INS_RD___CONVERT_DF2UW__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_df2uw (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8800020) {
					// Instruction: 8: 10001000100sssssPP------001ddddd | Rd = convert_df2w (Rss)
					hi->instruction = HEX_INS_RD___CONVERT_DF2W__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_df2w (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8a00020) {
					// Instruction: 8: 10001000101sssssPP------001ddddd | Rd = convert_df2uw (Rss) :chop
					hi->instruction = HEX_INS_RD___CONVERT_DF2UW__RSS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d = convert_df2uw (R%d:R%d) :chop", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8e00020) {
					// Instruction: 8: 10001000111sssssPP------001ddddd | Rd = convert_df2w (Rss) :chop
					hi->instruction = HEX_INS_RD___CONVERT_DF2W__RSS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d = convert_df2w (R%d:R%d) :chop", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb600000) {
					// Instruction: 8: 10001011011sssssPP------000ddddd | Rd = convert_sf2uw (Rs)
					hi->instruction = HEX_INS_RD___CONVERT_SF2UW__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_sf2uw (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb600020) {
					// Instruction: 8: 10001011011sssssPP------001ddddd | Rd = convert_sf2uw (Rs) :chop
					hi->instruction = HEX_INS_RD___CONVERT_SF2UW__RS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d = convert_sf2uw (R%d) :chop", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb800000) {
					// Instruction: 8: 10001011100sssssPP------000ddddd | Rd = convert_sf2w (Rs)
					hi->instruction = HEX_INS_RD___CONVERT_SF2W__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = convert_sf2w (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xb800020) {
					// Instruction: 8: 10001011100sssssPP------001ddddd | Rd = convert_sf2w (Rs) :chop
					hi->instruction = HEX_INS_RD___CONVERT_SF2W__RS___CHOP;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CHOP; // :chop
					sprintf(hi->mnem, "R%d = convert_sf2w (R%d) :chop", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xba00000) {
					// Instruction: 8: 10001011101sssssPP------000ddddd | Rd = sffixupr (Rs)
					hi->instruction = HEX_INS_RD___SFFIXUPR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sffixupr (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xbe00000) {
					// Instruction: 8: 10001011111sssssPP------0eeddddd | Rd, Pe = sfinvsqrta (Rs)
					hi->instruction = HEX_INS_RD__PE___SFINVSQRTA__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d, P%d = sfinvsqrta (R%d)", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8c00000) {
					// Instruction: 8: 10001000110sssssPP------000ddddd | Rd = sat (Rss)
					hi->instruction = HEX_INS_RD___SAT__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sat (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xcc00080) {
					// Instruction: 8: 10001100110sssssPP------100ddddd | Rd = sath (Rs)
					hi->instruction = HEX_INS_RD___SATH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sath (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xcc000a0) {
					// Instruction: 8: 10001100110sssssPP------101ddddd | Rd = satuh (Rs)
					hi->instruction = HEX_INS_RD___SATUH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = satuh (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xcc000c0) {
					// Instruction: 8: 10001100110sssssPP------110ddddd | Rd = satub (Rs)
					hi->instruction = HEX_INS_RD___SATUB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = satub (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xcc000e0) {
					// Instruction: 8: 10001100110sssssPP------111ddddd | Rd = satb (Rs)
					hi->instruction = HEX_INS_RD___SATB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = satb (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc8000e0) {
					// Instruction: 8: 10001100100sssssPP------111ddddd | Rd = swiz (Rs)
					hi->instruction = HEX_INS_RD___SWIZ__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = swiz (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8800080) {
					// Instruction: 8: 10001000100sssssPP------100ddddd | Rd = vrndwh (Rss)
					hi->instruction = HEX_INS_RD___VRNDWH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vrndwh (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x88000c0) {
					// Instruction: 8: 10001000100sssssPP------110ddddd | Rd = vrndwh (Rss) :sat
					hi->instruction = HEX_INS_RD___VRNDWH__RSS___SAT;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vrndwh (R%d:R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000000) {
					// Instruction: 8: 10001000000sssssPP------000ddddd | Rd = vsathub (Rss)
					hi->instruction = HEX_INS_RD___VSATHUB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsathub (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000040) {
					// Instruction: 8: 10001000000sssssPP------010ddddd | Rd = vsatwh (Rss)
					hi->instruction = HEX_INS_RD___VSATWH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsatwh (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8000080) {
					// Instruction: 8: 10001000000sssssPP------100ddddd | Rd = vsatwuh (Rss)
					hi->instruction = HEX_INS_RD___VSATWUH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsatwuh (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x80000c0) {
					// Instruction: 8: 10001000000sssssPP------110ddddd | Rd = vsathb (Rss)
					hi->instruction = HEX_INS_RD___VSATHB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsathb (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc800000) {
					// Instruction: 8: 1000110010-sssssPP------00-ddddd | Rd = vsathb (Rs)
					hi->instruction = HEX_INS_RD___VSATHB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsathb (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc800040) {
					// Instruction: 8: 1000110010-sssssPP------01-ddddd | Rd = vsathub (Rs)
					hi->instruction = HEX_INS_RD___VSATHUB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsathub (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x80) {
					// Instruction: 8: 10000000000sssssPP------100ddddd | Rdd = vsathub (Rss)
					hi->instruction = HEX_INS_RDD___VSATHUB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsathub (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xa0) {
					// Instruction: 8: 10000000000sssssPP------101ddddd | Rdd = vsatwuh (Rss)
					hi->instruction = HEX_INS_RDD___VSATWUH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsatwuh (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc0) {
					// Instruction: 8: 10000000000sssssPP------110ddddd | Rdd = vsatwh (Rss)
					hi->instruction = HEX_INS_RDD___VSATWH__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsatwh (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xe0) {
					// Instruction: 8: 10000000000sssssPP------111ddddd | Rdd = vsathb (Rss)
					hi->instruction = HEX_INS_RDD___VSATHB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsathb (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4400080) {
					// Instruction: 8: 1000010001-sssssPP------10-ddddd | Rdd = vsplatb (Rs)
					hi->instruction = HEX_INS_RDD___VSPLATB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsplatb (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc4000e0) {
					// Instruction: 8: 10001100010sssssPP------111ddddd | Rd = vsplatb (Rs)
					hi->instruction = HEX_INS_RD___VSPLATB__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsplatb (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4400040) {
					// Instruction: 8: 1000010001-sssssPP------01-ddddd | Rdd = vsplath (Rs)
					hi->instruction = HEX_INS_RDD___VSPLATH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsplath (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4000000) {
					// Instruction: 8: 1000010000-sssssPP------00-ddddd | Rdd = vsxtbh (Rs)
					hi->instruction = HEX_INS_RDD___VSXTBH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsxtbh (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4000080) {
					// Instruction: 8: 1000010000-sssssPP------10-ddddd | Rdd = vsxthw (Rs)
					hi->instruction = HEX_INS_RDD___VSXTHW__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsxthw (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8800000) {
					// Instruction: 8: 10001000100sssssPP------000ddddd | Rd = vtrunohb (Rss)
					hi->instruction = HEX_INS_RD___VTRUNOHB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vtrunohb (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x8800040) {
					// Instruction: 8: 10001000100sssssPP------010ddddd | Rd = vtrunehb (Rss)
					hi->instruction = HEX_INS_RD___VTRUNEHB__RSS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vtrunehb (R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x4000040) {
					// Instruction: 8: 1000010000-sssssPP------01-ddddd | Rdd = vzxtbh (Rs)
					hi->instruction = HEX_INS_RDD___VZXTBH__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vzxtbh (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x40000c0) {
					// Instruction: 8: 1000010000-sssssPP------11-ddddd | Rdd = vzxthw (Rs)
					hi->instruction = HEX_INS_RDD___VZXTHW__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vzxthw (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5800000) {
					// Instruction: 8: 10000101100sssssPPiiiiii------dd | Pd = bitsclr (Rs, #u6)
					hi->instruction = HEX_INS_PD___BITSCLR__RS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = bitsclr (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5a00000) {
					// Instruction: 8: 10000101101sssssPPiiiiii------dd | Pd = !bitsclr (Rs, #u6)
					hi->instruction = HEX_INS_PD____NOT_BITSCLR__RS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !bitsclr (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x6000000) {
					// Instruction: 8: 10000110--------PP----tt---ddddd | Rdd = mask (Pt)
					hi->instruction = HEX_INS_RDD___MASK__PT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mask (P%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5400000) {
					// Instruction: 8: 10000101010sssssPP------------dd | Pd = Rs
					hi->instruction = HEX_INS_PD___RS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xf400000) == 0x9400000) {
					// Instruction: 8: 10001001-1----ssPP---------ddddd | Rd = Ps
					hi->instruction = HEX_INS_RD___PS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = P%d", hi->ops[0].op.reg, hi->ops[1].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5000000) {
					// Instruction: 8: 10000101000sssssPP0iiiii------dd | Pd = tstbit (Rs, #u5)
					hi->instruction = HEX_INS_PD___TSTBIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = tstbit (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x5200000) {
					// Instruction: 8: 10000101001sssssPP0iiiii------dd | Pd = !tstbit (Rs, #u5)
					hi->instruction = HEX_INS_PD____NOT_TSTBIT__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !tstbit (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf600000) == 0x9000000) {
					// Instruction: 8: 10001001-00---ssPP----tt---ddddd | Rd = vitpack (Ps, Pt)
					hi->instruction = HEX_INS_RD___VITPACK__PS__PT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x30000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[2].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vitpack (P%d, P%d)", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x0) {
					// Instruction: 8: 10000000000sssssPPiiiiii000ddddd | Rdd = asr (Rss, #u6)
					hi->instruction = HEX_INS_RDD___ASR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = asr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x20) {
					// Instruction: 8: 10000000000sssssPPiiiiii001ddddd | Rdd = lsr (Rss, #u6)
					hi->instruction = HEX_INS_RDD___LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x40) {
					// Instruction: 8: 10000000000sssssPPiiiiii010ddddd | Rdd = asl (Rss, #u6)
					hi->instruction = HEX_INS_RDD___ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x60) {
					// Instruction: 8: 10000000000sssssPPiiiiii011ddddd | Rdd = rol (Rss, #u6)
					hi->instruction = HEX_INS_RDD___ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc000000) {
					// Instruction: 8: 10001100000sssssPP0iiiii000ddddd | Rd = asr (Rs, #u5)
					hi->instruction = HEX_INS_RD___ASR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = asr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc000020) {
					// Instruction: 8: 10001100000sssssPP0iiiii001ddddd | Rd = lsr (Rs, #u5)
					hi->instruction = HEX_INS_RD___LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc000040) {
					// Instruction: 8: 10001100000sssssPP0iiiii010ddddd | Rd = asl (Rs, #u5)
					hi->instruction = HEX_INS_RD___ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc000060) {
					// Instruction: 8: 10001100000sssssPP0iiiii011ddddd | Rd = rol (Rs, #u5)
					hi->instruction = HEX_INS_RD___ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2000000) {
					// Instruction: 8: 1000001000-sssssPPiiiiii000xxxxx | Rxx -= asr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__ASR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= asr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2000020) {
					// Instruction: 8: 1000001000-sssssPPiiiiii001xxxxx | Rxx -= lsr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2000040) {
					// Instruction: 8: 1000001000-sssssPPiiiiii010xxxxx | Rxx -= asl (Rss, #u6)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2000060) {
					// Instruction: 8: 1000001000-sssssPPiiiiii011xxxxx | Rxx -= rol (Rss, #u6)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2000080) {
					// Instruction: 8: 1000001000-sssssPPiiiiii100xxxxx | Rxx += asr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__ASR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += asr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x20000a0) {
					// Instruction: 8: 1000001000-sssssPPiiiiii101xxxxx | Rxx += lsr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x20000c0) {
					// Instruction: 8: 1000001000-sssssPPiiiiii110xxxxx | Rxx += asl (Rss, #u6)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x20000e0) {
					// Instruction: 8: 1000001000-sssssPPiiiiii111xxxxx | Rxx += rol (Rss, #u6)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe000000) {
					// Instruction: 8: 1000111000-sssssPP0iiiii000xxxxx | Rx -= asr (Rs, #u5)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ASR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= asr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe000020) {
					// Instruction: 8: 1000111000-sssssPP0iiiii001xxxxx | Rx -= lsr (Rs, #u5)
					hi->instruction = HEX_INS_RX__MINUS_EQ__LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe000040) {
					// Instruction: 8: 1000111000-sssssPP0iiiii010xxxxx | Rx -= asl (Rs, #u5)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe000060) {
					// Instruction: 8: 1000111000-sssssPP0iiiii011xxxxx | Rx -= rol (Rs, #u5)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe000080) {
					// Instruction: 8: 1000111000-sssssPP0iiiii100xxxxx | Rx += asr (Rs, #u5)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ASR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += asr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe0000a0) {
					// Instruction: 8: 1000111000-sssssPP0iiiii101xxxxx | Rx += lsr (Rs, #u5)
					hi->instruction = HEX_INS_RX__PLUS_EQ__LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe0000c0) {
					// Instruction: 8: 1000111000-sssssPP0iiiii110xxxxx | Rx += asl (Rs, #u5)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe0000e0) {
					// Instruction: 8: 1000111000-sssssPP0iiiii111xxxxx | Rx += rol (Rs, #u5)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2400000) {
					// Instruction: 8: 1000001001-sssssPPiiiiii000xxxxx | Rxx &= asr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__AND_EQ__ASR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= asr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2400020) {
					// Instruction: 8: 1000001001-sssssPPiiiiii001xxxxx | Rxx &= lsr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__AND_EQ__LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2400040) {
					// Instruction: 8: 1000001001-sssssPPiiiiii010xxxxx | Rxx &= asl (Rss, #u6)
					hi->instruction = HEX_INS_RXX__AND_EQ__ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2400060) {
					// Instruction: 8: 1000001001-sssssPPiiiiii011xxxxx | Rxx &= rol (Rss, #u6)
					hi->instruction = HEX_INS_RXX__AND_EQ__ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2400080) {
					// Instruction: 8: 1000001001-sssssPPiiiiii100xxxxx | Rxx |= asr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__OR_EQ__ASR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= asr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x24000a0) {
					// Instruction: 8: 1000001001-sssssPPiiiiii101xxxxx | Rxx |= lsr (Rss, #u6)
					hi->instruction = HEX_INS_RXX__OR_EQ__LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x24000c0) {
					// Instruction: 8: 1000001001-sssssPPiiiiii110xxxxx | Rxx |= asl (Rss, #u6)
					hi->instruction = HEX_INS_RXX__OR_EQ__ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x24000e0) {
					// Instruction: 8: 1000001001-sssssPPiiiiii111xxxxx | Rxx |= rol (Rss, #u6)
					hi->instruction = HEX_INS_RXX__OR_EQ__ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2800020) {
					// Instruction: 8: 1000001010-sssssPPiiiiii001xxxxx | Rxx ^= lsr (Rss, #u6)
					hi->instruction = HEX_INS_RXX____LSR__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= lsr (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2800040) {
					// Instruction: 8: 1000001010-sssssPPiiiiii010xxxxx | Rxx ^= asl (Rss, #u6)
					hi->instruction = HEX_INS_RXX____ASL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= asl (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x2800060) {
					// Instruction: 8: 1000001010-sssssPPiiiiii011xxxxx | Rxx ^= rol (Rss, #u6)
					hi->instruction = HEX_INS_RXX____ROL__RSS___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= rol (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe400000) {
					// Instruction: 8: 1000111001-sssssPP0iiiii000xxxxx | Rx &= asr (Rs, #u5)
					hi->instruction = HEX_INS_RX__AND_EQ__ASR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= asr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe400020) {
					// Instruction: 8: 1000111001-sssssPP0iiiii001xxxxx | Rx &= lsr (Rs, #u5)
					hi->instruction = HEX_INS_RX__AND_EQ__LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe400040) {
					// Instruction: 8: 1000111001-sssssPP0iiiii010xxxxx | Rx &= asl (Rs, #u5)
					hi->instruction = HEX_INS_RX__AND_EQ__ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe400060) {
					// Instruction: 8: 1000111001-sssssPP0iiiii011xxxxx | Rx &= rol (Rs, #u5)
					hi->instruction = HEX_INS_RX__AND_EQ__ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe400080) {
					// Instruction: 8: 1000111001-sssssPP0iiiii100xxxxx | Rx |= asr (Rs, #u5)
					hi->instruction = HEX_INS_RX__OR_EQ__ASR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= asr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe4000a0) {
					// Instruction: 8: 1000111001-sssssPP0iiiii101xxxxx | Rx |= lsr (Rs, #u5)
					hi->instruction = HEX_INS_RX__OR_EQ__LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe4000c0) {
					// Instruction: 8: 1000111001-sssssPP0iiiii110xxxxx | Rx |= asl (Rs, #u5)
					hi->instruction = HEX_INS_RX__OR_EQ__ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe4000e0) {
					// Instruction: 8: 1000111001-sssssPP0iiiii111xxxxx | Rx |= rol (Rs, #u5)
					hi->instruction = HEX_INS_RX__OR_EQ__ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe800020) {
					// Instruction: 8: 1000111010-sssssPP0iiiii001xxxxx | Rx ^= lsr (Rs, #u5)
					hi->instruction = HEX_INS_RX____LSR__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= lsr (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe800040) {
					// Instruction: 8: 1000111010-sssssPP0iiiii010xxxxx | Rx ^= asl (Rs, #u5)
					hi->instruction = HEX_INS_RX____ASL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= asl (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xe800060) {
					// Instruction: 8: 1000111010-sssssPP0iiiii011xxxxx | Rx ^= rol (Rs, #u5)
					hi->instruction = HEX_INS_RX____ROL__RS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= rol (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0xc000e0) {
					// Instruction: 8: 10000000110sssssPPiiiiii111ddddd | Rdd = asr (Rss, #u6) :rnd
					hi->instruction = HEX_INS_RDD___ASR__RSS___U6___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = asr (R%d:R%d, 0x%x) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc400000) {
					// Instruction: 8: 10001100010sssssPP0iiiii000ddddd | Rd = asr (Rs, #u5) :rnd
					hi->instruction = HEX_INS_RD___ASR__RS___U5___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = asr (R%d, 0x%x) :rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xc400040) {
					// Instruction: 8: 10001100010sssssPP0iiiii010ddddd | Rd = asl (Rs, #u5) :sat
					hi->instruction = HEX_INS_RD___ASL__RS___U5___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = asl (R%d, 0x%x) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x800000) {
					// Instruction: 8: 10000000100sssssPP00iiii000ddddd | Rdd = vasrh (Rss, #u4)
					hi->instruction = HEX_INS_RDD___VASRH__RSS___U4_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vasrh (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x800020) {
					// Instruction: 8: 10000000100sssssPP00iiii001ddddd | Rdd = vlsrh (Rss, #u4)
					hi->instruction = HEX_INS_RDD___VLSRH__RSS___U4_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlsrh (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x800040) {
					// Instruction: 8: 10000000100sssssPP00iiii010ddddd | Rdd = vaslh (Rss, #u4)
					hi->instruction = HEX_INS_RDD___VASLH__RSS___U4_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaslh (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x200000) {
					// Instruction: 8: 10000000001sssssPP00iiii000ddddd | Rdd = vasrh (Rss, #u4) :raw
					hi->instruction = HEX_INS_RDD___VASRH__RSS___U4___RAW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d:R%d = vasrh (R%d:R%d, 0x%x) :raw", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x8600080) {
					// Instruction: 8: 10001000011sssssPP00iiii100ddddd | Rd = vasrhub (Rss, #u4) :raw
					hi->instruction = HEX_INS_RD___VASRHUB__RSS___U4___RAW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d = vasrhub (R%d:R%d, 0x%x) :raw", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe030e0) == 0x86000a0) {
					// Instruction: 8: 10001000011sssssPP00iiii101ddddd | Rd = vasrhub (Rss, #u4) :sat
					hi->instruction = HEX_INS_RD___VASRHUB__RSS___U4___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xf00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vasrhub (R%d:R%d, 0x%x) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x400000) {
					// Instruction: 8: 10000000010sssssPP0iiiii000ddddd | Rdd = vasrw (Rss, #u5)
					hi->instruction = HEX_INS_RDD___VASRW__RSS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vasrw (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x400020) {
					// Instruction: 8: 10000000010sssssPP0iiiii001ddddd | Rdd = vlsrw (Rss, #u5)
					hi->instruction = HEX_INS_RDD___VLSRW__RSS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlsrw (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x400040) {
					// Instruction: 8: 10000000010sssssPP0iiiii010ddddd | Rdd = vaslw (Rss, #u5)
					hi->instruction = HEX_INS_RDD___VASLW__RSS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaslw (R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8c00040) {
					// Instruction: 8: 10001000110sssssPP0iiiii010ddddd | Rd = vasrw (Rss, #u5)
					hi->instruction = HEX_INS_RD___VASRW__RSS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vasrw (R%d:R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				break;
			}
			case 0x9: {
				if ((hi_u32 & 0x9e00000) == 0x1c00000) {
					// Instruction: 9: 10010ii1110sssssPPiiiiiiiiiddddd | Rdd = memd (Rs + #s11:3)
					hi->instruction = HEX_INS_RDD___MEMD__RS____S11_3_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 13)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 13);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 3);
					sprintf(hi->mnem, "R%d:R%d = memd (R%d + %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9c00000) {
					// Instruction: 9: 10011001110xxxxxPPu0--0iiiiddddd | Rdd = memd (Rx ++ #s4:3:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMD__RX_____S4_3_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9c00200) {
					// Instruction: 9: 10011001110xxxxxPPu0--1-0--ddddd | Rdd = memd (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMD__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d ++ I:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xbc01000) {
					// Instruction: 9: 10011011110eeeeePP01IIII-IIddddd | Rdd = memd (Re = #U6)
					hi->instruction = HEX_INS_RDD___MEMD__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d:R%d = memd (R%d = 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xbc00000) {
					// Instruction: 9: 10011011110xxxxxPP00---iiiiddddd | Rdd = memd (Rx ++ #s4:3)
					hi->instruction = HEX_INS_RDD___MEMD__RX_____S4_3_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d ++ %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xdc01000) {
					// Instruction: 9: 10011101110tttttPPi1IIIIiIIddddd | Rdd = memd (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RDD___MEMD__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d:R%d = memd (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xdc00000) {
					// Instruction: 9: 10011101110xxxxxPPu0----0--ddddd | Rdd = memd (Rx ++ Mu)
					hi->instruction = HEX_INS_RDD___MEMD__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d ++ R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xfc00000) {
					// Instruction: 9: 10011111110xxxxxPPu0----0--ddddd | Rdd = memd (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RDD___MEMD__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd (R%d ++ R%d:brev)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xbc02000) {
					// Instruction: 9: 10011011110xxxxxPP100ttiiiiddddd | if (Pt) Rdd = memd (Rx ++ #s4:3)
					hi->instruction = HEX_INS_IF__PT__RDD___MEMD__RX_____S4_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 6)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) R%d:R%d = memd (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xbc02800) {
					// Instruction: 9: 10011011110xxxxxPP101ttiiiiddddd | if !Pt Rdd = memd (Rx ++ #s4:3)
					hi->instruction = HEX_INS_IF__NOT_PT_RDD___MEMD__RX_____S4_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 6)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d:R%d = memd (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xbc03000) {
					// Instruction: 9: 10011011110xxxxxPP110ttiiiiddddd | if (Pt.new) Rdd = memd (Rx ++ #s4:3)
					hi->instruction = HEX_INS_IF__PT_NEW__RDD___MEMD__RX_____S4_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 6)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d:R%d = memd (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xbc03800) {
					// Instruction: 9: 10011011110xxxxxPP111ttiiiiddddd | if !Pt.new Rdd = memd (Rx ++ #s4:3)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RDD___MEMD__RX_____S4_3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 3; // scaled
					if (hi->ops[3].op.imm & (1 << 6)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d:R%d = memd (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xfc02080) {
					// Instruction: 9: 10011111110iiiiiPP100tti1--ddddd | if (Pt) Rdd = memd (#u6)
					hi->instruction = HEX_INS_IF__PT__RDD___MEMD___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d:R%d = memd (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xfc02880) {
					// Instruction: 9: 10011111110iiiiiPP101tti1--ddddd | if !Pt Rdd = memd (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RDD___MEMD___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d:R%d = memd (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xfc03080) {
					// Instruction: 9: 10011111110iiiiiPP110tti1--ddddd | if (Pt.new) Rdd = memd (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RDD___MEMD___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d:R%d = memd (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xfc03880) {
					// Instruction: 9: 10011111110iiiiiPP111tti1--ddddd | if !Pt.new Rdd = memd (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RDD___MEMD___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d:R%d = memd (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1000000) {
					// Instruction: 9: 10010ii1000sssssPPiiiiiiiiiddddd | Rd = memb (Rs + #s11:0)
					hi->instruction = HEX_INS_RD___MEMB__RS____S11_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memb (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9000000) {
					// Instruction: 9: 10011001000xxxxxPPu0--0iiiiddddd | Rd = memb (Rx ++ #s4:0:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMB__RX_____S4_0_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9000200) {
					// Instruction: 9: 10011001000xxxxxPPu0--1-0--ddddd | Rd = memb (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMB__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb001000) {
					// Instruction: 9: 10011011000eeeeePP01IIII-IIddddd | Rd = memb (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMB__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memb (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb000000) {
					// Instruction: 9: 10011011000xxxxxPP00---iiiiddddd | Rd = memb (Rx ++ #s4:0)
					hi->instruction = HEX_INS_RD___MEMB__RX_____S4_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xd001000) {
					// Instruction: 9: 10011101000tttttPPi1IIIIiIIddddd | Rd = memb (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMB__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memb (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xd000000) {
					// Instruction: 9: 10011101000xxxxxPPu0----0--ddddd | Rd = memb (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMB__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xf000000) {
					// Instruction: 9: 10011111000xxxxxPPu0----0--ddddd | Rd = memb (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMB__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memb (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb002000) {
					// Instruction: 9: 10011011000xxxxxPP100ttiiiiddddd | if (Pt) Rd = memb (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__PT__RD___MEMB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) R%d = memb (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb002800) {
					// Instruction: 9: 10011011000xxxxxPP101ttiiiiddddd | if !Pt Rd = memb (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d = memb (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb003000) {
					// Instruction: 9: 10011011000xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memb (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memb (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb003800) {
					// Instruction: 9: 10011011000xxxxxPP111ttiiiiddddd | if !Pt.new Rd = memb (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d = memb (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf002080) {
					// Instruction: 9: 10011111000iiiiiPP100tti1--ddddd | if (Pt) Rd = memb (#u6)
					hi->instruction = HEX_INS_IF__PT__RD___MEMB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = memb (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf002880) {
					// Instruction: 9: 10011111000iiiiiPP101tti1--ddddd | if !Pt Rd = memb (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = memb (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf003080) {
					// Instruction: 9: 10011111000iiiiiPP110tti1--ddddd | if (Pt.new) Rd = memb (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memb (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf003880) {
					// Instruction: 9: 10011111000iiiiiPP111tti1--ddddd | if !Pt.new Rd = memb (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = memb (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x800000) {
					// Instruction: 9: 10010ii0100sssssPPiiiiiiiiiyyyyy | Ryy = memb_fifo (Rs + #s11:0)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RS____S11_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d + %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8800000) {
					// Instruction: 9: 10011000100xxxxxPPu0--0iiiiyyyyy | Ryy = memb_fifo (Rx ++ #s4:0:circ (Mu))
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RX_____S4_0_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8800200) {
					// Instruction: 9: 10011000100xxxxxPPu0--1-0--yyyyy | Ryy = memb_fifo (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d ++ I:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa801000) {
					// Instruction: 9: 10011010100eeeeePP01IIII-IIyyyyy | Ryy = memb_fifo (Re = #U6)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d = 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa800000) {
					// Instruction: 9: 10011010100xxxxxPP00---iiiiyyyyy | Ryy = memb_fifo (Rx ++ #s4:0)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RX_____S4_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d ++ %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xc801000) {
					// Instruction: 9: 10011100100tttttPPi1IIIIiIIyyyyy | Ryy = memb_fifo (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xc800000) {
					// Instruction: 9: 10011100100xxxxxPPu0----0--yyyyy | Ryy = memb_fifo (Rx ++ Mu)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d ++ R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xe800000) {
					// Instruction: 9: 10011110100xxxxxPPu0----0--yyyyy | Ryy = memb_fifo (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RYY___MEMB_FIFO__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memb_fifo (R%d ++ R%d:brev)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x400000) {
					// Instruction: 9: 10010ii0010sssssPPiiiiiiiiiyyyyy | Ryy = memh_fifo (Rs + #s11:1)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RS____S11_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d + %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8400000) {
					// Instruction: 9: 10011000010xxxxxPPu0--0iiiiyyyyy | Ryy = memh_fifo (Rx ++ #s4:1:circ (Mu))
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RX_____S4_1_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8400200) {
					// Instruction: 9: 10011000010xxxxxPPu0--1-0--yyyyy | Ryy = memh_fifo (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d ++ I:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa401000) {
					// Instruction: 9: 10011010010eeeeePP01IIII-IIyyyyy | Ryy = memh_fifo (Re = #U6)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d = 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa400000) {
					// Instruction: 9: 10011010010xxxxxPP00---iiiiyyyyy | Ryy = memh_fifo (Rx ++ #s4:1)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RX_____S4_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d ++ %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xc401000) {
					// Instruction: 9: 10011100010tttttPPi1IIIIiIIyyyyy | Ryy = memh_fifo (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xc400000) {
					// Instruction: 9: 10011100010xxxxxPPu0----0--yyyyy | Ryy = memh_fifo (Rx ++ Mu)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d ++ R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xe400000) {
					// Instruction: 9: 10011110010xxxxxPPu0----0--yyyyy | Ryy = memh_fifo (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RYY___MEMH_FIFO__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memh_fifo (R%d ++ R%d:brev)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1400000) {
					// Instruction: 9: 10010ii1010sssssPPiiiiiiiiiddddd | Rd = memh (Rs + #s11:1)
					hi->instruction = HEX_INS_RD___MEMH__RS____S11_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "R%d = memh (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9400000) {
					// Instruction: 9: 10011001010xxxxxPPu0--0iiiiddddd | Rd = memh (Rx ++ #s4:1:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMH__RX_____S4_1_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9400200) {
					// Instruction: 9: 10011001010xxxxxPPu0--1-0--ddddd | Rd = memh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb401000) {
					// Instruction: 9: 10011011010eeeeePP01IIII-IIddddd | Rd = memh (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memh (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb400000) {
					// Instruction: 9: 10011011010xxxxxPP00---iiiiddddd | Rd = memh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_RD___MEMH__RX_____S4_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xd401000) {
					// Instruction: 9: 10011101010tttttPPi1IIIIiIIddddd | Rd = memh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xd400000) {
					// Instruction: 9: 10011101010xxxxxPPu0----0--ddddd | Rd = memh (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xf400000) {
					// Instruction: 9: 10011111010xxxxxPPu0----0--ddddd | Rd = memh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memh (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb402000) {
					// Instruction: 9: 10011011010xxxxxPP100ttiiiiddddd | if (Pt) Pd = memh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__PT__PD___MEMH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) P%d = memh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.pred, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb402800) {
					// Instruction: 9: 10011011010xxxxxPP101ttiiiiddddd | if !Pt Rd = memh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d = memh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb403000) {
					// Instruction: 9: 10011011010xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb403800) {
					// Instruction: 9: 10011011010xxxxxPP111ttiiiiddddd | if !Pt.new Rd = memh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d = memh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf402080) {
					// Instruction: 9: 10011111010iiiiiPP100tti1--ddddd | if (Pt) Rd = memh (#u6)
					hi->instruction = HEX_INS_IF__PT__RD___MEMH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = memh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf402880) {
					// Instruction: 9: 10011111010iiiiiPP101tti1--ddddd | if !Pt Rd = memh (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = memh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf403080) {
					// Instruction: 9: 10011111010iiiiiPP110tti1--ddddd | if (Pt.new) Rd = memh (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf403880) {
					// Instruction: 9: 10011111010iiiiiPP111tti1--ddddd | if !Pt.new Rd = memh (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = memh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1200000) {
					// Instruction: 9: 10010ii1001sssssPPiiiiiiiiiddddd | Rd = memub (Rs + #s11:0)
					hi->instruction = HEX_INS_RD___MEMUB__RS____S11_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 10)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memub (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9200000) {
					// Instruction: 9: 10011001001xxxxxPPu0--0iiiiddddd | Rd = memub (Rx ++ #s4:0:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUB__RX_____S4_0_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9200200) {
					// Instruction: 9: 10011001001xxxxxPPu0--1-0--ddddd | Rd = memub (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUB__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb201000) {
					// Instruction: 9: 10011011001eeeeePP01IIII-IIddddd | Rd = memub (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMUB__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memub (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb200000) {
					// Instruction: 9: 10011011001xxxxxPP00---iiiiddddd | Rd = memub (Rx ++ #s4:0)
					hi->instruction = HEX_INS_RD___MEMUB__RX_____S4_0_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xd201000) {
					// Instruction: 9: 10011101001tttttPPi1IIIIiIIddddd | Rd = memub (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMUB__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memub (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xd200000) {
					// Instruction: 9: 10011101001xxxxxPPu0----0--ddddd | Rd = memub (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMUB__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xf200000) {
					// Instruction: 9: 10011111001xxxxxPPu0----0--ddddd | Rd = memub (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMUB__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memub (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb202000) {
					// Instruction: 9: 10011011001xxxxxPP100ttiiiiddddd | if (Pt) Rd = memub (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) R%d = memub (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb202800) {
					// Instruction: 9: 10011011001xxxxxPP101ttiiiiddddd | if !Pt Rd = memub (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d = memub (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb203000) {
					// Instruction: 9: 10011011001xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memub (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memub (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb203800) {
					// Instruction: 9: 10011011001xxxxxPP111ttiiiiddddd | if !Pt.new Rd = memub (Rx ++ #s4:0)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUB__RX_____S4_0_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5);
					if (hi->ops[3].op.imm & (1 << 3)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d = memub (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf202080) {
					// Instruction: 9: 10011111001iiiiiPP100tti1--ddddd | if (Pt) Rd = memub (#u6)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = memub (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf202880) {
					// Instruction: 9: 10011111001iiiiiPP101tti1--ddddd | if !Pt Rd = memub (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = memub (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf203080) {
					// Instruction: 9: 10011111001iiiiiPP110tti1--ddddd | if (Pt.new) Rd = memub (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memub (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf203880) {
					// Instruction: 9: 10011111001iiiiiPP111tti1--ddddd | if !Pt.new Rd = memub (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUB___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = memub (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1600000) {
					// Instruction: 9: 10010ii1011sssssPPiiiiiiiiiddddd | Rd = memuh (Rs + #s11:1)
					hi->instruction = HEX_INS_RD___MEMUH__RS____S11_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 1);
					sprintf(hi->mnem, "R%d = memuh (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9600000) {
					// Instruction: 9: 10011001011xxxxxPPu0--0iiiiddddd | Rd = memuh (Rx ++ #s4:1:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUH__RX_____S4_1_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9600200) {
					// Instruction: 9: 10011001011xxxxxPPu0--1-0--ddddd | Rd = memuh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb601000) {
					// Instruction: 9: 10011011011eeeeePP01IIII-IIddddd | Rd = memuh (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMUH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memuh (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb600000) {
					// Instruction: 9: 10011011011xxxxxPP00---iiiiddddd | Rd = memuh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_RD___MEMUH__RX_____S4_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xd601000) {
					// Instruction: 9: 10011101011tttttPPi1IIIIiIIddddd | Rd = memuh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMUH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memuh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xd600000) {
					// Instruction: 9: 10011101011xxxxxPPu0----0--ddddd | Rd = memuh (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMUH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xf600000) {
					// Instruction: 9: 10011111011xxxxxPPu0----0--ddddd | Rd = memuh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMUH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memuh (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb602000) {
					// Instruction: 9: 10011011011xxxxxPP100ttiiiiddddd | if (Pt) Rd = memuh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) R%d = memuh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb602800) {
					// Instruction: 9: 10011011011xxxxxPP101ttiiiiddddd | if !Pt Rd = memuh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d = memuh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb603000) {
					// Instruction: 9: 10011011011xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memuh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memuh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb603800) {
					// Instruction: 9: 10011011011xxxxxPP111ttiiiiddddd | if !Pt.new Rd = memuh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUH__RX_____S4_1_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[3].op.imm & (1 << 4)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d = memuh (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf602080) {
					// Instruction: 9: 10011111011iiiiiPP100tti1--ddddd | if (Pt) Rd = memuh (#u6)
					hi->instruction = HEX_INS_IF__PT__RD___MEMUH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = memuh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf602880) {
					// Instruction: 9: 10011111011iiiiiPP101tti1--ddddd | if !Pt Rd = memuh (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMUH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = memuh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf603080) {
					// Instruction: 9: 10011111011iiiiiPP110tti1--ddddd | if (Pt.new) Rd = memuh (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMUH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memuh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf603880) {
					// Instruction: 9: 10011111011iiiiiPP111tti1--ddddd | if !Pt.new Rd = memuh (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMUH___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = memuh (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1800000) {
					// Instruction: 9: 10010ii1100sssssPPiiiiiiiiiddddd | Rd = memw (Rs + #s11:2)
					hi->instruction = HEX_INS_RD___MEMW__RS____S11_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 12)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 12);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[2], 2);
					sprintf(hi->mnem, "R%d = memw (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x9800000) {
					// Instruction: 9: 10011001100xxxxxPPu0--0iiiiddddd | Rd = memw (Rx ++ #s4:2:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMW__RX_____S4_2_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x9800200) {
					// Instruction: 9: 10011001100xxxxxPPu0--1-0--ddddd | Rd = memw (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMW__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb801000) {
					// Instruction: 9: 10011011100eeeeePP01IIII-IIddddd | Rd = memw (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMW__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memw (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xb800000) {
					// Instruction: 9: 10011011100xxxxxPP00---iiiiddddd | Rd = memw (Rx ++ #s4:2)
					hi->instruction = HEX_INS_RD___MEMW__RX_____S4_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xd801000) {
					// Instruction: 9: 10011101100tttttPPi1IIIIiIIddddd | Rd = memw (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMW__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = memw (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xd800000) {
					// Instruction: 9: 10011101100xxxxxPPu0----0--ddddd | Rd = memw (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMW__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xf800000) {
					// Instruction: 9: 10011111100xxxxxPPu0----0--ddddd | Rd = memw (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMW__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb802000) {
					// Instruction: 9: 10011011100xxxxxPP100ttiiiiddddd | if (Pt) Rd = memw (Rx ++ #s4:2)
					hi->instruction = HEX_INS_IF__PT__RD___MEMW__RX_____S4_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					sprintf(hi->mnem, "if (P%d) R%d = memw (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb802800) {
					// Instruction: 9: 10011011100xxxxxPP101ttiiiiddddd | if !Pt Rd = memw (Rx ++ #s4:2)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMW__RX_____S4_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					sprintf(hi->mnem, "if !P%d R%d = memw (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb803000) {
					// Instruction: 9: 10011011100xxxxxPP110ttiiiiddddd | if (Pt.new) Rd = memw (Rx ++ #s4:2)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMW__RX_____S4_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = memw (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03800) == 0xb803800) {
					// Instruction: 9: 10011011100xxxxxPP111ttiiiiddddd | if !Pt.new Rd = memw (Rx ++ #s4:2)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMW__RX_____S4_2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					sprintf(hi->mnem, "if !P%d.new R%d = memw (R%d ++ %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf802080) {
					// Instruction: 9: 10011111100iiiiiPP100tti1--ddddd | if (Pt) Rd = memw (#u6)
					hi->instruction = HEX_INS_IF__PT__RD___MEMW___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE; // if (Pt)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d) R%d = memw (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf802880) {
					// Instruction: 9: 10011111100iiiiiPP101tti1--ddddd | if !Pt Rd = memw (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_RD___MEMW___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE; // if !Pt
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d R%d = memw (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf803080) {
					// Instruction: 9: 10011111100iiiiiPP110tti1--ddddd | if (Pt.new) Rd = memw (#u6)
					hi->instruction = HEX_INS_IF__PT_NEW__RD___MEMW___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pt.new)
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if (P%d.new) R%d = memw (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xf803880) {
					// Instruction: 9: 10011111100iiiiiPP111tti1--ddddd | if !Pt.new Rd = memw (#u6)
					hi->instruction = HEX_INS_IF__NOT_PT_NEW_RD___MEMW___U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x600) >> 9);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x100) >> 8));
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pt.new
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "if !P%d.new R%d = memw (0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfff201f) == 0x1e001e) {
					// Instruction: 9: 1001000000011110PP0--------11110 | deallocframe
					hi->instruction = HEX_INS_DEALLOCFRAME;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "deallocframe");
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e001e) {
					// Instruction: 9: 1001011000011110PP0000-----11110 | dealloc_return
					hi->instruction = HEX_INS_DEALLOC_RETURN;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dealloc_return");
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e081e) {
					// Instruction: 9: 1001011000011110PP0010ss---11110 | if (Ps.new) dealloc_return:nt
					hi->instruction = HEX_INS_IF__PS_NEW__DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (P%d.new) dealloc_return:nt", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e101e) {
					// Instruction: 9: 1001011000011110PP0100ss---11110 | if (Ps) dealloc_return
					hi->instruction = HEX_INS_IF__PS__DEALLOC_RETURN;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (P%d) dealloc_return", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e181e) {
					// Instruction: 9: 1001011000011110PP0110ss---11110 | if (Ps.new) dealloc_return:t
					hi->instruction = HEX_INS_IF__PS_NEW__DEALLOC_RETURN_T;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if (P%d.new) dealloc_return:t", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e281e) {
					// Instruction: 9: 1001011000011110PP1010ss---11110 | if !Ps.new dealloc_return:nt
					hi->instruction = HEX_INS_IF__NOT_PS_NEW_DEALLOC_RETURN_NT;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if !P%d.new dealloc_return:nt", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e301e) {
					// Instruction: 9: 1001011000011110PP1100ss---11110 | if !Ps dealloc_return
					hi->instruction = HEX_INS_IF__NOT_PS_DEALLOC_RETURN;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if !P%d dealloc_return", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0xfff3c1f) == 0x61e381e) {
					// Instruction: 9: 1001011000011110PP1110ss---11110 | if !Ps.new dealloc_return:t
					hi->instruction = HEX_INS_IF__NOT_PS_NEW_DEALLOC_RETURN_T;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x300) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "if !P%d.new dealloc_return:t", hi->ops[0].op.pred);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x200000) {
					// Instruction: 9: 10010ii0001sssssPPiiiiiiiiiddddd | Rd = membh (Rs + #s11:1)
					hi->instruction = HEX_INS_RD___MEMBH__RS____S11_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x600000) {
					// Instruction: 9: 10010ii0011sssssPPiiiiiiiiiddddd | Rd = memubh (Rs + #s11:1)
					hi->instruction = HEX_INS_RD___MEMUBH__RS____S11_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 11)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d + %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0xa00000) {
					// Instruction: 9: 10010ii0101sssssPPiiiiiiiiiddddd | Rdd = memubh (Rs + #s11:2)
					hi->instruction = HEX_INS_RDD___MEMUBH__RS____S11_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 12)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 12);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d + %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0xe00000) {
					// Instruction: 9: 10010ii0111sssssPPiiiiiiiiiddddd | Rdd = membh (Rs + #s11:2)
					hi->instruction = HEX_INS_RDD___MEMBH__RS____S11_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x3fe0) >> 5)) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 12)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 12);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d + %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8200000) {
					// Instruction: 9: 10011000001xxxxxPPu0--0iiiiddddd | Rd = membh (Rx ++ #s4:1:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMBH__RX_____S4_1_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8200200) {
					// Instruction: 9: 10011000001xxxxxPPu0--1-0--ddddd | Rd = membh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMBH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8600000) {
					// Instruction: 9: 10011000011xxxxxPPu0--0iiiiddddd | Rd = memubh (Rx ++ #s4:1:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUBH__RX_____S4_1_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8600200) {
					// Instruction: 9: 10011000011xxxxxPPu0--1-0--ddddd | Rd = memubh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RD___MEMUBH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8a00000) {
					// Instruction: 9: 10011000101xxxxxPPu0--0iiiiddddd | Rdd = memubh (Rx ++ #s4:2:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMUBH__RX_____S4_2_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8a00200) {
					// Instruction: 9: 10011000101xxxxxPPu0--1-0--ddddd | Rdd = memubh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMUBH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01200) == 0x8e00000) {
					// Instruction: 9: 10011000111xxxxxPPu0--0iiiiddddd | Rdd = membh (Rx ++ #s4:2:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMBH__RX_____S4_2_CIRC__MU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d ++ %d:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01280) == 0x8e00200) {
					// Instruction: 9: 10011000111xxxxxPPu0--1-0--ddddd | Rdd = membh (Rx ++ I:circ (Mu))
					hi->instruction = HEX_INS_RDD___MEMBH__RX____I_CIRC__MU__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d ++ I:circ (R%d))", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa201000) {
					// Instruction: 9: 10011010001eeeeePP01IIII-IIddddd | Rd = membh (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMBH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa200000) {
					// Instruction: 9: 10011010001xxxxxPP00---iiiiddddd | Rd = membh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_RD___MEMBH__RX_____S4_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa601000) {
					// Instruction: 9: 10011010011eeeeePP01IIII-IIddddd | Rd = memubh (Re = #U6)
					hi->instruction = HEX_INS_RD___MEMUBH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d = 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xa600000) {
					// Instruction: 9: 10011010011xxxxxPP00---iiiiddddd | Rd = memubh (Rx ++ #s4:1)
					hi->instruction = HEX_INS_RD___MEMUBH__RX_____S4_1_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d ++ %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xaa01000) {
					// Instruction: 9: 10011010101eeeeePP01IIII-IIddddd | Rdd = memubh (Re = #U6)
					hi->instruction = HEX_INS_RDD___MEMUBH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d = 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xaa00000) {
					// Instruction: 9: 10011010101xxxxxPP00---iiiiddddd | Rdd = memubh (Rx ++ #s4:2)
					hi->instruction = HEX_INS_RDD___MEMUBH__RX_____S4_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d ++ %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xae01000) {
					// Instruction: 9: 10011010111eeeeePP01IIII-IIddddd | Rdd = membh (Re = #U6)
					hi->instruction = HEX_INS_RDD___MEMBH__RE____U6_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d = 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe03000) == 0xae00000) {
					// Instruction: 9: 10011010111xxxxxPP00---iiiiddddd | Rdd = membh (Rx ++ #s4:2)
					hi->instruction = HEX_INS_RDD___MEMBH__RX_____S4_2_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1e0) >> 5) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d ++ %d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xc201000) {
					// Instruction: 9: 10011100001tttttPPi1IIIIiIIddddd | Rd = membh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMBH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xc200000) {
					// Instruction: 9: 10011100001xxxxxPPu0----0--ddddd | Rd = membh (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMBH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xc601000) {
					// Instruction: 9: 10011100011tttttPPi1IIIIiIIddddd | Rd = memubh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RD___MEMUBH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xc600000) {
					// Instruction: 9: 10011100011xxxxxPPu0----0--ddddd | Rd = memubh (Rx ++ Mu)
					hi->instruction = HEX_INS_RD___MEMUBH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d ++ R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xca01000) {
					// Instruction: 9: 10011100101tttttPPi1IIIIiIIddddd | Rdd = memubh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RDD___MEMUBH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xca00000) {
					// Instruction: 9: 10011100101xxxxxPPu0----0--ddddd | Rdd = memubh (Rx ++ Mu)
					hi->instruction = HEX_INS_RDD___MEMUBH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d ++ R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01000) == 0xce01000) {
					// Instruction: 9: 10011100111tttttPPi1IIIIiIIddddd | Rdd = membh (Rt << #u2 + #U6)
					hi->instruction = HEX_INS_RDD___MEMBH__RT_____U2____U6_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rt
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x80) >> 7));
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0xf00) >> 6) | ((hi_u32 & 0x60) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d << 0x%x + 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xce00000) {
					// Instruction: 9: 10011100111xxxxxPPu0----0--ddddd | Rdd = membh (Rx ++ Mu)
					hi->instruction = HEX_INS_RDD___MEMBH__RX____MU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d ++ R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xe200000) {
					// Instruction: 9: 10011110001xxxxxPPu0----0--ddddd | Rd = membh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMBH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = membh (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xe600000) {
					// Instruction: 9: 10011110011xxxxxPPu0----0--ddddd | Rd = memubh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RD___MEMUBH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memubh (R%d ++ R%d:brev)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xea00000) {
					// Instruction: 9: 10011110101xxxxxPPu0----0--ddddd | Rdd = memubh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RDD___MEMUBH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memubh (R%d ++ R%d:brev)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01080) == 0xee00000) {
					// Instruction: 9: 10011110111xxxxxPPu0----0--ddddd | Rdd = membh (Rx ++ Mu:brev)
					hi->instruction = HEX_INS_RDD___MEMBH__RX____MU_BREV_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = membh (R%d ++ R%d:brev)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02020) == 0x2002000) {
					// Instruction: 9: 10010010000sssssPP1ttttt--0ddddd | Rd = memw_phys (Rs, Rt)
					hi->instruction = HEX_INS_RD___MEMW_PHYS__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw_phys (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03020) == 0x2000000) {
					// Instruction: 9: 10010010000sssssPP00------0ddddd | Rd = memw_locked (Rs)
					hi->instruction = HEX_INS_RD___MEMW_LOCKED__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = memw_locked (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03020) == 0x2001000) {
					// Instruction: 9: 10010010000sssssPP01------0ddddd | Rdd = memd_locked (Rs)
					hi->instruction = HEX_INS_RDD___MEMD_LOCKED__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = memd_locked (R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x4000000) {
					// Instruction: 9: 10010100000sssssPP0--iiiiiiiiiii | dcfetch (Rs + #u11:3)
					hi->instruction = HEX_INS_DCFETCH__RS____U11_3_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x7ff) >> 0) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dcfetch (R%d + 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				break;
			}
			case 0xa: {
				if ((hi_u32 & 0x9e01800) == 0x1a00000) {
					// Instruction: 10: 10100ii1101sssssPPi00tttiiiiiiii | memb (Rs + #s11:0) = Nt.new
					hi->instruction = HEX_INS_MEMB__RS____S11_0____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0));
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a00002) {
					// Instruction: 10: 10101001101xxxxxPPu00ttt0-----1- | memb (Rx ++ I:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMB__RX____I_CIRC__MU_____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a00000) {
					// Instruction: 10: 10101001101xxxxxPPu00ttt0iiii-0- | memb (Rx ++ #s4:0:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMB__RX_____S4_0_CIRC__MU_____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[1].op.imm & (1 << 3)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xba00080) {
					// Instruction: 10: 10101011101eeeeePP000ttt1-IIIIII | memb (Re = #U6) = Nt.new
					hi->instruction = HEX_INS_MEMB__RE____U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03882) == 0xba00000) {
					// Instruction: 10: 10101011101xxxxxPP000ttt0iiii-0- | memb (Rx ++ #s4:0) = Nt.new
					hi->instruction = HEX_INS_MEMB__RX_____S4_0____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[1].op.imm & (1 << 3)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda00080) {
					// Instruction: 10: 10101101101uuuuuPPi00ttt1iIIIIII | memb (Ru << #u2 + #U6) = Nt.new
					hi->instruction = HEX_INS_MEMB__RU_____U2____U6____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda00000) {
					// Instruction: 10: 10101101101xxxxxPPu00ttt0------- | memb (Rx ++ Mu) = Nt.new
					hi->instruction = HEX_INS_MEMB__RX____MU____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xfa00000) {
					// Instruction: 10: 10101111101xxxxxPPu00ttt0------- | memb (Rx ++ Mu:brev) = Nt.new
					hi->instruction = HEX_INS_MEMB__RX____MU_BREV____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02000) {
					// Instruction: 10: 10101011101xxxxxPP100ttt0iiii0vv | if (Pv) memb (Rx ++ #s4:0) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMB__RX_____S4_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02004) {
					// Instruction: 10: 10101011101xxxxxPP100ttt0iiii1vv | if !Pv memb (Rx ++ #s4:0) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RX_____S4_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02080) {
					// Instruction: 10: 10101011101xxxxxPP100ttt1iiii0vv | if (Pv.new) memb (Rx ++ #s4:0) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RX_____S4_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02084) {
					// Instruction: 10: 10101011101xxxxxPP100ttt1iiii1vv | if !Pv.new memb (Rx ++ #s4:0) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RX_____S4_0____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa00080) {
					// Instruction: 10: 10101111101---iiPP000ttt1iiii0vv | if (Pv) memb (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMB___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa00084) {
					// Instruction: 10: 10101111101---iiPP000ttt1iiii1vv | if !Pv memb (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa02080) {
					// Instruction: 10: 10101111101---iiPP100ttt1iiii0vv | if (Pv.new) memb (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa02084) {
					// Instruction: 10: 10101111101---iiPP100ttt1iiii1vv | if !Pv.new memb (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e01800) == 0x1a00800) {
					// Instruction: 10: 10100ii1101sssssPPi01tttiiiiiiii | memh (Rs + #s11:1) = Nt.new
					hi->instruction = HEX_INS_MEMH__RS____S11_1____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 11)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 1);
					sprintf(hi->mnem, "memh (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a00802) {
					// Instruction: 10: 10101001101xxxxxPPu01ttt0-----1- | memh (Rx ++ I:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMH__RX____I_CIRC__MU_____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a00800) {
					// Instruction: 10: 10101001101xxxxxPPu01ttt0iiii-0- | memh (Rx ++ #s4:1:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMH__RX_____S4_1_CIRC__MU_____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xba00880) {
					// Instruction: 10: 10101011101eeeeePP001ttt1-IIIIII | memh (Re = #U6) = Nt.new
					hi->instruction = HEX_INS_MEMH__RE____U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03882) == 0xba00800) {
					// Instruction: 10: 10101011101xxxxxPP001ttt0iiii-0- | memh (Rx ++ #s4:1) = Nt.new
					hi->instruction = HEX_INS_MEMH__RX_____S4_1____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda00880) {
					// Instruction: 10: 10101101101uuuuuPPi01ttt1iIIIIII | memh (Ru << #u2 + #U6) = Nt.new
					hi->instruction = HEX_INS_MEMH__RU_____U2____U6____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memh (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda00800) {
					// Instruction: 10: 10101101101xxxxxPPu01ttt0------- | memh (Rx ++ Mu) = Nt.new
					hi->instruction = HEX_INS_MEMH__RX____MU____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xfa00800) {
					// Instruction: 10: 10101111101xxxxxPPu01ttt0------- | memh (Rx ++ Mu:brev) = Nt.new
					hi->instruction = HEX_INS_MEMH__RX____MU_BREV____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02800) {
					// Instruction: 10: 10101011101xxxxxPP101ttt0iiii0vv | if (Pv) memh (Rx ++ #s4:1) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMH__RX_____S4_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02804) {
					// Instruction: 10: 10101011101xxxxxPP101ttt0iiii1vv | if !Pv memh (Rx ++ #s4:1) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RX_____S4_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02880) {
					// Instruction: 10: 10101011101xxxxxPP101ttt1iiii0vv | if (Pv.new) memh (Rx ++ #s4:1) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RX_____S4_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba02884) {
					// Instruction: 10: 10101011101xxxxxPP101ttt1iiii1vv | if !Pv.new memh (Rx ++ #s4:1) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RX_____S4_1____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa00880) {
					// Instruction: 10: 10101111101---iiPP001ttt1iiii0vv | if (Pv) memh (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMH___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa00884) {
					// Instruction: 10: 10101111101---iiPP001ttt1iiii1vv | if !Pv memh (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa02880) {
					// Instruction: 10: 10101111101---iiPP101ttt1iiii0vv | if (Pv.new) memh (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa02884) {
					// Instruction: 10: 10101111101---iiPP101ttt1iiii1vv | if !Pv.new memh (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e01800) == 0x1a01000) {
					// Instruction: 10: 10100ii1101sssssPPi10tttiiiiiiii | memw (Rs + #s11:2) = Nt.new
					hi->instruction = HEX_INS_MEMW__RS____S11_2____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 12)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 12);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "memw (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a01002) {
					// Instruction: 10: 10101001101xxxxxPPu10ttt0-----1- | memw (Rx ++ I:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMW__RX____I_CIRC__MU_____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01882) == 0x9a01000) {
					// Instruction: 10: 10101001101xxxxxPPu10ttt0iiii-0- | memw (Rx ++ #s4:2:circ (Mu)) = Nt.new
					hi->instruction = HEX_INS_MEMW__RX_____S4_2_CIRC__MU_____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 5)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03880) == 0xba01080) {
					// Instruction: 10: 10101011101eeeeePP010ttt1-IIIIII | memw (Re = #U6) = Nt.new
					hi->instruction = HEX_INS_MEMW__RE____U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03882) == 0xba01000) {
					// Instruction: 10: 10101011101xxxxxPP010ttt0iiii-0- | memw (Rx ++ #s4:2) = Nt.new
					hi->instruction = HEX_INS_MEMW__RX_____S4_2____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 5)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda01080) {
					// Instruction: 10: 10101101101uuuuuPPi10ttt1iIIIIII | memw (Ru << #u2 + #U6) = Nt.new
					hi->instruction = HEX_INS_MEMW__RU_____U2____U6____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memw (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xda01000) {
					// Instruction: 10: 10101101101xxxxxPPu10ttt0------- | memw (Rx ++ Mu) = Nt.new
					hi->instruction = HEX_INS_MEMW__RX____MU____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01880) == 0xfa01000) {
					// Instruction: 10: 10101111101xxxxxPPu10ttt0------- | memw (Rx ++ Mu:brev) = Nt.new
					hi->instruction = HEX_INS_MEMW__RX____MU_BREV____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba03000) {
					// Instruction: 10: 10101011101xxxxxPP110ttt0iiii0vv | if (Pv) memw (Rx ++ #s4:2) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMW__RX_____S4_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba03004) {
					// Instruction: 10: 10101011101xxxxxPP110ttt0iiii1vv | if !Pv memw (Rx ++ #s4:2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RX_____S4_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba03080) {
					// Instruction: 10: 10101011101xxxxxPP110ttt1iiii0vv | if (Pv.new) memw (Rx ++ #s4:2) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RX_____S4_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xba03084) {
					// Instruction: 10: 10101011101xxxxxPP110ttt1iiii1vv | if !Pv.new memw (Rx ++ #s4:2) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RX_____S4_2____NT_NEW;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa01080) {
					// Instruction: 10: 10101111101---iiPP010ttt1iiii0vv | if (Pv) memw (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV__MEMW___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if (P%d) memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa01084) {
					// Instruction: 10: 10101111101---iiPP010ttt1iiii1vv | if !Pv memw (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if !P%d memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa03080) {
					// Instruction: 10: 10101111101---iiPP110ttt1iiii0vv | if (Pv.new) memw (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if (P%d.new) memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe03884) == 0xfa03084) {
					// Instruction: 10: 10101111101---iiPP110ttt1iiii1vv | if !Pv.new memw (#u6) = Nt.new
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW___U6____NT_NEW;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x700) >> 8); // Nt.new
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if !P%d.new memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1c00000) {
					// Instruction: 10: 10100ii1110sssssPPitttttiiiiiiii | memd (Rs + #s11:3) = Rtt
					hi->instruction = HEX_INS_MEMD__RS____S11_3____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 13)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 13);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 3);
					sprintf(hi->mnem, "memd (R%d + %d) = R%d:R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9c00002) {
					// Instruction: 10: 10101001110xxxxxPPuttttt0-----1- | memd (Rx ++ I:circ (Mu)) = Rtt
					hi->instruction = HEX_INS_MEMD__RX____I_CIRC__MU_____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d ++ I:circ (R%d)) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9c00000) {
					// Instruction: 10: 10101001110xxxxxPPuttttt0iiii-0- | memd (Rx ++ #s4:3:circ (Mu)) = Rtt
					hi->instruction = HEX_INS_MEMD__RX_____S4_3_CIRC__MU_____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d ++ %d:circ (R%d)) = R%d:R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xbc00080) {
					// Instruction: 10: 10101011110eeeeePP0ttttt1-IIIIII | memd (Re = #U6) = Rtt
					hi->instruction = HEX_INS_MEMD__RE____U6____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memd (R%d = 0x%x) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02082) == 0xbc00000) {
					// Instruction: 10: 10101011110xxxxxPP0ttttt0iiii-0- | memd (Rx ++ #s4:3) = Rtt
					hi->instruction = HEX_INS_MEMD__RX_____S4_3____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[1].op.imm & (1 << 6)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d ++ %d) = R%d:R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xdc00080) {
					// Instruction: 10: 10101101110uuuuuPPittttt1iIIIIII | memd (Ru << #u2 + #U6) = Rtt
					hi->instruction = HEX_INS_MEMD__RU_____U2____U6____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memd (R%d << 0x%x + 0x%x) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xdc00000) {
					// Instruction: 10: 10101101110xxxxxPPuttttt0------- | memd (Rx ++ Mu) = Rtt
					hi->instruction = HEX_INS_MEMD__RX____MU____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d ++ R%d) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xfc00000) {
					// Instruction: 10: 10101111110xxxxxPPuttttt0------- | memd (Rx ++ Mu:brev) = Rtt
					hi->instruction = HEX_INS_MEMD__RX____MU_BREV____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd (R%d ++ R%d:brev) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xbc02000) {
					// Instruction: 10: 10101011110xxxxxPP1ttttt0iiii0vv | if (Pv) memd (Rx ++ #s4:3) = Rtt
					hi->instruction = HEX_INS_IF__PV__MEMD__RX_____S4_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memd (R%d ++ %d) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xbc02004) {
					// Instruction: 10: 10101011110xxxxxPP1ttttt0iiii1vv | if !Pv memd (Rx ++ #s4:3) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMD__RX_____S4_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memd (R%d ++ %d) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xbc02080) {
					// Instruction: 10: 10101011110xxxxxPP1ttttt1iiii0vv | if (Pv.new) memd (Rx ++ #s4:3) = Rtt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMD__RX_____S4_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memd (R%d ++ %d) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xbc02084) {
					// Instruction: 10: 10101011110xxxxxPP1ttttt1iiii1vv | if !Pv.new memd (Rx ++ #s4:3) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMD__RX_____S4_3____RTT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 3; // scaled
					if (hi->ops[2].op.imm & (1 << 6)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 6);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memd (R%d ++ %d) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xfc00080) {
					// Instruction: 10: 10101111110---iiPP0ttttt1iiii0vv | if (Pv) memd (#u6) = Rtt
					hi->instruction = HEX_INS_IF__PV__MEMD___U6____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memd (0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xfc00084) {
					// Instruction: 10: 10101111110---iiPP0ttttt1iiii1vv | if !Pv memd (#u6) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMD___U6____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memd (0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xfc02080) {
					// Instruction: 10: 10101111110---iiPP1ttttt1iiii0vv | if (Pv.new) memd (#u6) = Rtt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMD___U6____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memd (0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xfc02084) {
					// Instruction: 10: 10101111110---iiPP1ttttt1iiii1vv | if !Pv.new memd (#u6) = Rtt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMD___U6____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memd (0x%x) = R%d:R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1000000) {
					// Instruction: 10: 10100ii1000sssssPPitttttiiiiiiii | memb (Rs + #s11:0) = Rt
					hi->instruction = HEX_INS_MEMB__RS____S11_0____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0));
					if (hi->ops[1].op.imm & (1 << 10)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 10);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9000002) {
					// Instruction: 10: 10101001000xxxxxPPuttttt0-----1- | memb (Rx ++ I:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMB__RX____I_CIRC__MU_____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9000000) {
					// Instruction: 10: 10101001000xxxxxPPuttttt0iiii-0- | memb (Rx ++ #s4:0:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMB__RX_____S4_0_CIRC__MU_____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[1].op.imm & (1 << 3)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xb000080) {
					// Instruction: 10: 10101011000eeeeePP0ttttt1-IIIIII | memb (Re = #U6) = Rt
					hi->instruction = HEX_INS_MEMB__RE____U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02082) == 0xb000000) {
					// Instruction: 10: 10101011000xxxxxPP0ttttt0iiii-0- | memb (Rx ++ #s4:0) = Rt
					hi->instruction = HEX_INS_MEMB__RX_____S4_0____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[1].op.imm & (1 << 3)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd000080) {
					// Instruction: 10: 10101101000uuuuuPPittttt1iIIIIII | memb (Ru << #u2 + #U6) = Rt
					hi->instruction = HEX_INS_MEMB__RU_____U2____U6____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memb (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd000000) {
					// Instruction: 10: 10101101000xxxxxPPuttttt0------- | memb (Rx ++ Mu) = Rt
					hi->instruction = HEX_INS_MEMB__RX____MU____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xf000000) {
					// Instruction: 10: 10101111000xxxxxPPuttttt0------- | memb (Rx ++ Mu:brev) = Rt
					hi->instruction = HEX_INS_MEMB__RX____MU_BREV____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memb (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb002000) {
					// Instruction: 10: 10101011000xxxxxPP1ttttt0iiii0vv | if (Pv) memb (Rx ++ #s4:0) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMB__RX_____S4_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb002004) {
					// Instruction: 10: 10101011000xxxxxPP1ttttt0iiii1vv | if !Pv memb (Rx ++ #s4:0) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB__RX_____S4_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb002080) {
					// Instruction: 10: 10101011000xxxxxPP1ttttt1iiii0vv | if (Pv.new) memb (Rx ++ #s4:0) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB__RX_____S4_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb002084) {
					// Instruction: 10: 10101011000xxxxxPP1ttttt1iiii1vv | if !Pv.new memb (Rx ++ #s4:0) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB__RX_____S4_0____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3);
					if (hi->ops[2].op.imm & (1 << 3)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 3);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf000080) {
					// Instruction: 10: 10101111000---iiPP0ttttt1iiii0vv | if (Pv) memb (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMB___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf000084) {
					// Instruction: 10: 10101111000---iiPP0ttttt1iiii1vv | if !Pv memb (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMB___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf002080) {
					// Instruction: 10: 10101111000---iiPP1ttttt1iiii0vv | if (Pv.new) memb (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMB___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf002084) {
					// Instruction: 10: 10101111000---iiPP1ttttt1iiii1vv | if !Pv.new memb (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMB___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memb (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1400000) {
					// Instruction: 10: 10100ii1010sssssPPitttttiiiiiiii | memh (Rs + #s11:1) = Rt
					hi->instruction = HEX_INS_MEMH__RS____S11_1____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 11)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 1);
					sprintf(hi->mnem, "memh (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1600000) {
					// Instruction: 10: 10100ii1011sssssPPitttttiiiiiiii | memh (Rs + #s11:1) = Rt.H
					hi->instruction = HEX_INS_MEMH__RS____S11_1____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 11)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 11);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d + %d) = R%d.H", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9400002) {
					// Instruction: 10: 10101001010xxxxxPPuttttt0-----1- | memh (Rx ++ I:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMH__RX____I_CIRC__MU_____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9400000) {
					// Instruction: 10: 10101001010xxxxxPPuttttt0iiii-0- | memh (Rx ++ #s4:1:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMH__RX_____S4_1_CIRC__MU_____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9600002) {
					// Instruction: 10: 10101001011xxxxxPPuttttt0-----1- | memh (Rx ++ I:circ (Mu)) = Rt.H
					hi->instruction = HEX_INS_MEMH__RX____I_CIRC__MU_____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ I:circ (R%d)) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9600000) {
					// Instruction: 10: 10101001011xxxxxPPuttttt0iiii-0- | memh (Rx ++ #s4:1:circ (Mu)) = Rt.H
					hi->instruction = HEX_INS_MEMH__RX_____S4_1_CIRC__MU_____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d:circ (R%d)) = R%d.H", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xb400080) {
					// Instruction: 10: 10101011010eeeeePP0ttttt1-IIIIII | memh (Re = #U6) = Rt
					hi->instruction = HEX_INS_MEMH__RE____U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memh (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02082) == 0xb400000) {
					// Instruction: 10: 10101011010xxxxxPP0ttttt0iiii-0- | memh (Rx ++ #s4:1) = Rt
					hi->instruction = HEX_INS_MEMH__RX_____S4_1____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xb600080) {
					// Instruction: 10: 10101011011eeeeePP0ttttt1-IIIIII | memh (Re = #U6) = Rt.H
					hi->instruction = HEX_INS_MEMH__RE____U6____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d = 0x%x) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02082) == 0xb600000) {
					// Instruction: 10: 10101011011xxxxxPP0ttttt0iiii-0- | memh (Rx ++ #s4:1) = Rt.H
					hi->instruction = HEX_INS_MEMH__RX_____S4_1____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[1].op.imm & (1 << 4)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ %d) = R%d.H", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd400080) {
					// Instruction: 10: 10101101010uuuuuPPittttt1iIIIIII | memh (Ru << #u2 + #U6) = Rt
					hi->instruction = HEX_INS_MEMH__RU_____U2____U6____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memh (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd400000) {
					// Instruction: 10: 10101101010xxxxxPPuttttt0------- | memh (Rx ++ Mu) = Rt
					hi->instruction = HEX_INS_MEMH__RX____MU____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd600080) {
					// Instruction: 10: 10101101011uuuuuPPittttt1iIIIIII | memh (Ru << #u2 + #U6) = Rt.H
					hi->instruction = HEX_INS_MEMH__RU_____U2____U6____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d << 0x%x + 0x%x) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd600000) {
					// Instruction: 10: 10101101011xxxxxPPuttttt0------- | memh (Rx ++ Mu) = Rt.H
					hi->instruction = HEX_INS_MEMH__RX____MU____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xf400000) {
					// Instruction: 10: 10101111010xxxxxPPuttttt0------- | memh (Rx ++ Mu:brev) = Rt
					hi->instruction = HEX_INS_MEMH__RX____MU_BREV____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xf600000) {
					// Instruction: 10: 10101111011xxxxxPPuttttt0------- | memh (Rx ++ Mu:brev) = Rt.H
					hi->instruction = HEX_INS_MEMH__RX____MU_BREV____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memh (R%d ++ R%d:brev) = R%d.H", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb402000) {
					// Instruction: 10: 10101011010xxxxxPP1ttttt0iiii0vv | if (Pv) memh (Rx ++ #s4:1) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMH__RX_____S4_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb402004) {
					// Instruction: 10: 10101011010xxxxxPP1ttttt0iiii1vv | if !Pv memh (Rx ++ #s4:1) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RX_____S4_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb402080) {
					// Instruction: 10: 10101011010xxxxxPP1ttttt1iiii0vv | if (Pv.new) memh (Rx ++ #s4:1) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RX_____S4_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb402084) {
					// Instruction: 10: 10101011010xxxxxPP1ttttt1iiii1vv | if !Pv.new memh (Rx ++ #s4:1) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RX_____S4_1____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb602000) {
					// Instruction: 10: 10101011011xxxxxPP1ttttt0iiii0vv | if (Pv) memh (Rx ++ #s4:1) = Rt.H
					hi->instruction = HEX_INS_IF__PV__MEMH__RX_____S4_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (R%d ++ %d) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb602004) {
					// Instruction: 10: 10101011011xxxxxPP1ttttt0iiii1vv | if !Pv memh (Rx ++ #s4:1) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH__RX_____S4_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (R%d ++ %d) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb602080) {
					// Instruction: 10: 10101011011xxxxxPP1ttttt1iiii0vv | if (Pv.new) memh (Rx ++ #s4:1) = Rt.H
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH__RX_____S4_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (R%d ++ %d) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb602084) {
					// Instruction: 10: 10101011011xxxxxPP1ttttt1iiii1vv | if !Pv.new memh (Rx ++ #s4:1) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH__RX_____S4_1____RT_H;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 1; // scaled
					if (hi->ops[2].op.imm & (1 << 4)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 4);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (R%d ++ %d) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf400080) {
					// Instruction: 10: 10101111010---iiPP0ttttt1iiii0vv | if (Pv) memh (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMH___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf400084) {
					// Instruction: 10: 10101111010---iiPP0ttttt1iiii1vv | if !Pv memh (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf402080) {
					// Instruction: 10: 10101111010---iiPP1ttttt1iiii0vv | if (Pv.new) memh (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf402084) {
					// Instruction: 10: 10101111010---iiPP1ttttt1iiii1vv | if !Pv.new memh (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf600080) {
					// Instruction: 10: 10101111011---iiPP0ttttt1iiii0vv | if (Pv) memh (#u6) = Rt.H
					hi->instruction = HEX_INS_IF__PV__MEMH___U6____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memh (0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf600084) {
					// Instruction: 10: 10101111011---iiPP0ttttt1iiii1vv | if !Pv memh (#u6) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_MEMH___U6____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memh (0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf602080) {
					// Instruction: 10: 10101111011---iiPP1ttttt1iiii0vv | if (Pv.new) memh (#u6) = Rt.H
					hi->instruction = HEX_INS_IF__PV_NEW__MEMH___U6____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memh (0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf602084) {
					// Instruction: 10: 10101111011---iiPP1ttttt1iiii1vv | if !Pv.new memh (#u6) = Rt.H
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMH___U6____RT_H;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memh (0x%x) = R%d.H", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0x9e00000) == 0x1800000) {
					// Instruction: 10: 10100ii1100sssssPPitttttiiiiiiii | memw (Rs + #s11:2) = Rt
					hi->instruction = HEX_INS_MEMW__RS____S11_2____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x6000000) >> 16) | ((hi_u32 & 0x2000) >> 5) | ((hi_u32 & 0xff) >> 0)) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 12)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 12);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend_off(&hi->ops[1], 2);
					sprintf(hi->mnem, "memw (R%d + %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9800002) {
					// Instruction: 10: 10101001100xxxxxPPuttttt0-----1- | memw (Rx ++ I:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMW__RX____I_CIRC__MU_____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ I:circ (R%d)) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00082) == 0x9800000) {
					// Instruction: 10: 10101001100xxxxxPPuttttt0iiii-0- | memw (Rx ++ #s4:2:circ (Mu)) = Rt
					hi->instruction = HEX_INS_MEMW__RX_____S4_2_CIRC__MU_____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 5)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ %d:circ (R%d)) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xb800080) {
					// Instruction: 10: 10101011100eeeeePP0ttttt1-IIIIII | memw (Re = #U6) = Rt
					hi->instruction = HEX_INS_MEMW__RE____U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Re
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memw (R%d = 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02082) == 0xb800000) {
					// Instruction: 10: 10101011100xxxxxPP0ttttt0iiii-0- | memw (Rx ++ #s4:2) = Rt
					hi->instruction = HEX_INS_MEMW__RX_____S4_2____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[1].op.imm & (1 << 5)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ %d) = R%d", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd800080) {
					// Instruction: 10: 10101101100uuuuuPPittttt1iIIIIII | memw (Ru << #u2 + #U6) = Rt
					hi->instruction = HEX_INS_MEMW__RU_____U2____U6____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Ru
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x40) >> 6));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3f) >> 0);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "memw (R%d << 0x%x + 0x%x) = R%d", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xd800000) {
					// Instruction: 10: 10101101100xxxxxPPuttttt0------- | memw (Rx ++ Mu) = Rt
					hi->instruction = HEX_INS_MEMW__RX____MU____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ R%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0xf800000) {
					// Instruction: 10: 10101111100xxxxxPPuttttt0------- | memw (Rx ++ Mu:brev) = Rt
					hi->instruction = HEX_INS_MEMW__RX____MU_BREV____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x2000) >> 13); // Mu
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw (R%d ++ R%d:brev) = R%d", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb802000) {
					// Instruction: 10: 10101011100xxxxxPP1ttttt0iiii0vv | if (Pv) memw (Rx ++ #s4:2) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMW__RX_____S4_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					sprintf(hi->mnem, "if (P%d) memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb802004) {
					// Instruction: 10: 10101011100xxxxxPP1ttttt0iiii1vv | if !Pv memw (Rx ++ #s4:2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW__RX_____S4_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					sprintf(hi->mnem, "if !P%d memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb802080) {
					// Instruction: 10: 10101011100xxxxxPP1ttttt1iiii0vv | if (Pv.new) memw (Rx ++ #s4:2) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW__RX_____S4_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					sprintf(hi->mnem, "if (P%d.new) memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xb802084) {
					// Instruction: 10: 10101011100xxxxxPP1ttttt1iiii1vv | if !Pv.new memw (Rx ++ #s4:2) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW__RX_____S4_2____RT;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x78) >> 3) << 2; // scaled
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					sprintf(hi->mnem, "if !P%d.new memw (R%d ++ %d) = R%d", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf800080) {
					// Instruction: 10: 10101111100---iiPP0ttttt1iiii0vv | if (Pv) memw (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV__MEMW___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pv)
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if (P%d) memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf800084) {
					// Instruction: 10: 10101111100---iiPP0ttttt1iiii1vv | if !Pv memw (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_MEMW___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pv
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if !P%d memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf802080) {
					// Instruction: 10: 10101111100---iiPP1ttttt1iiii0vv | if (Pv.new) memw (#u6) = Rt
					hi->instruction = HEX_INS_IF__PV_NEW__MEMW___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pv.new)
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if (P%d.new) memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02084) == 0xf802084) {
					// Instruction: 10: 10101111100---iiPP1ttttt1iiii1vv | if !Pv.new memw (#u6) = Rt
					hi->instruction = HEX_INS_IF__NOT_PV_NEW_MEMW___U6____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x30000) >> 12) | ((hi_u32 & 0x78) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pv.new
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "if !P%d.new memw (0x%x) = R%d", hi->ops[0].op.pred, hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfff3800) == 0x9d0000) {
					// Instruction: 10: 1010000010011101PP000iiiiiiiiiii | allocframe (#u11:3)
					hi->instruction = HEX_INS_ALLOCFRAME___U11_3_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_IMM;
					hi->ops[0].op.imm = (((hi_u32) & 0x7ff) >> 0) << 3; // scaled
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "allocframe (0x%x)", hi->ops[0].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2000000) {
					// Instruction: 10: 10100010000-----PP-------------- | dckill
					hi->instruction = HEX_INS_DCKILL;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dckill");
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2200000) {
					// Instruction: 10: 10100010001sssssPP-------------- | dccleanidx (Rs)
					hi->instruction = HEX_INS_DCCLEANIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dccleanidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2400000) {
					// Instruction: 10: 10100010010sssssPP-------------- | dcinvidx (Rs)
					hi->instruction = HEX_INS_DCINVIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dcinvidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2600000) {
					// Instruction: 10: 10100010011sssssPP-------------- | dccleaninvidx (Rs)
					hi->instruction = HEX_INS_DCCLEANINVIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dccleaninvidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4000000) {
					// Instruction: 10: 10100100000sssssPP-ttttt-------- | dctagw (Rs, Rt)
					hi->instruction = HEX_INS_DCTAGW__RS__RT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dctagw (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4200000) {
					// Instruction: 10: 10100100001sssssPP---------ddddd | Rd = dctagr (Rs)
					hi->instruction = HEX_INS_RD___DCTAGR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = dctagr (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6200000) {
					// Instruction: 10: 10100110001sssssPP-------------- | l2cleanidx (Rs)
					hi->instruction = HEX_INS_L2CLEANIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2cleanidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6400000) {
					// Instruction: 10: 10100110010sssssPP-------------- | l2invidx (Rs)
					hi->instruction = HEX_INS_L2INVIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2invidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8600000) {
					// Instruction: 10: 10101000011sssssPP-------------- | l2cleaninvidx (Rs)
					hi->instruction = HEX_INS_L2CLEANINVIDX__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2cleaninvidx (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6a00000) {
					// Instruction: 10: 10100110101-----PP-ttttt-------- | l2gclean (Rtt)
					hi->instruction = HEX_INS_L2GCLEAN__RTT_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2gclean (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6c00000) {
					// Instruction: 10: 10100110110-----PP-ttttt-------- | l2gcleaninv (Rtt)
					hi->instruction = HEX_INS_L2GCLEANINV__RTT_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2gcleaninv (R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01c00) == 0x8200000) {
					// Instruction: 10: 10101000001-----PP-000---------- | l2kill
					hi->instruction = HEX_INS_L2KILL;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2kill");
					break;
				}
				if ((hi_u32 & 0xfe01c00) == 0x8200800) {
					// Instruction: 10: 10101000001-----PP-010---------- | l2gunlock
					hi->instruction = HEX_INS_L2GUNLOCK;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2gunlock");
					break;
				}
				if ((hi_u32 & 0xfe01c00) == 0x8201000) {
					// Instruction: 10: 10101000001-----PP-100---------- | l2gclean
					hi->instruction = HEX_INS_L2GCLEAN;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2gclean");
					break;
				}
				if ((hi_u32 & 0xfe01c00) == 0x8201800) {
					// Instruction: 10: 10101000001-----PP-110---------- | l2gcleaninv
					hi->instruction = HEX_INS_L2GCLEANINV;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2gcleaninv");
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xe02000) {
					// Instruction: 10: 10100000111sssssPP1-----------dd | Pd = l2locka (Rs)
					hi->instruction = HEX_INS_PD___L2LOCKA__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = l2locka (R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6600000) {
					// Instruction: 10: 10100110011sssssPP-------------- | l2unlocka (Rs)
					hi->instruction = HEX_INS_L2UNLOCKA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2unlocka (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x4400000) {
					// Instruction: 10: 10100100010sssssPP0ttttt-------- | l2tagw (Rs, Rt)
					hi->instruction = HEX_INS_L2TAGW__RS__RT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2tagw (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x4600000) {
					// Instruction: 10: 10100100011sssssPP---------ddddd | Rd = l2tagr (Rs)
					hi->instruction = HEX_INS_RD___L2TAGR__RS_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = l2tagr (R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xa00000) {
					// Instruction: 10: 10100000101sssssPP-ttttt------dd | memw_locked (Rs, Pd) = Rt
					hi->instruction = HEX_INS_MEMW_LOCKED__RS__PD____RT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memw_locked (R%d, P%d) = R%d", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xe00000) {
					// Instruction: 10: 10100000111sssssPP0ttttt------dd | memd_locked (Rs, Pd) = Rtt
					hi->instruction = HEX_INS_MEMD_LOCKED__RS__PD____RTT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "memd_locked (R%d, P%d) = R%d:R%d", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0xc00000) {
					// Instruction: 10: 10100000110sssssPP0------------- | dczeroa (Rs)
					hi->instruction = HEX_INS_DCZEROA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dczeroa (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8000000) {
					// Instruction: 10: 10101000000-----PP-------------- | barrier
					hi->instruction = HEX_INS_BARRIER;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "barrier");
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x0) {
					// Instruction: 10: 10100000000sssssPP-------------- | dccleana (Rs)
					hi->instruction = HEX_INS_DCCLEANA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dccleana (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x200000) {
					// Instruction: 10: 10100000001sssssPP-------------- | dcinva (Rs)
					hi->instruction = HEX_INS_DCINVA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dcinva (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x400000) {
					// Instruction: 10: 10100000010sssssPP-------------- | dccleaninva (Rs)
					hi->instruction = HEX_INS_DCCLEANINVA__RS_;
					hi->op_count = 1;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "dccleaninva (R%d)", hi->ops[0].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6000000) {
					// Instruction: 10: 10100110000sssssPP-ttttt-------- | l2fetch (Rs, Rt)
					hi->instruction = HEX_INS_L2FETCH__RS__RT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2fetch (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6800000) {
					// Instruction: 10: 10100110100sssssPP-ttttt-------- | l2fetch (Rs, Rtt)
					hi->instruction = HEX_INS_L2FETCH__RS__RTT_;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "l2fetch (R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x8400000) {
					// Instruction: 10: 10101000010-----PP-------------- | syncht
					hi->instruction = HEX_INS_SYNCHT;
					hi->op_count = 0;
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "syncht");
					break;
				}
				break;
			}
			case 0xb: {
				if ((hi_u32 & 0x0) == 0x0) {
					// Instruction: 11: 1011iiiiiiisssssPPiiiiiiiiiddddd | Rd = add (Rs, #s16)
					hi->instruction = HEX_INS_RD___ADD__RS___S16_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0xfe00000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 15)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 15);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = add (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				break;
			}
			case 0xc: {
				if ((hi_u32 & 0xfe00000) == 0x2c00000) {
					// Instruction: 12: 11000010110sssssPP-ttttt-xxddddd | Rdd = add (Rss, Rtt, Px) :carry
					hi->instruction = HEX_INS_RDD___ADD__RSS__RTT__PX___CARRY;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = add (R%d:R%d, R%d:R%d, P%d) :carry", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2e00000) {
					// Instruction: 12: 11000010111sssssPP-ttttt-xxddddd | Rdd = sub (Rss, Rtt, Px) :carry
					hi->instruction = HEX_INS_RDD___SUB__RSS__RTT__PX___CARRY;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = sub (R%d:R%d, R%d:R%d, P%d) :carry", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfc020e0) == 0xa800000) {
					// Instruction: 12: 1100101010-sssssPP0ttttt000xxxxx | Rxx ^= xor (Rss, Rtt)
					hi->instruction = HEX_INS_RXX____XOR__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= xor (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6c00000) {
					// Instruction: 12: 1100011011-sssssPP-ttttt00-ddddd | Rd = cround (Rs, Rt)
					hi->instruction = HEX_INS_RD___CROUND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cround (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6c00080) {
					// Instruction: 12: 1100011011-sssssPP-ttttt10-ddddd | Rd = round (Rs, Rt)
					hi->instruction = HEX_INS_RD___ROUND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = round (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6c000c0) {
					// Instruction: 12: 1100011011-sssssPP-ttttt11-ddddd | Rd = round (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___ROUND__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = round (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1400020) {
					// Instruction: 12: 1100000101-sssssPP-ttttt001ddddd | Rd = vaddhub (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RD___VADDHUB__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vaddhub (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3c00040) {
					// Instruction: 12: 1100001111-sssssPP-ttttt01-ddddd | Rdd = vcnegh (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VCNEGH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vcnegh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb2020e0) {
					// Instruction: 12: 11001011001sssssPP1ttttt111xxxxx | Rxx += vrcnegh (Rss, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCNEGH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcnegh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb200020) {
					// Instruction: 12: 11001011001sssssPP0xxxxx001uuuuu | Rxx = vrmaxh (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMAXH__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmaxh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb202020) {
					// Instruction: 12: 11001011001sssssPP1xxxxx001uuuuu | Rxx = vrmaxuh (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMAXUH__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmaxuh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb200040) {
					// Instruction: 12: 11001011001sssssPP0xxxxx010uuuuu | Rxx = vrmaxw (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMAXW__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmaxw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb202040) {
					// Instruction: 12: 11001011001sssssPP1xxxxx010uuuuu | Rxx = vrmaxuw (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMAXUW__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmaxuw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb2000a0) {
					// Instruction: 12: 11001011001sssssPP0xxxxx101uuuuu | Rxx = vrminh (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMINH__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrminh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb2020a0) {
					// Instruction: 12: 11001011001sssssPP1xxxxx101uuuuu | Rxx = vrminuh (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMINUH__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrminuh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb2000c0) {
					// Instruction: 12: 11001011001sssssPP0xxxxx110uuuuu | Rxx = vrminw (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMINW__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrminw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb2020c0) {
					// Instruction: 12: 11001011001sssssPP1xxxxx110uuuuu | Rxx = vrminuw (Rss, Ru)
					hi->instruction = HEX_INS_RXX___VRMINUW__RSS__RU_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrminuw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1000000) {
					// Instruction: 12: 1100000100-sssssPP-ttttt00-ddddd | Rdd = extractu (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___EXTRACTU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = extractu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1c00080) {
					// Instruction: 12: 1100000111-sssssPP-ttttt10-ddddd | Rdd = extract (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___EXTRACT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = extract (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x9000000) {
					// Instruction: 12: 1100100100-sssssPP-ttttt00-ddddd | Rd = extractu (Rs, Rtt)
					hi->instruction = HEX_INS_RD___EXTRACTU__RS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = extractu (R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x9000040) {
					// Instruction: 12: 1100100100-sssssPP-ttttt01-ddddd | Rd = extract (Rs, Rtt)
					hi->instruction = HEX_INS_RD___EXTRACT__RS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = extract (R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x8000000) {
					// Instruction: 12: 11001000---sssssPP-ttttt---xxxxx | Rx = insert (Rs, Rtt)
					hi->instruction = HEX_INS_RX___INSERT__RS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = insert (R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0xa000000) {
					// Instruction: 12: 110010100--sssssPP0ttttt---xxxxx | Rxx = insert (Rss, Rtt)
					hi->instruction = HEX_INS_RXX___INSERT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = insert (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x18000c0) {
					// Instruction: 12: 1100000110-sssssPP-ttttt110ddddd | Rdd = lfs (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___LFS__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = lfs (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6800000) {
					// Instruction: 12: 1100011010-sssssPP-ttttt00-ddddd | Rd = setbit (Rs, Rt)
					hi->instruction = HEX_INS_RD___SETBIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = setbit (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6800040) {
					// Instruction: 12: 1100011010-sssssPP-ttttt01-ddddd | Rd = clrbit (Rs, Rt)
					hi->instruction = HEX_INS_RD___CLRBIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = clrbit (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6800080) {
					// Instruction: 12: 1100011010-sssssPP-ttttt10-ddddd | Rd = togglebit (Rs, Rt)
					hi->instruction = HEX_INS_RD___TOGGLEBIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = togglebit (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1400080) {
					// Instruction: 12: 1100000101-sssssPP-ttttt100ddddd | Rdd = vxaddsubh (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VXADDSUBH__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxaddsubh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x14000c0) {
					// Instruction: 12: 1100000101-sssssPP-ttttt110ddddd | Rdd = vxsubaddh (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VXSUBADDH__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxsubaddh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1c00000) {
					// Instruction: 12: 1100000111-sssssPP-ttttt00-ddddd | Rdd = vxaddsubh (Rss, Rtt) :rnd:>>1:sat
					hi->instruction = HEX_INS_RDD___VXADDSUBH__RSS__RTT___RND___1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RSH1; // :>>1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxaddsubh (R%d:R%d, R%d:R%d) :rnd:>>1:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1c00040) {
					// Instruction: 12: 1100000111-sssssPP-ttttt01-ddddd | Rdd = vxsubaddh (Rss, Rtt) :rnd:>>1:sat
					hi->instruction = HEX_INS_RDD___VXSUBADDH__RSS__RTT___RND___1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RSH1; // :>>1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxsubaddh (R%d:R%d, R%d:R%d) :rnd:>>1:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1400000) {
					// Instruction: 12: 1100000101-sssssPP-ttttt000ddddd | Rdd = vxaddsubw (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VXADDSUBW__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxaddsubw (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1400040) {
					// Instruction: 12: 1100000101-sssssPP-ttttt010ddddd | Rdd = vxsubaddw (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VXSUBADDW__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vxsubaddw (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf0000e0) == 0x5000080) {
					// Instruction: 12: 11000101---sssssPP-ttttt100ddddd | Rd = cmpyiwh (Rss, Rt) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___CMPYIWH__RSS__RT_____1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpyiwh (R%d:R%d, R%d) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf0000e0) == 0x50000a0) {
					// Instruction: 12: 11000101---sssssPP-ttttt101ddddd | Rd = cmpyiwh (Rss, Rt *) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___CMPYIWH__RSS__RT_______1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpyiwh (R%d:R%d, R%d *) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf0000e0) == 0x50000c0) {
					// Instruction: 12: 11000101---sssssPP-ttttt110ddddd | Rd = cmpyrwh (Rss, Rt) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___CMPYRWH__RSS__RT_____1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpyrwh (R%d:R%d, R%d) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf0000e0) == 0x50000e0) {
					// Instruction: 12: 11000101---sssssPP-ttttt111ddddd | Rd = cmpyrwh (Rss, Rt *) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___CMPYRWH__RSS__RT_______1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpyrwh (R%d:R%d, R%d *) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3c00000) {
					// Instruction: 12: 1100001111-sssssPP-ttttt00-ddddd | Rdd = vcrotate (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VCROTATE__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vcrotate (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3c000c0) {
					// Instruction: 12: 1100001111-sssssPPittttt11iddddd | Rdd = vrcrotate (Rss, Rt, #u2)
					hi->instruction = HEX_INS_RDD___VRCROTATE__RSS__RT___U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x20) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrcrotate (R%d:R%d, R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0xba00000) {
					// Instruction: 12: 11001011101sssssPPittttt--ixxxxx | Rxx += vrcrotate (Rss, Rt, #u2)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCROTATE__RSS__RT___U2_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x2000) >> 12) | ((hi_u32 & 0x20) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcrotate (R%d:R%d, R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7e00000) {
					// Instruction: 12: 11000111111sssssPP-ttttt000---dd | Pd = cmp.ge (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_GE__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.ge (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7e00020) {
					// Instruction: 12: 11000111111sssssPP-ttttt001---dd | Pd = cmp.uo (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_UO__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.uo (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7e00060) {
					// Instruction: 12: 11000111111sssssPP-ttttt011---dd | Pd = cmp.eq (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_EQ__RS__RT__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.eq (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7e00080) {
					// Instruction: 12: 11000111111sssssPP-ttttt100---dd | Pd = cmp.gt (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_GT__RS__RT__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gt (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1c000c0) {
					// Instruction: 12: 1100000111-sssssPP-ttttt11-ddddd | Rdd = decbin (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___DECBIN__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = decbin (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x0) {
					// Instruction: 12: 110000000--sssssPP-tttttiiiddddd | Rdd = valignb (Rtt, Rss, #u3)
					hi->instruction = HEX_INS_RDD___VALIGNB__RTT__RSS___U3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = valignb (R%d:R%d, R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x2000000) {
					// Instruction: 12: 110000100--sssssPP-ttttt-uuddddd | Rdd = valignb (Rtt, Rss, Pu)
					hi->instruction = HEX_INS_RDD___VALIGNB__RTT__RSS__PU_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = valignb (R%d:R%d, R%d:R%d, P%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1000040) {
					// Instruction: 12: 1100000100-sssssPP-ttttt01-ddddd | Rdd = shuffeb (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___SHUFFEB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = shuffeb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x1000080) {
					// Instruction: 12: 1100000100-sssssPP-ttttt10-ddddd | Rdd = shuffob (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___SHUFFOB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = shuffob (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x10000c0) {
					// Instruction: 12: 1100000100-sssssPP-ttttt11-ddddd | Rdd = shuffeh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___SHUFFEH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = shuffeh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1800000) {
					// Instruction: 12: 1100000110-sssssPP-ttttt000ddddd | Rdd = shuffoh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___SHUFFOH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = shuffoh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x800000) {
					// Instruction: 12: 110000001--sssssPP-tttttiiiddddd | Rdd = vspliceb (Rss, Rtt, #u3)
					hi->instruction = HEX_INS_RDD___VSPLICEB__RSS__RTT___U3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vspliceb (R%d:R%d, R%d:R%d, 0x%x)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x2800000) {
					// Instruction: 12: 11000010100sssssPP-ttttt-uuddddd | Rdd = vspliceb (Rss, Rtt, Pu)
					hi->instruction = HEX_INS_RDD___VSPLICEB__RSS__RTT__PU_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vspliceb (R%d:R%d, R%d:R%d, P%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1800040) {
					// Instruction: 12: 1100000110-sssssPP-ttttt010ddddd | Rdd = vtrunewh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VTRUNEWH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vtrunewh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1800060) {
					// Instruction: 12: 1100000110-sssssPP-ttttt011ddddd | Rdd = vtrunehb (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VTRUNEHB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vtrunehb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x1800080) {
					// Instruction: 12: 1100000110-sssssPP-ttttt100ddddd | Rdd = vtrunowh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VTRUNOWH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vtrunowh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000e0) == 0x18000a0) {
					// Instruction: 12: 1100000110-sssssPP-ttttt101ddddd | Rdd = vtrunohb (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VTRUNOHB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vtrunohb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c00040) {
					// Instruction: 12: 11000111110sssssPP-ttttt010---dd | Pd = cmpb.gt (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPB_GT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmpb.gt (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c000c0) {
					// Instruction: 12: 11000111110sssssPP-ttttt110---dd | Pd = cmpb.eq (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPB_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmpb.eq (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c000e0) {
					// Instruction: 12: 11000111110sssssPP-ttttt111---dd | Pd = cmpb.gtu (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPB_GTU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmpb.gtu (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c00060) {
					// Instruction: 12: 11000111110sssssPP-ttttt011---dd | Pd = cmph.eq (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPH_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmph.eq (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c00080) {
					// Instruction: 12: 11000111110sssssPP-ttttt100---dd | Pd = cmph.gt (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPH_GT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmph.gt (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x7c000a0) {
					// Instruction: 12: 11000111110sssssPP-ttttt101---dd | Pd = cmph.gtu (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMPH_GTU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmph.gtu (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7400000) {
					// Instruction: 12: 11000111010sssssPP-ttttt------dd | Pd = bitsset (Rs, Rt)
					hi->instruction = HEX_INS_PD___BITSSET__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = bitsset (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7600000) {
					// Instruction: 12: 11000111011sssssPP-ttttt------dd | Pd = !bitsset (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_BITSSET__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !bitsset (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7800000) {
					// Instruction: 12: 11000111100sssssPP-ttttt------dd | Pd = bitsclr (Rs, Rt)
					hi->instruction = HEX_INS_PD___BITSCLR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = bitsclr (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7a00000) {
					// Instruction: 12: 11000111101sssssPP-ttttt------dd | Pd = !bitsclr (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_BITSCLR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !bitsclr (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7000000) {
					// Instruction: 12: 11000111000sssssPP-ttttt------dd | Pd = tstbit (Rs, Rt)
					hi->instruction = HEX_INS_PD___TSTBIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = tstbit (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x7200000) {
					// Instruction: 12: 11000111001sssssPP-ttttt------dd | Pd = !tstbit (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_TSTBIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !tstbit (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02000) == 0x4000000) {
					// Instruction: 12: 11000100000sssssPP0tttttiiiddddd | Rd = addasl (Rt, Rs, #u3)
					hi->instruction = HEX_INS_RD___ADDASL__RT__RS___U3_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32) & 0xe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = addasl (R%d, R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3800000) {
					// Instruction: 12: 1100001110-sssssPP-ttttt00-ddddd | Rdd = asr (Rss, Rt)
					hi->instruction = HEX_INS_RDD___ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3800040) {
					// Instruction: 12: 1100001110-sssssPP-ttttt01-ddddd | Rdd = lsr (Rss, Rt)
					hi->instruction = HEX_INS_RDD___LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3800080) {
					// Instruction: 12: 1100001110-sssssPP-ttttt10-ddddd | Rdd = asl (Rss, Rt)
					hi->instruction = HEX_INS_RDD___ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x38000c0) {
					// Instruction: 12: 1100001110-sssssPP-ttttt11-ddddd | Rdd = lsl (Rss, Rt)
					hi->instruction = HEX_INS_RDD___LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6400000) {
					// Instruction: 12: 1100011001-sssssPP-ttttt00-ddddd | Rd = asr (Rs, Rt)
					hi->instruction = HEX_INS_RD___ASR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = asr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6400040) {
					// Instruction: 12: 1100011001-sssssPP-ttttt01-ddddd | Rd = lsr (Rs, Rt)
					hi->instruction = HEX_INS_RD___LSR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = lsr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6400080) {
					// Instruction: 12: 1100011001-sssssPP-ttttt10-ddddd | Rd = asl (Rs, Rt)
					hi->instruction = HEX_INS_RD___ASL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = asl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x64000c0) {
					// Instruction: 12: 1100011001-sssssPP-ttttt11-ddddd | Rd = lsl (Rs, Rt)
					hi->instruction = HEX_INS_RD___LSL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = lsl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x68000c0) {
					// Instruction: 12: 1100011010-iiiiiPP-ttttt11iddddd | Rd = lsl (#s6, Rt)
					hi->instruction = HEX_INS_RD___LSL___S6__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x1f0000) >> 15) | ((hi_u32 & 0x20) >> 5));
					if (hi->ops[1].op.imm & (1 << 5)) {
						hi->ops[1].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = lsl (%d, R%d)", hi->ops[0].op.reg, (st32) hi->ops[1].op.imm, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb800000) {
					// Instruction: 12: 11001011100sssssPP-ttttt00-xxxxx | Rxx -= asr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb800040) {
					// Instruction: 12: 11001011100sssssPP-ttttt01-xxxxx | Rxx -= lsr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb800080) {
					// Instruction: 12: 11001011100sssssPP-ttttt10-xxxxx | Rxx -= asl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb8000c0) {
					// Instruction: 12: 11001011100sssssPP-ttttt11-xxxxx | Rxx -= lsl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xbc00000) {
					// Instruction: 12: 11001011110sssssPP-ttttt00-xxxxx | Rxx += asr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xbc00040) {
					// Instruction: 12: 11001011110sssssPP-ttttt01-xxxxx | Rxx += lsr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xbc00080) {
					// Instruction: 12: 11001011110sssssPP-ttttt10-xxxxx | Rxx += asl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xbc000c0) {
					// Instruction: 12: 11001011110sssssPP-ttttt11-xxxxx | Rxx += lsl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc800000) {
					// Instruction: 12: 1100110010-sssssPP-ttttt00-xxxxx | Rx -= asr (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ASR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= asr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc800040) {
					// Instruction: 12: 1100110010-sssssPP-ttttt01-xxxxx | Rx -= lsr (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__LSR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= lsr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc800080) {
					// Instruction: 12: 1100110010-sssssPP-ttttt10-xxxxx | Rx -= asl (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ASL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= asl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc8000c0) {
					// Instruction: 12: 1100110010-sssssPP-ttttt11-xxxxx | Rx -= lsl (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__LSL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= lsl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xcc00000) {
					// Instruction: 12: 1100110011-sssssPP-ttttt00-xxxxx | Rx += asr (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ASR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += asr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xcc00040) {
					// Instruction: 12: 1100110011-sssssPP-ttttt01-xxxxx | Rx += lsr (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__LSR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += lsr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xcc00080) {
					// Instruction: 12: 1100110011-sssssPP-ttttt10-xxxxx | Rx += asl (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ASL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += asl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xcc000c0) {
					// Instruction: 12: 1100110011-sssssPP-ttttt11-xxxxx | Rx += lsl (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__LSL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += lsl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb000000) {
					// Instruction: 12: 11001011000sssssPP-ttttt00-xxxxx | Rxx |= asr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__OR_EQ__ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb000040) {
					// Instruction: 12: 11001011000sssssPP-ttttt01-xxxxx | Rxx |= lsr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__OR_EQ__LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb000080) {
					// Instruction: 12: 11001011000sssssPP-ttttt10-xxxxx | Rxx |= asl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__OR_EQ__ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb0000c0) {
					// Instruction: 12: 11001011000sssssPP-ttttt11-xxxxx | Rxx |= lsl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__OR_EQ__LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d |= lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb400000) {
					// Instruction: 12: 11001011010sssssPP-ttttt00-xxxxx | Rxx &= asr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__AND_EQ__ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb400040) {
					// Instruction: 12: 11001011010sssssPP-ttttt01-xxxxx | Rxx &= lsr (Rss, Rt)
					hi->instruction = HEX_INS_RXX__AND_EQ__LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb400080) {
					// Instruction: 12: 11001011010sssssPP-ttttt10-xxxxx | Rxx &= asl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__AND_EQ__ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb4000c0) {
					// Instruction: 12: 11001011010sssssPP-ttttt11-xxxxx | Rxx &= lsl (Rss, Rt)
					hi->instruction = HEX_INS_RXX__AND_EQ__LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d &= lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb600000) {
					// Instruction: 12: 11001011011sssssPP-ttttt00-xxxxx | Rxx ^= asr (Rss, Rt)
					hi->instruction = HEX_INS_RXX____ASR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= asr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb600040) {
					// Instruction: 12: 11001011011sssssPP-ttttt01-xxxxx | Rxx ^= lsr (Rss, Rt)
					hi->instruction = HEX_INS_RXX____LSR__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= lsr (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb600080) {
					// Instruction: 12: 11001011011sssssPP-ttttt10-xxxxx | Rxx ^= asl (Rss, Rt)
					hi->instruction = HEX_INS_RXX____ASL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= asl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0xb6000c0) {
					// Instruction: 12: 11001011011sssssPP-ttttt11-xxxxx | Rxx ^= lsl (Rss, Rt)
					hi->instruction = HEX_INS_RXX____LSL__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= lsl (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc000000) {
					// Instruction: 12: 1100110000-sssssPP-ttttt00-xxxxx | Rx |= asr (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__ASR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= asr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc000040) {
					// Instruction: 12: 1100110000-sssssPP-ttttt01-xxxxx | Rx |= lsr (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__LSR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= lsr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc000080) {
					// Instruction: 12: 1100110000-sssssPP-ttttt10-xxxxx | Rx |= asl (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__ASL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= asl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc0000c0) {
					// Instruction: 12: 1100110000-sssssPP-ttttt11-xxxxx | Rx |= lsl (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__LSL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= lsl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc400000) {
					// Instruction: 12: 1100110001-sssssPP-ttttt00-xxxxx | Rx &= asr (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__ASR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= asr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc400040) {
					// Instruction: 12: 1100110001-sssssPP-ttttt01-xxxxx | Rx &= lsr (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__LSR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= lsr (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc400080) {
					// Instruction: 12: 1100110001-sssssPP-ttttt10-xxxxx | Rx &= asl (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__ASL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= asl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0xc4000c0) {
					// Instruction: 12: 1100110001-sssssPP-ttttt11-xxxxx | Rx &= lsl (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__LSL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= lsl (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6000000) {
					// Instruction: 12: 1100011000-sssssPP-ttttt00-ddddd | Rd = asr (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___ASR__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = asr (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x6000080) {
					// Instruction: 12: 1100011000-sssssPP-ttttt10-ddddd | Rd = asl (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___ASL__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = asl (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3400000) {
					// Instruction: 12: 1100001101-sssssPP-ttttt00-ddddd | Rdd = vasrh (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VASRH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vasrh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3400040) {
					// Instruction: 12: 1100001101-sssssPP-ttttt01-ddddd | Rdd = vlsrh (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VLSRH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlsrh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3400080) {
					// Instruction: 12: 1100001101-sssssPP-ttttt10-ddddd | Rdd = vaslh (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VASLH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaslh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x34000c0) {
					// Instruction: 12: 1100001101-sssssPP-ttttt11-ddddd | Rdd = vlslh (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VLSLH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlslh (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3000000) {
					// Instruction: 12: 1100001100-sssssPP-ttttt00-ddddd | Rdd = vasrw (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VASRW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vasrw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3000040) {
					// Instruction: 12: 1100001100-sssssPP-ttttt01-ddddd | Rdd = vlsrw (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VLSRW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlsrw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x3000080) {
					// Instruction: 12: 1100001100-sssssPP-ttttt10-ddddd | Rdd = vaslw (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VASLW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaslw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc000c0) == 0x30000c0) {
					// Instruction: 12: 1100001100-sssssPP-ttttt11-ddddd | Rdd = vlslw (Rss, Rt)
					hi->instruction = HEX_INS_RDD___VLSLW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vlslw (R%d:R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf0000e0) == 0x5000040) {
					// Instruction: 12: 11000101---sssssPP-ttttt010ddddd | Rd = vasrw (Rss, Rt)
					hi->instruction = HEX_INS_RD___VASRW__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vasrw (R%d:R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				break;
			}
			case 0xd: {
				if ((hi_u32 & 0xf800000) == 0xb000000) {
					// Instruction: 13: 110110110iisssssPPidddddiiiuuuuu | Rd = add (Rs, add (Ru, #s6))
					hi->instruction = HEX_INS_RD___ADD__RS__ADD__RU___S6__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5));
					if (hi->ops[3].op.imm & (1 << 5)) {
						hi->ops[3].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[3]);
					sprintf(hi->mnem, "R%d = add (R%d, add (R%d, %d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, (st32) hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xb800000) {
					// Instruction: 13: 110110111iisssssPPidddddiiiuuuuu | Rd = add (Rs, sub (#s6, Ru))
					hi->instruction = HEX_INS_RD___ADD__RS__SUB___S6__RU__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 5)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 5);
					}
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d = add (R%d, sub (%d, R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x30000e0) {
					// Instruction: 13: 11010011000sssssPP-ttttt111ddddd | Rdd = add (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___ADD__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = add (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x36000a0) {
					// Instruction: 13: 11010011011sssssPP-ttttt101ddddd | Rdd = add (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___ADD__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = add (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x36000c0) {
					// Instruction: 13: 11010011011sssssPP-ttttt110ddddd | Rdd = add (Rss, Rtt) :raw:lo
					hi->instruction = HEX_INS_RDD___ADD__RSS__RTT___RAW_LO;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LO; // :lo
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d:R%d = add (R%d:R%d, R%d:R%d) :raw:lo", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x36000e0) {
					// Instruction: 13: 11010011011sssssPP-ttttt111ddddd | Rdd = add (Rss, Rtt) :raw:hi
					hi->instruction = HEX_INS_RDD___ADD__RSS__RTT___RAW_HI;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_HI; // :hi
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "R%d:R%d = add (R%d:R%d, R%d:R%d) :raw:hi", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5800000) {
					// Instruction: 13: 11010101100sssssPP-ttttt0--ddddd | Rd = add (Rs, Rt) :sat:deprecated
					hi->instruction = HEX_INS_RD___ADD__RS__RT___SAT_DEPRECATED;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_DEPRECATED; // :deprecated
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d, R%d) :sat:deprecated", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5000000) {
					// Instruction: 13: 11010101000sssssPP-ttttt00-ddddd | Rd = add (Rt.L, Rs.L)
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_L_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.L)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5000040) {
					// Instruction: 13: 11010101000sssssPP-ttttt01-ddddd | Rd = add (Rt.L, Rs.H)
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_H_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.H)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5000080) {
					// Instruction: 13: 11010101000sssssPP-ttttt10-ddddd | Rd = add (Rt.L, Rs.L) :sat
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_L___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.L) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x50000c0) {
					// Instruction: 13: 11010101000sssssPP-ttttt11-ddddd | Rd = add (Rt.L, Rs.H) :sat
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_H___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.H) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5400000) {
					// Instruction: 13: 11010101010sssssPP-ttttt000ddddd | Rd = add (Rt.L, Rs.L) :<<16
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_L_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.L) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5400020) {
					// Instruction: 13: 11010101010sssssPP-ttttt001ddddd | Rd = add (Rt.L, Rs.H) :<<16
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_H_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.H) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5400040) {
					// Instruction: 13: 11010101010sssssPP-ttttt010ddddd | Rd = add (Rt.H, Rs.L) :<<16
					hi->instruction = HEX_INS_RD___ADD__RT_H__RS_L_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = add (R%d.H, R%d.L) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5400060) {
					// Instruction: 13: 11010101010sssssPP-ttttt011ddddd | Rd = add (Rt.H, Rs.H) :<<16
					hi->instruction = HEX_INS_RD___ADD__RT_H__RS_H_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = add (R%d.H, R%d.H) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5400080) {
					// Instruction: 13: 11010101010sssssPP-ttttt100ddddd | Rd = add (Rt.L, Rs.L) :sat:<<16
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_L___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.L) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x54000a0) {
					// Instruction: 13: 11010101010sssssPP-ttttt101ddddd | Rd = add (Rt.L, Rs.H) :sat:<<16
					hi->instruction = HEX_INS_RD___ADD__RT_L__RS_H___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.L, R%d.H) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x54000c0) {
					// Instruction: 13: 11010101010sssssPP-ttttt110ddddd | Rd = add (Rt.H, Rs.L) :sat:<<16
					hi->instruction = HEX_INS_RD___ADD__RT_H__RS_L___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.H, R%d.L) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x54000e0) {
					// Instruction: 13: 11010101010sssssPP-ttttt111ddddd | Rd = add (Rt.H, Rs.H) :sat:<<16
					hi->instruction = HEX_INS_RD___ADD__RT_H__RS_H___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d.H, R%d.H) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e00000) {
					// Instruction: 13: 11010011111sssssPP-ttttt000ddddd | Rdd = and (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___AND__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = and (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e00020) {
					// Instruction: 13: 11010011111sssssPP-ttttt001ddddd | Rdd = and (Rtt, ~Rss)
					hi->instruction = HEX_INS_RDD___AND__RTT___RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = and (R%d:R%d, ~R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e00040) {
					// Instruction: 13: 11010011111sssssPP-ttttt010ddddd | Rdd = or (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___OR__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = or (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e00060) {
					// Instruction: 13: 11010011111sssssPP-ttttt011ddddd | Rdd = or (Rtt, ~Rss)
					hi->instruction = HEX_INS_RDD___OR__RTT___RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = or (R%d:R%d, ~R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e00080) {
					// Instruction: 13: 11010011111sssssPP-ttttt100ddddd | Rdd = xor (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___XOR__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = xor (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0xa000000) {
					// Instruction: 13: 1101101000isssssPPiiiiiiiiixxxxx | Rx |= and (Rs, #s10)
					hi->instruction = HEX_INS_RX__OR_EQ__AND__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= and (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0xa400000) {
					// Instruction: 13: 1101101001ixxxxxPPiiiiiiiiiuuuuu | Rx = or (Ru, and (Rx, #s10))
					hi->instruction = HEX_INS_RX___OR__RU__AND__RX___S10__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = or (R%d, and (Rx, %d))", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0xa800000) {
					// Instruction: 13: 1101101010isssssPPiiiiiiiiixxxxx | Rx |= or (Rs, #s10)
					hi->instruction = HEX_INS_RX__OR_EQ__OR__RS___S10_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					if (hi->ops[2].op.imm & (1 << 9)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 9);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= or (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5c00000) {
					// Instruction: 13: 11010101110sssssPP-ttttt0--ddddd | Rd = max (Rs, Rt)
					hi->instruction = HEX_INS_RD___MAX__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = max (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5c00080) {
					// Instruction: 13: 11010101110sssssPP-ttttt1--ddddd | Rd = maxu (Rs, Rt)
					hi->instruction = HEX_INS_RD___MAXU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = maxu (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c00080) {
					// Instruction: 13: 11010011110sssssPP-ttttt100ddddd | Rdd = max (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___MAX__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = max (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c000a0) {
					// Instruction: 13: 11010011110sssssPP-ttttt101ddddd | Rdd = maxu (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___MAXU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = maxu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5a00000) {
					// Instruction: 13: 11010101101sssssPP-ttttt0--ddddd | Rd = min (Rt, Rs)
					hi->instruction = HEX_INS_RD___MIN__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = min (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5a00080) {
					// Instruction: 13: 11010101101sssssPP-ttttt1--ddddd | Rd = minu (Rt, Rs)
					hi->instruction = HEX_INS_RD___MINU__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = minu (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a000c0) {
					// Instruction: 13: 11010011101sssssPP-ttttt110ddddd | Rdd = min (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___MIN__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = min (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a000e0) {
					// Instruction: 13: 11010011101sssssPP-ttttt111ddddd | Rdd = minu (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___MINU__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = minu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3e000e0) {
					// Instruction: 13: 11010011111sssssPP-ttttt111ddddd | Rd = modwrap (Rs, Rt)
					hi->instruction = HEX_INS_RD___MODWRAP__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = modwrap (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x32000e0) {
					// Instruction: 13: 11010011001sssssPP-ttttt111ddddd | Rdd = sub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___SUB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = sub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00080) == 0x5800080) {
					// Instruction: 13: 11010101100sssssPP-ttttt1--ddddd | Rd = sub (Rt, Rs) :sat:deprecated
					hi->instruction = HEX_INS_RD___SUB__RT__RS___SAT_DEPRECATED;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_DEPRECATED; // :deprecated
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d, R%d) :sat:deprecated", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5200000) {
					// Instruction: 13: 11010101001sssssPP-ttttt00-ddddd | Rd = sub (Rt.L, Rs.L)
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_L_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.L)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5200040) {
					// Instruction: 13: 11010101001sssssPP-ttttt01-ddddd | Rd = sub (Rt.L, Rs.H)
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_H_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.H)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x5200080) {
					// Instruction: 13: 11010101001sssssPP-ttttt10-ddddd | Rd = sub (Rt.L, Rs.L) :sat
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_L___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.L) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x52000c0) {
					// Instruction: 13: 11010101001sssssPP-ttttt11-ddddd | Rd = sub (Rt.L, Rs.H) :sat
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_H___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.H) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5600000) {
					// Instruction: 13: 11010101011sssssPP-ttttt000ddddd | Rd = sub (Rt.L, Rs.L) :<<16
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_L_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.L) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5600020) {
					// Instruction: 13: 11010101011sssssPP-ttttt001ddddd | Rd = sub (Rt.L, Rs.H) :<<16
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_H_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.H) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5600040) {
					// Instruction: 13: 11010101011sssssPP-ttttt010ddddd | Rd = sub (Rt.H, Rs.L) :<<16
					hi->instruction = HEX_INS_RD___SUB__RT_H__RS_L_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = sub (R%d.H, R%d.L) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5600060) {
					// Instruction: 13: 11010101011sssssPP-ttttt011ddddd | Rd = sub (Rt.H, Rs.H) :<<16
					hi->instruction = HEX_INS_RD___SUB__RT_H__RS_H_____16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					sprintf(hi->mnem, "R%d = sub (R%d.H, R%d.H) :<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x5600080) {
					// Instruction: 13: 11010101011sssssPP-ttttt100ddddd | Rd = sub (Rt.L, Rs.L) :sat:<<16
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_L___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.L) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x56000a0) {
					// Instruction: 13: 11010101011sssssPP-ttttt101ddddd | Rd = sub (Rt.L, Rs.H) :sat:<<16
					hi->instruction = HEX_INS_RD___SUB__RT_L__RS_H___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.L, R%d.H) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x56000c0) {
					// Instruction: 13: 11010101011sssssPP-ttttt110ddddd | Rd = sub (Rt.H, Rs.L) :sat:<<16
					hi->instruction = HEX_INS_RD___SUB__RT_H__RS_L___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.H, R%d.L) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x56000e0) {
					// Instruction: 13: 11010101011sssssPP-ttttt111ddddd | Rd = sub (Rt.H, Rs.H) :sat:<<16
					hi->instruction = HEX_INS_RD___SUB__RT_H__RS_H___SAT___16;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LSH16; // :<<16
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d.H, R%d.H) :sat:<<16", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3000040) {
					// Instruction: 13: 11010011000sssssPP-ttttt010ddddd | Rdd = vaddh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VADDH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaddh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3000060) {
					// Instruction: 13: 11010011000sssssPP-ttttt011ddddd | Rdd = vaddh (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VADDH__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vaddh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3000080) {
					// Instruction: 13: 11010011000sssssPP-ttttt100ddddd | Rdd = vadduh (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VADDUH__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vadduh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3000000) {
					// Instruction: 13: 11010011000sssssPP-ttttt000ddddd | Rdd = vaddub (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VADDUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaddub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3000020) {
					// Instruction: 13: 11010011000sssssPP-ttttt001ddddd | Rdd = vaddub (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VADDUB__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vaddub (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x30000a0) {
					// Instruction: 13: 11010011000sssssPP-ttttt101ddddd | Rdd = vaddw (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VADDW__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vaddw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x30000c0) {
					// Instruction: 13: 11010011000sssssPP-ttttt110ddddd | Rdd = vaddw (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VADDW__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vaddw (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3400040) {
					// Instruction: 13: 11010011010sssssPP-ttttt010ddddd | Rdd = vavgh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VAVGH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vavgh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3400060) {
					// Instruction: 13: 11010011010sssssPP-ttttt011ddddd | Rdd = vavgh (Rss, Rtt) :rnd
					hi->instruction = HEX_INS_RDD___VAVGH__RSS__RTT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = vavgh (R%d:R%d, R%d:R%d) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3400080) {
					// Instruction: 13: 11010011010sssssPP-ttttt100ddddd | Rdd = vavgh (Rss, Rtt) :crnd
					hi->instruction = HEX_INS_RDD___VAVGH__RSS__RTT___CRND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CRND; // :crnd
					sprintf(hi->mnem, "R%d:R%d = vavgh (R%d:R%d, R%d:R%d) :crnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x34000a0) {
					// Instruction: 13: 11010011010sssssPP-ttttt101ddddd | Rdd = vavguh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VAVGUH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vavguh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x34000c0) {
					// Instruction: 13: 11010011010sssssPP-ttttt11-ddddd | Rdd = vavguh (Rss, Rtt) :rnd
					hi->instruction = HEX_INS_RDD___VAVGUH__RSS__RTT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = vavguh (R%d:R%d, R%d:R%d) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3800000) {
					// Instruction: 13: 11010011100sssssPP-ttttt000ddddd | Rdd = vnavgh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VNAVGH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vnavgh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3800020) {
					// Instruction: 13: 11010011100sssssPP-ttttt001ddddd | Rdd = vnavgh (Rtt, Rss) :rnd:sat
					hi->instruction = HEX_INS_RDD___VNAVGH__RTT__RSS___RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vnavgh (R%d:R%d, R%d:R%d) :rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3800040) {
					// Instruction: 13: 11010011100sssssPP-ttttt010ddddd | Rdd = vnavgh (Rtt, Rss) :crnd:sat
					hi->instruction = HEX_INS_RDD___VNAVGH__RTT__RSS___CRND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CRND; // :crnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vnavgh (R%d:R%d, R%d:R%d) :crnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3400000) {
					// Instruction: 13: 11010011010sssssPP-ttttt000ddddd | Rdd = vavgub (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VAVGUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vavgub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3400020) {
					// Instruction: 13: 11010011010sssssPP-ttttt001ddddd | Rdd = vavgub (Rss, Rtt) :rnd
					hi->instruction = HEX_INS_RDD___VAVGUB__RSS__RTT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = vavgub (R%d:R%d, R%d:R%d) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3600000) {
					// Instruction: 13: 11010011011sssssPP-ttttt000ddddd | Rdd = vavgw (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VAVGW__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vavgw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3600020) {
					// Instruction: 13: 11010011011sssssPP-ttttt001ddddd | Rdd = vavgw (Rss, Rtt) :rnd
					hi->instruction = HEX_INS_RDD___VAVGW__RSS__RTT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = vavgw (R%d:R%d, R%d:R%d) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3600040) {
					// Instruction: 13: 11010011011sssssPP-ttttt010ddddd | Rdd = vavgw (Rss, Rtt) :crnd
					hi->instruction = HEX_INS_RDD___VAVGW__RSS__RTT___CRND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CRND; // :crnd
					sprintf(hi->mnem, "R%d:R%d = vavgw (R%d:R%d, R%d:R%d) :crnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3600060) {
					// Instruction: 13: 11010011011sssssPP-ttttt011ddddd | Rdd = vavguw (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VAVGUW__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vavguw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3600080) {
					// Instruction: 13: 11010011011sssssPP-ttttt100ddddd | Rdd = vavguw (Rss, Rtt) :rnd
					hi->instruction = HEX_INS_RDD___VAVGUW__RSS__RTT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = vavguw (R%d:R%d, R%d:R%d) :rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3800060) {
					// Instruction: 13: 11010011100sssssPP-ttttt011ddddd | Rdd = vnavgw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VNAVGW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vnavgw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x3800080) {
					// Instruction: 13: 11010011100sssssPP-ttttt10-ddddd | Rdd = vnavgw (Rtt, Rss) :rnd:sat
					hi->instruction = HEX_INS_RDD___VNAVGW__RTT__RSS___RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vnavgw (R%d:R%d, R%d:R%d) :rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000c0) == 0x38000c0) {
					// Instruction: 13: 11010011100sssssPP-ttttt11-ddddd | Rdd = vnavgw (Rtt, Rss) :crnd:sat
					hi->instruction = HEX_INS_RDD___VNAVGW__RTT__RSS___CRND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_CRND; // :crnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vnavgw (R%d:R%d, R%d:R%d) :crnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c00000) {
					// Instruction: 13: 11010011110sssssPP-ttttt000ddddd | Rdd = vmaxub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXUB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c000c0) {
					// Instruction: 13: 11010011110sssssPP-ttttt110ddddd | Rdd = vmaxb (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c00020) {
					// Instruction: 13: 11010011110sssssPP-ttttt001ddddd | Rdd = vmaxh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c00040) {
					// Instruction: 13: 11010011110sssssPP-ttttt010ddddd | Rdd = vmaxuh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXUH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxuh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a000a0) {
					// Instruction: 13: 11010011101sssssPP-ttttt101ddddd | Rdd = vmaxuw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXUW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxuw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c00060) {
					// Instruction: 13: 11010011110sssssPP-ttttt011ddddd | Rdd = vmaxw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMAXW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmaxw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a00000) {
					// Instruction: 13: 11010011101sssssPP-ttttt000ddddd | Rdd = vminub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINUB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3c000e0) {
					// Instruction: 13: 11010011110sssssPP-ttttt111ddddd | Rdd = vminb (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a00020) {
					// Instruction: 13: 11010011101sssssPP-ttttt001ddddd | Rdd = vminh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a00040) {
					// Instruction: 13: 11010011101sssssPP-ttttt010ddddd | Rdd = vminuh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINUH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminuh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a00060) {
					// Instruction: 13: 11010011101sssssPP-ttttt011ddddd | Rdd = vminw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3a00080) {
					// Instruction: 13: 11010011101sssssPP-ttttt100ddddd | Rdd = vminuw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VMINUW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vminuw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3200040) {
					// Instruction: 13: 11010011001sssssPP-ttttt010ddddd | Rdd = vsubh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VSUBH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsubh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3200060) {
					// Instruction: 13: 11010011001sssssPP-ttttt011ddddd | Rdd = vsubh (Rtt, Rss) :sat
					hi->instruction = HEX_INS_RDD___VSUBH__RTT__RSS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vsubh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3200080) {
					// Instruction: 13: 11010011001sssssPP-ttttt100ddddd | Rdd = vsubuh (Rtt, Rss) :sat
					hi->instruction = HEX_INS_RDD___VSUBUH__RTT__RSS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vsubuh (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3200000) {
					// Instruction: 13: 11010011001sssssPP-ttttt000ddddd | Rdd = vsubub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VSUBUB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsubub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x3200020) {
					// Instruction: 13: 11010011001sssssPP-ttttt001ddddd | Rdd = vsubub (Rtt, Rss) :sat
					hi->instruction = HEX_INS_RDD___VSUBUB__RTT__RSS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vsubub (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x32000a0) {
					// Instruction: 13: 11010011001sssssPP-ttttt101ddddd | Rdd = vsubw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VSUBW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vsubw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x32000c0) {
					// Instruction: 13: 11010011001sssssPP-ttttt110ddddd | Rdd = vsubw (Rtt, Rss) :sat
					hi->instruction = HEX_INS_RDD___VSUBW__RTT__RSS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vsubw (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x0) {
					// Instruction: 13: 11010000---sssssPP-ttttt---ddddd | Rd = parity (Rss, Rtt)
					hi->instruction = HEX_INS_RD___PARITY__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = parity (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x5e00000) {
					// Instruction: 13: 11010101111sssssPP-ttttt---ddddd | Rd = parity (Rs, Rt)
					hi->instruction = HEX_INS_RD___PARITY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = parity (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf200000) == 0x4200000) {
					// Instruction: 13: 11010100--1sssssPP-ttttt---ddddd | Rdd = bitsplit (Rs, Rt)
					hi->instruction = HEX_INS_RDD___BITSPLIT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = bitsplit (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe01c18) == 0xc800010) {
					// Instruction: 13: 11011100100sssssPP-000iiiii10-dd | Pd = dfclass (Rss, #u5)
					hi->instruction = HEX_INS_PD___DFCLASS__RSS___U5_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x3e0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = dfclass (R%d:R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2e00000) {
					// Instruction: 13: 11010010111sssssPP-ttttt000---dd | Pd = cmp.eq (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_EQ__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.eq (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2e00020) {
					// Instruction: 13: 11010010111sssssPP-ttttt001---dd | Pd = cmp.gt (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_GT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gt (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2e00040) {
					// Instruction: 13: 11010010111sssssPP-ttttt010---dd | Pd = cmp.ge (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_GE__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.ge (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2e00060) {
					// Instruction: 13: 11010010111sssssPP-ttttt011---dd | Pd = cmp.uo (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_UO__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.uo (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x6000000) {
					// Instruction: 13: 1101011000i-----PPiiiiiiiiiddddd | Rd = sfmake (#u10) :pos
					hi->instruction = HEX_INS_RD___SFMAKE___U10___POS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_POS; // :pos
					sprintf(hi->mnem, "R%d = sfmake (0x%x) :pos", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x6400000) {
					// Instruction: 13: 1101011001i-----PPiiiiiiiiiddddd | Rd = sfmake (#u10) :neg
					hi->instruction = HEX_INS_RD___SFMAKE___U10___NEG;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_NEG; // :neg
					sprintf(hi->mnem, "R%d = sfmake (0x%x) :neg", hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x9000000) {
					// Instruction: 13: 1101100100i-----PPiiiiiiiiiddddd | Rdd = dfmake (#u10) :pos
					hi->instruction = HEX_INS_RDD___DFMAKE___U10___POS;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_POS; // :pos
					sprintf(hi->mnem, "R%d:R%d = dfmake (0x%x) :pos", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xfc00000) == 0x9400000) {
					// Instruction: 13: 1101100101i-----PPiiiiiiiiiddddd | Rdd = dfmake (#u10) :neg
					hi->instruction = HEX_INS_RDD___DFMAKE___U10___NEG;
					hi->op_count = 2;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x200000) >> 12) | ((hi_u32 & 0x3fe0) >> 5));
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_NEG; // :neg
					sprintf(hi->mnem, "R%d:R%d = dfmake (0x%x) :neg", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x7000000) {
					// Instruction: 13: 110101110iisssssPPitttttiiiddddd | Rd = add (#u6, mpyi (Rs, Rt))
					hi->instruction = HEX_INS_RD___ADD___U6__MPYI__RS__RT__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (0x%x, mpyi (R%d, R%d))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x8000000) {
					// Instruction: 13: 11011000IiisssssPPidddddiiiIIIII | Rd = add (#u6, mpyi (Rs, #U6))
					hi->instruction = HEX_INS_RD___ADD___U6__MPYI__RS___U6__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5));
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x800000) >> 18) | ((hi_u32 & 0x1f) >> 0));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (0x%x, mpyi (R%d, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xf000000) {
					// Instruction: 13: 110111110iisssssPPidddddiiiuuuuu | Rd = add (Ru, mpyi (#u6:2, Rs))
					hi->instruction = HEX_INS_RD___ADD__RU__MPYI___U6_2__RS__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5)) << 2; // scaled
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d, mpyi (0x%x, R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0xf800000) {
					// Instruction: 13: 110111111iisssssPPidddddiiiuuuuu | Rd = add (Ru, mpyi (Rs, #u6))
					hi->instruction = HEX_INS_RD___ADD__RU__MPYI__RS___U6__;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_IMM;
					hi->ops[3].op.imm = (((hi_u32 & 0x600000) >> 17) | ((hi_u32 & 0x2000) >> 10) | ((hi_u32 & 0xe0) >> 5));
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d, mpyi (R%d, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.imm);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2002080) {
					// Instruction: 13: 110100100--sssssPP1ttttt100---dd | Pd = boundscheck (Rss, Rtt) :raw:lo
					hi->instruction = HEX_INS_PD___BOUNDSCHECK__RSS__RTT___RAW_LO;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LO; // :lo
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "P%d = boundscheck (R%d:R%d, R%d:R%d) :raw:lo", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x20020a0) {
					// Instruction: 13: 110100100--sssssPP1ttttt101---dd | Pd = boundscheck (Rss, Rtt) :raw:hi
					hi->instruction = HEX_INS_PD___BOUNDSCHECK__RSS__RTT___RAW_HI;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_HI; // :hi
					hi->pf |= HEX_PF_RAW; // :raw
					sprintf(hi->mnem, "P%d = boundscheck (R%d:R%d, R%d:R%d) :raw:hi", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf600018) == 0xd000000) {
					// Instruction: 13: 11011101-00sssssPP-iiiiiiii00-dd | Pd = cmpb.eq (Rs, #u8)
					hi->instruction = HEX_INS_PD___CMPB_EQ__RS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmpb.eq (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf600018) == 0xd200000) {
					// Instruction: 13: 11011101-01sssssPP-iiiiiiii00-dd | Pd = cmpb.gt (Rs, #s8)
					hi->instruction = HEX_INS_PD___CMPB_GT__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmpb.gt (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf601018) == 0xd400000) {
					// Instruction: 13: 11011101-10sssssPP-0iiiiiii00-dd | Pd = cmpb.gtu (Rs, #u7)
					hi->instruction = HEX_INS_PD___CMPB_GTU__RS___U7_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xfe0) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmpb.gtu (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf600018) == 0xd000008) {
					// Instruction: 13: 11011101-00sssssPP-iiiiiiii01-dd | Pd = cmph.eq (Rs, #s8)
					hi->instruction = HEX_INS_PD___CMPH_EQ__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmph.eq (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf600018) == 0xd200008) {
					// Instruction: 13: 11011101-01sssssPP-iiiiiiii01-dd | Pd = cmph.gt (Rs, #s8)
					hi->instruction = HEX_INS_PD___CMPH_GT__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmph.gt (R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf601018) == 0xd400008) {
					// Instruction: 13: 11011101-10sssssPP-0iiiiiii01-dd | Pd = cmph.gtu (Rs, #u7)
					hi->instruction = HEX_INS_PD___CMPH_GTU__RS___U7_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xfe0) >> 5);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "P%d = cmph.gtu (R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2800000) {
					// Instruction: 13: 11010010100sssssPP-ttttt000---dd | Pd = cmp.eq (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_EQ__RSS__RTT__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.eq (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2800040) {
					// Instruction: 13: 11010010100sssssPP-ttttt010---dd | Pd = cmp.gt (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_GT__RSS__RTT__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gt (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe000e0) == 0x2800080) {
					// Instruction: 13: 11010010100sssssPP-ttttt100---dd | Pd = cmp.gtu (Rss, Rtt)
					hi->instruction = HEX_INS_PD___CMP_GTU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gtu (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2002060) {
					// Instruction: 13: 110100100--sssssPP1ttttt011---dd | Pd = tlbmatch (Rss, Rt)
					hi->instruction = HEX_INS_PD___TLBMATCH__RSS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = tlbmatch (R%d:R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2000060) {
					// Instruction: 13: 110100100--sssssPP0ttttt011---dd | Pd = vcmph.eq (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPH_EQ__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.eq (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2000080) {
					// Instruction: 13: 110100100--sssssPP0ttttt100---dd | Pd = vcmph.gt (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPH_GT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.gt (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x20000a0) {
					// Instruction: 13: 110100100--sssssPP0ttttt101---dd | Pd = vcmph.gtu (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPH_GTU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.gtu (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc000008) {
					// Instruction: 13: 11011100000sssssPP-iiiiiiii01-dd | Pd = vcmph.eq (Rss, #s8)
					hi->instruction = HEX_INS_PD___VCMPH_EQ__RSS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.eq (R%d:R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc200008) {
					// Instruction: 13: 11011100001sssssPP-iiiiiiii01-dd | Pd = vcmph.gt (Rss, #s8)
					hi->instruction = HEX_INS_PD___VCMPH_GT__RSS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.gt (R%d:R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01018) == 0xc400008) {
					// Instruction: 13: 11011100010sssssPP-0iiiiiii01-dd | Pd = vcmph.gtu (Rss, #u7)
					hi->instruction = HEX_INS_PD___VCMPH_GTU__RSS___U7_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xfe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmph.gtu (R%d:R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2002000) {
					// Instruction: 13: 110100100--sssssPP1ttttt000---dd | Pd = any8 (vcmpb.eq (Rss, Rtt))
					hi->instruction = HEX_INS_PD___ANY8__VCMPB_EQ__RSS__RTT__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = any8 (vcmpb.eq (R%d:R%d, R%d:R%d))", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x20000c0) {
					// Instruction: 13: 110100100--sssssPP0ttttt110---dd | Pd = vcmpb.eq (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPB_EQ__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.eq (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x20000e0) {
					// Instruction: 13: 110100100--sssssPP0ttttt111---dd | Pd = vcmpb.gtu (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPB_GTU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.gtu (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2002040) {
					// Instruction: 13: 110100100--sssssPP1ttttt010---dd | Pd = vcmpb.gt (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPB_GT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.gt (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc000000) {
					// Instruction: 13: 11011100000sssssPP-iiiiiiii00-dd | Pd = vcmpb.eq (Rss, #u8)
					hi->instruction = HEX_INS_PD___VCMPB_EQ__RSS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.eq (R%d:R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc200000) {
					// Instruction: 13: 11011100001sssssPP-iiiiiiii00-dd | Pd = vcmpb.gt (Rss, #s8)
					hi->instruction = HEX_INS_PD___VCMPB_GT__RSS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.gt (R%d:R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01018) == 0xc400000) {
					// Instruction: 13: 11011100010sssssPP-0iiiiiii00-dd | Pd = vcmpb.gtu (Rss, #u7)
					hi->instruction = HEX_INS_PD___VCMPB_GTU__RSS___U7_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xfe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpb.gtu (R%d:R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2000000) {
					// Instruction: 13: 110100100--sssssPP0ttttt000---dd | Pd = vcmpw.eq (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPW_EQ__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.eq (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2000020) {
					// Instruction: 13: 110100100--sssssPP0ttttt001---dd | Pd = vcmpw.gt (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPW_GT__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.gt (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf8020e0) == 0x2000040) {
					// Instruction: 13: 110100100--sssssPP0ttttt010---dd | Pd = vcmpw.gtu (Rss, Rtt)
					hi->instruction = HEX_INS_PD___VCMPW_GTU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.gtu (R%d:R%d, R%d:R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc000010) {
					// Instruction: 13: 11011100000sssssPP-iiiiiiii10-dd | Pd = vcmpw.eq (Rss, #s8)
					hi->instruction = HEX_INS_PD___VCMPW_EQ__RSS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.eq (R%d:R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe00018) == 0xc200010) {
					// Instruction: 13: 11011100001sssssPP-iiiiiiii10-dd | Pd = vcmpw.gt (Rss, #s8)
					hi->instruction = HEX_INS_PD___VCMPW_GT__RSS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.gt (R%d:R%d, %d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe01018) == 0xc400010) {
					// Instruction: 13: 11011100010sssssPP-0iiiiiii10-dd | Pd = vcmpw.gtu (Rss, #u7)
					hi->instruction = HEX_INS_PD___VCMPW_GTU__RSS___U7_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0xfe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = vcmpw.gtu (R%d:R%d, 0x%x)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x1000000) {
					// Instruction: 13: 11010001---sssssPP-ttttt-uuddddd | Rdd = vmux (Pu, Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VMUX__PU__RSS__RTT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmux (P%d, R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000004) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii0i10- | Rx = add (#u8, asl (Rx, #U5))
					hi->instruction = HEX_INS_RX___ADD___U8__ASL__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = add (0x%x, asl (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000006) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii0i11- | Rx = sub (#u8, asl (Rx, #U5))
					hi->instruction = HEX_INS_RX___SUB___U8__ASL__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = sub (0x%x, asl (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000014) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii1i10- | Rx = add (#u8, lsr (Rx, #U5))
					hi->instruction = HEX_INS_RX___ADD___U8__LSR__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = add (0x%x, lsr (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000016) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii1i11- | Rx = sub (#u8, lsr (Rx, #U5))
					hi->instruction = HEX_INS_RX___SUB___U8__LSR__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = sub (0x%x, lsr (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000000) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii0i00- | Rx = and (#u8, asl (Rx, #U5))
					hi->instruction = HEX_INS_RX___AND___U8__ASL__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = and (0x%x, asl (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000002) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii0i01- | Rx = or (#u8, asl (Rx, #U5))
					hi->instruction = HEX_INS_RX___OR___U8__ASL__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = or (0x%x, asl (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000010) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii1i00- | Rx = and (#u8, lsr (Rx, #U5))
					hi->instruction = HEX_INS_RX___AND___U8__LSR__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = and (0x%x, lsr (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf000016) == 0xe000012) {
					// Instruction: 13: 11011110iiixxxxxPPiIIIIIiii1i01- | Rx = or (#u8, lsr (Rx, #U5))
					hi->instruction = HEX_INS_RX___OR___U8__LSR__RX___U5__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rx
					hi->ops[1].type = HEX_OP_TYPE_IMM;
					hi->ops[1].op.imm = (((hi_u32 & 0xe00000) >> 16) | ((hi_u32 & 0x2000) >> 9) | ((hi_u32 & 0xe0) >> 4) | ((hi_u32 & 0x8) >> 3));
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[1]);
					sprintf(hi->mnem, "R%d = or (0x%x, lsr (Rx, 0x%x))", hi->ops[0].op.reg, hi->ops[1].op.imm, hi->ops[2].op.imm);
					break;
				}
				break;
			}
			case 0xe: {
				if ((hi_u32 & 0xf802000) == 0x2000000) {
					// Instruction: 14: 111000100--sssssPP0iiiiiiiixxxxx | Rx += add (Rs, #s8)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ADD__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d += add (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x2800000) {
					// Instruction: 14: 111000101--sssssPP0iiiiiiiixxxxx | Rx -= add (Rs, #s8)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ADD__RS___S8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					if (hi->ops[2].op.imm & (1 << 7)) {
						hi->ops[2].op.imm |= (0xFFFFFFFF << 7);
					}
					hi->predicate = HEX_NOPRED;
					hex_op_extend(&hi->ops[2]);
					sprintf(hi->mnem, "R%d -= add (R%d, %d)", hi->ops[0].op.reg, hi->ops[1].op.reg, (st32) hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf000020) {
					// Instruction: 14: 11101111000sssssPP0ttttt001xxxxx | Rx += add (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__ADD__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += add (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf800020) {
					// Instruction: 14: 11101111100sssssPP0ttttt001xxxxx | Rx -= add (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__ADD__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= add (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf200000) {
					// Instruction: 14: 11101111001sssssPP0ttttt000xxxxx | Rx |= and (Rs, ~Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__AND__RS___RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= and (R%d, ~R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf200020) {
					// Instruction: 14: 11101111001sssssPP0ttttt001xxxxx | Rx &= and (Rs, ~Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__AND__RS___RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= and (R%d, ~R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf200040) {
					// Instruction: 14: 11101111001sssssPP0ttttt010xxxxx | Rx ^= and (Rs, ~Rt)
					hi->instruction = HEX_INS_RX____AND__RS___RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= and (R%d, ~R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf400000) {
					// Instruction: 14: 11101111010sssssPP0ttttt000xxxxx | Rx &= and (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__AND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= and (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf400020) {
					// Instruction: 14: 11101111010sssssPP0ttttt001xxxxx | Rx &= or (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__OR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= or (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf400040) {
					// Instruction: 14: 11101111010sssssPP0ttttt010xxxxx | Rx &= xor (Rs, Rt)
					hi->instruction = HEX_INS_RX__AND_EQ__XOR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d &= xor (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf400060) {
					// Instruction: 14: 11101111010sssssPP0ttttt011xxxxx | Rx |= and (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__AND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= and (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf800060) {
					// Instruction: 14: 11101111100sssssPP0ttttt011xxxxx | Rx ^= xor (Rs, Rt)
					hi->instruction = HEX_INS_RX____XOR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= xor (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xfc00000) {
					// Instruction: 14: 11101111110sssssPP0ttttt000xxxxx | Rx |= or (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__OR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= or (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xfc00020) {
					// Instruction: 14: 11101111110sssssPP0ttttt001xxxxx | Rx |= xor (Rs, Rt)
					hi->instruction = HEX_INS_RX__OR_EQ__XOR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d |= xor (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xfc00040) {
					// Instruction: 14: 11101111110sssssPP0ttttt010xxxxx | Rx ^= and (Rs, Rt)
					hi->instruction = HEX_INS_RX____AND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= and (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xfc00060) {
					// Instruction: 14: 11101111110sssssPP0ttttt011xxxxx | Rx ^= or (Rs, Rt)
					hi->instruction = HEX_INS_RX____OR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d ^= or (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf000060) {
					// Instruction: 14: 11101111000sssssPP0ttttt011xxxxx | Rx += sub (Rt, Rs)
					hi->instruction = HEX_INS_RX__PLUS_EQ__SUB__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += sub (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8a00000) {
					// Instruction: 14: 11101000101sssssPP0ttttt000ddddd | Rdd = vabsdiffub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VABSDIFFUB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsdiffub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8e00000) {
					// Instruction: 14: 11101000111sssssPP0ttttt000ddddd | Rdd = vabsdiffb (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VABSDIFFB__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsdiffb (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8600000) {
					// Instruction: 14: 11101000011sssssPP0ttttt000ddddd | Rdd = vabsdiffh (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VABSDIFFH__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsdiffh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8200000) {
					// Instruction: 14: 11101000001sssssPP0ttttt000ddddd | Rdd = vabsdiffw (Rtt, Rss)
					hi->instruction = HEX_INS_RDD___VABSDIFFW__RTT__RSS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vabsdiffw (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xaa00000) {
					// Instruction: 14: 11101010101sssssPP0ttttt0eexxxxx | Rxx, Pe = vacsh (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PE___VACSH__RSS__RTT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d, P%d = vacsh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8400020) {
					// Instruction: 14: 11101000010sssssPP0ttttt001ddddd | Rdd = vraddub (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRADDUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vraddub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa400020) {
					// Instruction: 14: 11101010010sssssPP0ttttt001xxxxx | Rxx += vraddub (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRADDUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vraddub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf802060) == 0x9000020) {
					// Instruction: 14: 111010010--sssssPP0ttttt-01ddddd | Rd = vradduh (Rss, Rtt)
					hi->instruction = HEX_INS_RD___VRADDUH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vradduh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa020e0) == 0x92000e0) {
					// Instruction: 14: 111010010-1sssssPP0ttttt111ddddd | Rd = vraddh (Rss, Rtt)
					hi->instruction = HEX_INS_RD___VRADDH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vraddh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xae00000) {
					// Instruction: 14: 11101010111sssssPP0ttttt0eeddddd | Rdd, Pe = vminub (Rtt, Rss)
					hi->instruction = HEX_INS_RDD__PE___VMINUB__RTT__RSS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].attr |= HEX_OP_REG_PAIR;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d, P%d = vminub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, hi->ops[3].op.reg + 1, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8400040) {
					// Instruction: 14: 11101000010sssssPP0ttttt010ddddd | Rdd = vrsadub (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRSADUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrsadub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa400040) {
					// Instruction: 14: 11101010010sssssPP0ttttt010xxxxx | Rxx += vrsadub (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRSADUB__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrsadub (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x50000c0) {
					// Instruction: 14: 11100101N00sssssPP0ttttt110ddddd | Rdd = cmpy (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___CMPY__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = cmpy (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x54000c0) {
					// Instruction: 14: 11100101N10sssssPP0ttttt110ddddd | Rdd = cmpy (Rs, Rt *) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___CMPY__RS__RT________N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = cmpy (R%d, R%d *) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x70000c0) {
					// Instruction: 14: 11100111N00sssssPP0ttttt110xxxxx | Rxx += cmpy (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__CMPY__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += cmpy (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x70000e0) {
					// Instruction: 14: 11100111N00sssssPP0ttttt111xxxxx | Rxx -= cmpy (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__MINUS_EQ__CMPY__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d -= cmpy (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x74000c0) {
					// Instruction: 14: 11100111N10sssssPP0ttttt110xxxxx | Rxx += cmpy (Rs, Rt *) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__CMPY__RS__RT________N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += cmpy (R%d, R%d *) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x74000e0) {
					// Instruction: 14: 11100111N10sssssPP0ttttt111xxxxx | Rxx -= cmpy (Rs, Rt *) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__MINUS_EQ__CMPY__RS__RT________N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d -= cmpy (R%d, R%d *) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5000020) {
					// Instruction: 14: 11100101000sssssPP0ttttt001ddddd | Rdd = cmpyi (Rs, Rt)
					hi->instruction = HEX_INS_RDD___CMPYI__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = cmpyi (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5000040) {
					// Instruction: 14: 11100101000sssssPP0ttttt010ddddd | Rdd = cmpyr (Rs, Rt)
					hi->instruction = HEX_INS_RDD___CMPYR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = cmpyr (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7000020) {
					// Instruction: 14: 11100111000sssssPP0ttttt001xxxxx | Rxx += cmpyi (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__CMPYI__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += cmpyi (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7000040) {
					// Instruction: 14: 11100111000sssssPP0ttttt010xxxxx | Rxx += cmpyr (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__CMPYR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += cmpyr (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xd2000c0) {
					// Instruction: 14: 11101101N01sssssPP0ttttt110ddddd | Rd = cmpy (Rs, Rt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___CMPY__RS__RT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpy (R%d, R%d) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xd6000c0) {
					// Instruction: 14: 11101101N11sssssPP0ttttt110ddddd | Rd = cmpy (Rs, Rt *) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___CMPY__RS__RT________N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = cmpy (R%d, R%d *) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x82000c0) {
					// Instruction: 14: 11101000N01sssssPP0ttttt110ddddd | Rdd = vcmpyr (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VCMPYR__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vcmpyr (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x84000c0) {
					// Instruction: 14: 11101000N10sssssPP0ttttt110ddddd | Rdd = vcmpyi (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VCMPYI__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vcmpyi (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa200080) {
					// Instruction: 14: 11101010001sssssPP0ttttt100xxxxx | Rxx += vcmpyr (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VCMPYR__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vcmpyr (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa400080) {
					// Instruction: 14: 11101010010sssssPP0ttttt100xxxxx | Rxx += vcmpyi (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VCMPYI__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vcmpyi (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8000000) {
					// Instruction: 14: 11101000000sssssPP0ttttt000ddddd | Rdd = vrcmpyi (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRCMPYI__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrcmpyi (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8000020) {
					// Instruction: 14: 11101000000sssssPP0ttttt001ddddd | Rdd = vrcmpyr (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRCMPYR__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrcmpyr (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8400000) {
					// Instruction: 14: 11101000010sssssPP0ttttt000ddddd | Rdd = vrcmpyi (Rss, Rtt *)
					hi->instruction = HEX_INS_RDD___VRCMPYI__RSS__RTT___;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrcmpyi (R%d:R%d, R%d:R%d *)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8600020) {
					// Instruction: 14: 11101000011sssssPP0ttttt001ddddd | Rdd = vrcmpyr (Rss, Rtt *)
					hi->instruction = HEX_INS_RDD___VRCMPYR__RSS__RTT___;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrcmpyr (R%d:R%d, R%d:R%d *)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa000000) {
					// Instruction: 14: 11101010000sssssPP0ttttt000xxxxx | Rxx += vrcmpyi (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYI__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcmpyi (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa000020) {
					// Instruction: 14: 11101010000sssssPP0ttttt001xxxxx | Rxx += vrcmpyr (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYR__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcmpyr (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa400000) {
					// Instruction: 14: 11101010010sssssPP0ttttt000xxxxx | Rxx += vrcmpyi (Rss, Rtt *)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYI__RSS__RTT___;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcmpyi (R%d:R%d, R%d:R%d *)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa600020) {
					// Instruction: 14: 11101010011sssssPP0ttttt001xxxxx | Rxx += vrcmpyr (Rss, Rtt *)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYR__RSS__RTT___;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrcmpyr (R%d:R%d, R%d:R%d *)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8a00080) {
					// Instruction: 14: 11101000101sssssPP0ttttt100ddddd | Rdd = vrcmpys (Rss, Rtt) :<<1:sat:raw:hi
					hi->instruction = HEX_INS_RDD___VRCMPYS__RSS__RTT_____1_SAT_RAW_HI;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_HI; // :hi
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vrcmpys (R%d:R%d, R%d:R%d) :<<1:sat:raw:hi", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8e00080) {
					// Instruction: 14: 11101000111sssssPP0ttttt100ddddd | Rdd = vrcmpys (Rss, Rtt) :<<1:sat:raw:lo
					hi->instruction = HEX_INS_RDD___VRCMPYS__RSS__RTT_____1_SAT_RAW_LO;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LO; // :lo
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vrcmpys (R%d:R%d, R%d:R%d) :<<1:sat:raw:lo", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xaa00080) {
					// Instruction: 14: 11101010101sssssPP0ttttt100xxxxx | Rxx += vrcmpys (Rss, Rtt) :<<1:sat:raw:hi
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYS__RSS__RTT_____1_SAT_RAW_HI;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_HI; // :hi
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vrcmpys (R%d:R%d, R%d:R%d) :<<1:sat:raw:hi", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xae00080) {
					// Instruction: 14: 11101010111sssssPP0ttttt100xxxxx | Rxx += vrcmpys (Rss, Rtt) :<<1:sat:raw:lo
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRCMPYS__RSS__RTT_____1_SAT_RAW_LO;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LO; // :lo
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vrcmpys (R%d:R%d, R%d:R%d) :<<1:sat:raw:lo", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa020e0) == 0x9a000c0) {
					// Instruction: 14: 111010011-1sssssPP0ttttt110ddddd | Rd = vrcmpys (Rss, Rtt) :<<1:rnd:sat:raw:hi
					hi->instruction = HEX_INS_RD___VRCMPYS__RSS__RTT_____1_RND_SAT_RAW_HI;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_HI; // :hi
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vrcmpys (R%d:R%d, R%d:R%d) :<<1:rnd:sat:raw:hi", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa020e0) == 0x9a000e0) {
					// Instruction: 14: 111010011-1sssssPP0ttttt111ddddd | Rd = vrcmpys (Rss, Rtt) :<<1:rnd:sat:raw:lo
					hi->instruction = HEX_INS_RD___VRCMPYS__RSS__RTT_____1_RND_SAT_RAW_LO;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_LO; // :lo
					hi->pf |= HEX_PF_RAW; // :raw
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vrcmpys (R%d:R%d, R%d:R%d) :<<1:rnd:sat:raw:lo", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb000000) {
					// Instruction: 14: 11101011000sssssPP0ttttt000ddddd | Rd = sfadd (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFADD__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sfadd (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xbc00000) {
					// Instruction: 14: 11101011110sssssPP0ttttt000ddddd | Rd = sffixupn (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFFIXUPN__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sffixupn (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xbc00020) {
					// Instruction: 14: 11101011110sssssPP0ttttt001ddddd | Rd = sffixupd (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFFIXUPD__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sffixupd (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf000080) {
					// Instruction: 14: 11101111000sssssPP0ttttt100xxxxx | Rx += sfmpy (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__SFMPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += sfmpy (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf0000a0) {
					// Instruction: 14: 11101111000sssssPP0ttttt101xxxxx | Rx -= sfmpy (Rs, Rt)
					hi->instruction = HEX_INS_RX__MINUS_EQ__SFMPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= sfmpy (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xf600080) {
					// Instruction: 14: 11101111011sssssPP0ttttt1uuxxxxx | Rx += sfmpy (Rs, Rt, Pu) :scale
					hi->instruction = HEX_INS_RX__PLUS_EQ__SFMPY__RS__RT__PU___SCALE;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[3].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SCALE; // :scale
					sprintf(hi->mnem, "R%d += sfmpy (R%d, R%d, P%d) :scale", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.pred);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf0000c0) {
					// Instruction: 14: 11101111000sssssPP0ttttt110xxxxx | Rx += sfmpy (Rs, Rt) :lib
					hi->instruction = HEX_INS_RX__PLUS_EQ__SFMPY__RS__RT___LIB;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += sfmpy (R%d, R%d) :lib", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf0000e0) {
					// Instruction: 14: 11101111000sssssPP0ttttt111xxxxx | Rx -= sfmpy (Rs, Rt) :lib
					hi->instruction = HEX_INS_RX__MINUS_EQ__SFMPY__RS__RT___LIB;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= sfmpy (R%d, R%d) :lib", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb800000) {
					// Instruction: 14: 11101011100sssssPP0ttttt000ddddd | Rd = sfmax (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFMAX__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sfmax (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb800020) {
					// Instruction: 14: 11101011100sssssPP0ttttt001ddddd | Rd = sfmin (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFMIN__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sfmin (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb400000) {
					// Instruction: 14: 11101011010sssssPP0ttttt000ddddd | Rd = sfmpy (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFMPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sfmpy (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe02080) == 0xbe00080) {
					// Instruction: 14: 11101011111sssssPP0ttttt1eeddddd | Rd, Pe = sfrecipa (Rs, Rt)
					hi->instruction = HEX_INS_RD__PE___SFRECIPA__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d, P%d = sfrecipa (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xb000020) {
					// Instruction: 14: 11101011000sssssPP0ttttt001ddddd | Rd = sfsub (Rs, Rt)
					hi->instruction = HEX_INS_RD___SFSUB__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sfsub (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3000000) {
					// Instruction: 14: 11100011000sssssPP-yyyyy---uuuuu | Ry = add (Ru, mpyi (Ry, Rs))
					hi->instruction = HEX_INS_RY___ADD__RU__MPYI__RY__RS__;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f00) >> 8); // Ry
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Ru
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d, mpyi (Ry, R%d))", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x0) {
					// Instruction: 14: 111000000--sssssPP0iiiiiiiiddddd | Rd = + mpyi (Rs, #u8)
					hi->instruction = HEX_INS_RD__EQ_PLUS__MPYI__RS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = + mpyi (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x800000) {
					// Instruction: 14: 111000001--sssssPP0iiiiiiiiddddd | Rd = - mpyi (Rs, #u8)
					hi->instruction = HEX_INS_RD__EQ_MINUS__MPYI__RS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = - mpyi (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x1000000) {
					// Instruction: 14: 111000010--sssssPP0iiiiiiiixxxxx | Rx += mpyi (Rs, #u8)
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYI__RS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyi (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xf802000) == 0x1800000) {
					// Instruction: 14: 111000011--sssssPP0iiiiiiiixxxxx | Rx -= mpyi (Rs, #u8)
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPYI__RS___U8_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_IMM;
					hi->ops[2].op.imm = (((hi_u32) & 0x1fe0) >> 5);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpyi (R%d, 0x%x)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.imm);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xd000000) {
					// Instruction: 14: 11101101000sssssPP0ttttt000ddddd | Rd = mpyi (Rs, Rt)
					hi->instruction = HEX_INS_RD___MPYI__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyi (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf000000) {
					// Instruction: 14: 11101111000sssssPP0ttttt000xxxxx | Rx += mpyi (Rs, Rt)
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYI__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyi (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x80000a0) {
					// Instruction: 14: 11101000N00sssssPP0ttttt101ddddd | Rdd = vmpyweh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYWEH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyweh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x80000e0) {
					// Instruction: 14: 11101000N00sssssPP0ttttt111ddddd | Rdd = vmpywoh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYWOH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpywoh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x82000a0) {
					// Instruction: 14: 11101000N01sssssPP0ttttt101ddddd | Rdd = vmpyweh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RDD___VMPYWEH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyweh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x82000e0) {
					// Instruction: 14: 11101000N01sssssPP0ttttt111ddddd | Rdd = vmpywoh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RDD___VMPYWOH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpywoh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa0000a0) {
					// Instruction: 14: 11101010N00sssssPP0ttttt101xxxxx | Rxx += vmpyweh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWEH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyweh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa0000e0) {
					// Instruction: 14: 11101010N00sssssPP0ttttt111xxxxx | Rxx += vmpywoh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWOH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpywoh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa2000a0) {
					// Instruction: 14: 11101010N01sssssPP0ttttt101xxxxx | Rxx += vmpyweh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWEH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyweh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa2000e0) {
					// Instruction: 14: 11101010N01sssssPP0ttttt111xxxxx | Rxx += vmpywoh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWOH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpywoh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x84000a0) {
					// Instruction: 14: 11101000N10sssssPP0ttttt101ddddd | Rdd = vmpyweuh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYWEUH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyweuh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x84000e0) {
					// Instruction: 14: 11101000N10sssssPP0ttttt111ddddd | Rdd = vmpywouh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYWOUH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpywouh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x86000a0) {
					// Instruction: 14: 11101000N11sssssPP0ttttt101ddddd | Rdd = vmpyweuh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RDD___VMPYWEUH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyweuh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x86000e0) {
					// Instruction: 14: 11101000N11sssssPP0ttttt111ddddd | Rdd = vmpywouh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RDD___VMPYWOUH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpywouh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa4000a0) {
					// Instruction: 14: 11101010N10sssssPP0ttttt101xxxxx | Rxx += vmpyweuh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWEUH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyweuh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa4000e0) {
					// Instruction: 14: 11101010N10sssssPP0ttttt111xxxxx | Rxx += vmpywouh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWOUH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpywouh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa6000a0) {
					// Instruction: 14: 11101010N11sssssPP0ttttt101xxxxx | Rxx += vmpyweuh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWEUH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyweuh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa6000e0) {
					// Instruction: 14: 11101010N11sssssPP0ttttt111xxxxx | Rxx += vmpywouh (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYWOUH__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpywouh (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4000000) {
					// Instruction: 14: 11100100N00sssssPP-ttttt-00ddddd | Rdd = mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RDD___MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4000020) {
					// Instruction: 14: 11100100N00sssssPP-ttttt-01ddddd | Rdd = mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RDD___MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4000040) {
					// Instruction: 14: 11100100N00sssssPP-ttttt-10ddddd | Rdd = mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RDD___MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4000060) {
					// Instruction: 14: 11100100N00sssssPP-ttttt-11ddddd | Rdd = mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RDD___MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4200000) {
					// Instruction: 14: 11100100N01sssssPP-ttttt-00ddddd | Rdd = mpy (Rs.L, Rt.L) [:<<N]:rnd
					hi->instruction = HEX_INS_RDD___MPY__RS_L__RT_L______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.L, R%d.L) %s:rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4200020) {
					// Instruction: 14: 11100100N01sssssPP-ttttt-01ddddd | Rdd = mpy (Rs.L, Rt.H) [:<<N]:rnd
					hi->instruction = HEX_INS_RDD___MPY__RS_L__RT_H______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.L, R%d.H) %s:rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4200040) {
					// Instruction: 14: 11100100N01sssssPP-ttttt-10ddddd | Rdd = mpy (Rs.H, Rt.L) [:<<N]:rnd
					hi->instruction = HEX_INS_RDD___MPY__RS_H__RT_L______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.H, R%d.L) %s:rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4200060) {
					// Instruction: 14: 11100100N01sssssPP-ttttt-11ddddd | Rdd = mpy (Rs.H, Rt.H) [:<<N]:rnd
					hi->instruction = HEX_INS_RDD___MPY__RS_H__RT_H______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d.H, R%d.H) %s:rnd", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6000000) {
					// Instruction: 14: 11100110N00sssssPP-ttttt000xxxxx | Rxx += mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6000020) {
					// Instruction: 14: 11100110N00sssssPP-ttttt001xxxxx | Rxx += mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6000040) {
					// Instruction: 14: 11100110N00sssssPP-ttttt010xxxxx | Rxx += mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6000060) {
					// Instruction: 14: 11100110N00sssssPP-ttttt011xxxxx | Rxx += mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6200000) {
					// Instruction: 14: 11100110N01sssssPP-ttttt000xxxxx | Rxx -= mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6200020) {
					// Instruction: 14: 11100110N01sssssPP-ttttt001xxxxx | Rxx -= mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6200040) {
					// Instruction: 14: 11100110N01sssssPP-ttttt010xxxxx | Rxx -= mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6200060) {
					// Instruction: 14: 11100110N01sssssPP-ttttt011xxxxx | Rxx -= mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc000000) {
					// Instruction: 14: 11101100N00sssssPP-ttttt000ddddd | Rd = mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc000020) {
					// Instruction: 14: 11101100N00sssssPP-ttttt001ddddd | Rd = mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc000040) {
					// Instruction: 14: 11101100N00sssssPP-ttttt010ddddd | Rd = mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc000060) {
					// Instruction: 14: 11101100N00sssssPP-ttttt011ddddd | Rd = mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc000080) {
					// Instruction: 14: 11101100N00sssssPP-ttttt100ddddd | Rd = mpy (Rs.L, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc0000a0) {
					// Instruction: 14: 11101100N00sssssPP-ttttt101ddddd | Rd = mpy (Rs.L, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc0000c0) {
					// Instruction: 14: 11101100N00sssssPP-ttttt110ddddd | Rd = mpy (Rs.H, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc0000e0) {
					// Instruction: 14: 11101100N00sssssPP-ttttt111ddddd | Rd = mpy (Rs.H, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc200000) {
					// Instruction: 14: 11101100N01sssssPP-ttttt000ddddd | Rd = mpy (Rs.L, Rt.L) [:<<N]:rnd
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_L______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.L) %s:rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc200020) {
					// Instruction: 14: 11101100N01sssssPP-ttttt001ddddd | Rd = mpy (Rs.L, Rt.H) [:<<N]:rnd
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_H______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.H) %s:rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc200040) {
					// Instruction: 14: 11101100N01sssssPP-ttttt010ddddd | Rd = mpy (Rs.H, Rt.L) [:<<N]:rnd
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_L______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.L) %s:rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc200060) {
					// Instruction: 14: 11101100N01sssssPP-ttttt011ddddd | Rd = mpy (Rs.H, Rt.H) [:<<N]:rnd
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_H______N__RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.H) %s:rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc200080) {
					// Instruction: 14: 11101100N01sssssPP-ttttt100ddddd | Rd = mpy (Rs.L, Rt.L) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_L______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.L) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc2000a0) {
					// Instruction: 14: 11101100N01sssssPP-ttttt101ddddd | Rd = mpy (Rs.L, Rt.H) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS_L__RT_H______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.L, R%d.H) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc2000c0) {
					// Instruction: 14: 11101100N01sssssPP-ttttt110ddddd | Rd = mpy (Rs.H, Rt.L) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_L______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.L) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc2000e0) {
					// Instruction: 14: 11101100N01sssssPP-ttttt111ddddd | Rd = mpy (Rs.H, Rt.H) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS_H__RT_H______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d.H, R%d.H) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe000000) {
					// Instruction: 14: 11101110N00sssssPP-ttttt000xxxxx | Rx += mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe000020) {
					// Instruction: 14: 11101110N00sssssPP-ttttt001xxxxx | Rx += mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe000040) {
					// Instruction: 14: 11101110N00sssssPP-ttttt010xxxxx | Rx += mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe000060) {
					// Instruction: 14: 11101110N00sssssPP-ttttt011xxxxx | Rx += mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe000080) {
					// Instruction: 14: 11101110N00sssssPP-ttttt100xxxxx | Rx += mpy (Rs.L, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_L__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d += mpy (R%d.L, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe0000a0) {
					// Instruction: 14: 11101110N00sssssPP-ttttt101xxxxx | Rx += mpy (Rs.L, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_L__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d += mpy (R%d.L, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe0000c0) {
					// Instruction: 14: 11101110N00sssssPP-ttttt110xxxxx | Rx += mpy (Rs.H, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_H__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d += mpy (R%d.H, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe0000e0) {
					// Instruction: 14: 11101110N00sssssPP-ttttt111xxxxx | Rx += mpy (Rs.H, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS_H__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d += mpy (R%d.H, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe200000) {
					// Instruction: 14: 11101110N01sssssPP-ttttt000xxxxx | Rx -= mpy (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpy (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe200020) {
					// Instruction: 14: 11101110N01sssssPP-ttttt001xxxxx | Rx -= mpy (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpy (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe200040) {
					// Instruction: 14: 11101110N01sssssPP-ttttt010xxxxx | Rx -= mpy (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpy (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe200060) {
					// Instruction: 14: 11101110N01sssssPP-ttttt011xxxxx | Rx -= mpy (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpy (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe200080) {
					// Instruction: 14: 11101110N01sssssPP-ttttt100xxxxx | Rx -= mpy (Rs.L, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_L__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d -= mpy (R%d.L, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe2000a0) {
					// Instruction: 14: 11101110N01sssssPP-ttttt101xxxxx | Rx -= mpy (Rs.L, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_L__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d -= mpy (R%d.L, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe2000c0) {
					// Instruction: 14: 11101110N01sssssPP-ttttt110xxxxx | Rx -= mpy (Rs.H, Rt.L) [:<<N]:sat
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_H__RT_L______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d -= mpy (R%d.H, R%d.L) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe2000e0) {
					// Instruction: 14: 11101110N01sssssPP-ttttt111xxxxx | Rx -= mpy (Rs.H, Rt.H) [:<<N]:sat
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS_H__RT_H______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d -= mpy (R%d.H, R%d.H) %s:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4400000) {
					// Instruction: 14: 11100100N10sssssPP-ttttt-00ddddd | Rdd = mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RDD___MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4400020) {
					// Instruction: 14: 11100100N10sssssPP-ttttt-01ddddd | Rdd = mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RDD___MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4400040) {
					// Instruction: 14: 11100100N10sssssPP-ttttt-10ddddd | Rdd = mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RDD___MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf600060) == 0x4400060) {
					// Instruction: 14: 11100100N10sssssPP-ttttt-11ddddd | Rdd = mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RDD___MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6400000) {
					// Instruction: 14: 11100110N10sssssPP-ttttt000xxxxx | Rxx += mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6400020) {
					// Instruction: 14: 11100110N10sssssPP-ttttt001xxxxx | Rxx += mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6400040) {
					// Instruction: 14: 11100110N10sssssPP-ttttt010xxxxx | Rxx += mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6400060) {
					// Instruction: 14: 11100110N10sssssPP-ttttt011xxxxx | Rxx += mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6600000) {
					// Instruction: 14: 11100110N11sssssPP-ttttt000xxxxx | Rxx -= mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6600020) {
					// Instruction: 14: 11100110N11sssssPP-ttttt001xxxxx | Rxx -= mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6600040) {
					// Instruction: 14: 11100110N11sssssPP-ttttt010xxxxx | Rxx -= mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0x6600060) {
					// Instruction: 14: 11100110N11sssssPP-ttttt011xxxxx | Rxx -= mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc400000) {
					// Instruction: 14: 11101100N10sssssPP-ttttt000ddddd | Rd = mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RD___MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc400020) {
					// Instruction: 14: 11101100N10sssssPP-ttttt001ddddd | Rd = mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RD___MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc400040) {
					// Instruction: 14: 11101100N10sssssPP-ttttt010ddddd | Rd = mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RD___MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xc400060) {
					// Instruction: 14: 11101100N10sssssPP-ttttt011ddddd | Rd = mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RD___MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe400000) {
					// Instruction: 14: 11101110N10sssssPP-ttttt000xxxxx | Rx += mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe400020) {
					// Instruction: 14: 11101110N10sssssPP-ttttt001xxxxx | Rx += mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe400040) {
					// Instruction: 14: 11101110N10sssssPP-ttttt010xxxxx | Rx += mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe400060) {
					// Instruction: 14: 11101110N10sssssPP-ttttt011xxxxx | Rx += mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d += mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe600000) {
					// Instruction: 14: 11101110N11sssssPP-ttttt000xxxxx | Rx -= mpyu (Rs.L, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPYU__RS_L__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpyu (R%d.L, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe600020) {
					// Instruction: 14: 11101110N11sssssPP-ttttt001xxxxx | Rx -= mpyu (Rs.L, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPYU__RS_L__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpyu (R%d.L, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe600040) {
					// Instruction: 14: 11101110N11sssssPP-ttttt010xxxxx | Rx -= mpyu (Rs.H, Rt.L) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPYU__RS_H__RT_L______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpyu (R%d.H, R%d.L) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6000e0) == 0xe600060) {
					// Instruction: 14: 11101110N11sssssPP-ttttt011xxxxx | Rx -= mpyu (Rs.H, Rt.H) [:<<N]
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPYU__RS_H__RT_H______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d -= mpyu (R%d.H, R%d.H) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x54000e0) {
					// Instruction: 14: 11100101010sssssPP0ttttt111ddddd | Rdd = pmpyw (Rs, Rt)
					hi->instruction = HEX_INS_RDD___PMPYW__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = pmpyw (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x72000e0) {
					// Instruction: 14: 11100111001sssssPP0ttttt111xxxxx | Rxx ^= pmpyw (Rs, Rt)
					hi->instruction = HEX_INS_RXX____PMPYW__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= pmpyw (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x8200040) {
					// Instruction: 14: 11101000N01sssssPP0ttttt010ddddd | Rdd = vrmpywoh (Rss, Rtt) [:<<N]
					hi->instruction = HEX_INS_RDD___VRMPYWOH__RSS__RTT______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmpywoh (R%d:R%d, R%d:R%d) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x8400080) {
					// Instruction: 14: 11101000N10sssssPP0ttttt100ddddd | Rdd = vrmpyweh (Rss, Rtt) [:<<N]
					hi->instruction = HEX_INS_RDD___VRMPYWEH__RSS__RTT______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmpyweh (R%d:R%d, R%d:R%d) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa2000c0) {
					// Instruction: 14: 11101010N01sssssPP0ttttt110xxxxx | Rxx += vrmpyweh (Rss, Rtt) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRMPYWEH__RSS__RTT______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrmpyweh (R%d:R%d, R%d:R%d) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa6000c0) {
					// Instruction: 14: 11101010N11sssssPP0ttttt110xxxxx | Rxx += vrmpywoh (Rss, Rtt) [:<<N]
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRMPYWOH__RSS__RTT______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrmpywoh (R%d:R%d, R%d:R%d) %s", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xd200020) {
					// Instruction: 14: 11101101001sssssPP0ttttt001ddddd | Rd = mpy (Rs, Rt) :rnd
					hi->instruction = HEX_INS_RD___MPY__RS__RT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d) :rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xd400020) {
					// Instruction: 14: 11101101010sssssPP0ttttt001ddddd | Rd = mpyu (Rs, Rt)
					hi->instruction = HEX_INS_RD___MPYU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpyu (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xd600020) {
					// Instruction: 14: 11101101011sssssPP0ttttt001ddddd | Rd = mpysu (Rs, Rt)
					hi->instruction = HEX_INS_RD___MPYSU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpysu (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xda00000) {
					// Instruction: 14: 11101101101sssssPP0ttttt000ddddd | Rd = mpy (Rs, Rt.H) :<<1:sat
					hi->instruction = HEX_INS_RD___MPY__RS__RT_H_____1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d.H) :<<1:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xda00020) {
					// Instruction: 14: 11101101101sssssPP0ttttt001ddddd | Rd = mpy (Rs, Rt.L) :<<1:sat
					hi->instruction = HEX_INS_RD___MPY__RS__RT_L_____1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d.L) :<<1:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xda00080) {
					// Instruction: 14: 11101101101sssssPP0ttttt100ddddd | Rd = mpy (Rs, Rt.H) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS__RT_H_____1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d.H) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xde00000) {
					// Instruction: 14: 11101101111sssssPP0ttttt000ddddd | Rd = mpy (Rs, Rt) :<<1:sat
					hi->instruction = HEX_INS_RD___MPY__RS__RT_____1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d) :<<1:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xde00080) {
					// Instruction: 14: 11101101111sssssPP0ttttt100ddddd | Rd = mpy (Rs, Rt.L) :<<1:rnd:sat
					hi->instruction = HEX_INS_RD___MPY__RS__RT_L_____1_RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d.L) :<<1:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf402080) == 0xd000000) {
					// Instruction: 14: 11101101N0NsssssPP0ttttt0NNddddd | Rd = mpy (Rs, Rt) [:<<N]
					hi->instruction = HEX_INS_RD___MPY__RS__RT______N_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32 & 0x800000) >> 20) | ((hi_u32 & 0x200000) >> 19) | ((hi_u32 & 0x60) >> 5))) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mpy (R%d, R%d) %s", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf600000) {
					// Instruction: 14: 11101111011sssssPP0ttttt000xxxxx | Rx += mpy (Rs, Rt) :<<1:sat
					hi->instruction = HEX_INS_RX__PLUS_EQ__MPY__RS__RT_____1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d += mpy (R%d, R%d) :<<1:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xf600020) {
					// Instruction: 14: 11101111011sssssPP0ttttt001xxxxx | Rx -= mpy (Rs, Rt) :<<1:sat
					hi->instruction = HEX_INS_RX__MINUS_EQ__MPY__RS__RT_____1_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rx
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_LSH1; // :<<1
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d -= mpy (R%d, R%d) :<<1:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5000000) {
					// Instruction: 14: 11100101000sssssPP0ttttt000ddddd | Rdd = mpy (Rs, Rt)
					hi->instruction = HEX_INS_RDD___MPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpy (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5400000) {
					// Instruction: 14: 11100101010sssssPP0ttttt000ddddd | Rdd = mpyu (Rs, Rt)
					hi->instruction = HEX_INS_RDD___MPYU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = mpyu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7000000) {
					// Instruction: 14: 11100111000sssssPP0ttttt000xxxxx | Rxx += mpy (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpy (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7200000) {
					// Instruction: 14: 11100111001sssssPP0ttttt000xxxxx | Rxx -= mpy (Rs, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPY__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpy (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7400000) {
					// Instruction: 14: 11100111010sssssPP0ttttt000xxxxx | Rxx += mpyu (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__MPYU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += mpyu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7600000) {
					// Instruction: 14: 11100111011sssssPP0ttttt000xxxxx | Rxx -= mpyu (Rs, Rt)
					hi->instruction = HEX_INS_RXX__MINUS_EQ__MPYU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d -= mpyu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x8000080) {
					// Instruction: 14: 11101000N00sssssPP0ttttt100ddddd | Rdd = vdmpy (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VDMPY__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vdmpy (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa000080) {
					// Instruction: 14: 11101010N00sssssPP0ttttt100xxxxx | Rxx += vdmpy (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VDMPY__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vdmpy (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf002060) == 0x9000000) {
					// Instruction: 14: 11101001N--sssssPP0ttttt-00ddddd | Rd = vdmpy (Rss, Rtt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___VDMPY__RSS__RTT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vdmpy (R%d:R%d, R%d:R%d) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8800020) {
					// Instruction: 14: 11101000100sssssPP0ttttt001ddddd | Rdd = vrmpybu (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRMPYBU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmpybu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8c00020) {
					// Instruction: 14: 11101000110sssssPP0ttttt001ddddd | Rdd = vrmpybsu (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRMPYBSU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmpybsu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa800020) {
					// Instruction: 14: 11101010100sssssPP0ttttt001xxxxx | Rxx += vrmpybu (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRMPYBU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrmpybu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xac00020) {
					// Instruction: 14: 11101010110sssssPP0ttttt001xxxxx | Rxx += vrmpybsu (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRMPYBSU__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrmpybsu (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8a00020) {
					// Instruction: 14: 11101000101sssssPP0ttttt001ddddd | Rdd = vdmpybsu (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RDD___VDMPYBSU__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vdmpybsu (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa200020) {
					// Instruction: 14: 11101010001sssssPP0ttttt001xxxxx | Rxx += vdmpybsu (Rss, Rtt) :sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VDMPYBSU__RSS__RTT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vdmpybsu (R%d:R%d, R%d:R%d) :sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x80000c0) {
					// Instruction: 14: 11101000N00sssssPP0ttttt110ddddd | Rdd = vmpyeh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYEH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyeh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa200040) {
					// Instruction: 14: 11101010001sssssPP0ttttt010xxxxx | Rxx += vmpyeh (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYEH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vmpyeh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xa0000c0) {
					// Instruction: 14: 11101010N00sssssPP0ttttt110xxxxx | Rxx += vmpyeh (Rss, Rtt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYEH__RSS__RTT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyeh (R%d:R%d, R%d:R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x50000a0) {
					// Instruction: 14: 11100101N00sssssPP0ttttt101ddddd | Rdd = vmpyh (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYH__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyh (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7200020) {
					// Instruction: 14: 11100111001sssssPP0ttttt001xxxxx | Rxx += vmpyh (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYH__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vmpyh (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x70000a0) {
					// Instruction: 14: 11100111N00sssssPP0ttttt101xxxxx | Rxx += vmpyh (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYH__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyh (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0xd2000e0) {
					// Instruction: 14: 11101101N01sssssPP0ttttt111ddddd | Rd = vmpyh (Rs, Rt) [:<<N]:rnd:sat
					hi->instruction = HEX_INS_RD___VMPYH__RS__RT______N__RND_SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vmpyh (R%d, R%d) %s:rnd:sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x50000e0) {
					// Instruction: 14: 11100101N00sssssPP0ttttt111ddddd | Rdd = vmpyhsu (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RDD___VMPYHSU__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d = vmpyhsu (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xf6020e0) == 0x76000a0) {
					// Instruction: 14: 11100111N11sssssPP0ttttt101xxxxx | Rxx += vmpyhsu (Rs, Rt) [:<<N]:sat
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYHSU__RS__RT______N__SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					if ((((hi_u32) & 0x800000) >> 23)) {
						hi->pf |= HEX_PF_LSH1; // [:<<1]
					}
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d:R%d += vmpyhsu (R%d, R%d) %s:sat", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg, ((hi->pf & HEX_PF_LSH1) == HEX_PF_LSH1) ? ":<<1" : "");
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x8000040) {
					// Instruction: 14: 11101000000sssssPP0ttttt010ddddd | Rdd = vrmpyh (Rss, Rtt)
					hi->instruction = HEX_INS_RDD___VRMPYH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vrmpyh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0xa000040) {
					// Instruction: 14: 11101010000sssssPP0ttttt010xxxxx | Rxx += vrmpyh (Rss, Rtt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VRMPYH__RSS__RTT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].attr |= HEX_OP_REG_PAIR;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8);
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vrmpyh (R%d:R%d, R%d:R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg + 1, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5400020) {
					// Instruction: 14: 11100101010sssssPP0ttttt001ddddd | Rdd = vmpybsu (Rs, Rt)
					hi->instruction = HEX_INS_RDD___VMPYBSU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmpybsu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5800020) {
					// Instruction: 14: 11100101100sssssPP0ttttt001ddddd | Rdd = vmpybu (Rs, Rt)
					hi->instruction = HEX_INS_RDD___VMPYBU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vmpybu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7800020) {
					// Instruction: 14: 11100111100sssssPP0ttttt001xxxxx | Rxx += vmpybu (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYBU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vmpybu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7c00020) {
					// Instruction: 14: 11100111110sssssPP0ttttt001xxxxx | Rxx += vmpybsu (Rs, Rt)
					hi->instruction = HEX_INS_RXX__PLUS_EQ__VMPYBSU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d += vmpybsu (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x5c000e0) {
					// Instruction: 14: 11100101110sssssPP0ttttt111ddddd | Rdd = vpmpyh (Rs, Rt)
					hi->instruction = HEX_INS_RDD___VPMPYH__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = vpmpyh (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe020e0) == 0x7a000e0) {
					// Instruction: 14: 11100111101sssssPP0ttttt111xxxxx | Rxx ^= vpmpyh (Rs, Rt)
					hi->instruction = HEX_INS_RXX____VPMPYH__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d ^= vpmpyh (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				break;
			}
			case 0xf: {
				if ((hi_u32 & 0xfe00000) == 0x3000000) {
					// Instruction: 15: 11110011000sssssPP-ttttt---ddddd | Rd = add (Rs, Rt)
					hi->instruction = HEX_INS_RD___ADD__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = add (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6400000) {
					// Instruction: 15: 11110110010sssssPP-ttttt---ddddd | Rd = add (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___ADD__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = add (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1000000) {
					// Instruction: 15: 11110001000sssssPP-ttttt---ddddd | Rd = and (Rs, Rt)
					hi->instruction = HEX_INS_RD___AND__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = and (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1200000) {
					// Instruction: 15: 11110001001sssssPP-ttttt---ddddd | Rd = or (Rs, Rt)
					hi->instruction = HEX_INS_RD___OR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = or (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1600000) {
					// Instruction: 15: 11110001011sssssPP-ttttt---ddddd | Rd = xor (Rs, Rt)
					hi->instruction = HEX_INS_RD___XOR__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = xor (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1800000) {
					// Instruction: 15: 11110001100sssssPP-ttttt---ddddd | Rd = and (Rt, ~Rs)
					hi->instruction = HEX_INS_RD___AND__RT___RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = and (R%d, ~R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x1a00000) {
					// Instruction: 15: 11110001101sssssPP-ttttt---ddddd | Rd = or (Rt, ~Rs)
					hi->instruction = HEX_INS_RD___OR__RT___RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = or (R%d, ~R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3200000) {
					// Instruction: 15: 11110011001sssssPP-ttttt---ddddd | Rd = sub (Rt, Rs)
					hi->instruction = HEX_INS_RD___SUB__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = sub (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6c00000) {
					// Instruction: 15: 11110110110sssssPP-ttttt---ddddd | Rd = sub (Rt, Rs) :sat
					hi->instruction = HEX_INS_RD___SUB__RT__RS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = sub (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6000000) {
					// Instruction: 15: 11110110000sssssPP-ttttt---ddddd | Rd = vaddh (Rs, Rt)
					hi->instruction = HEX_INS_RD___VADDH__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vaddh (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6200000) {
					// Instruction: 15: 11110110001sssssPP-ttttt---ddddd | Rd = vaddh (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___VADDH__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vaddh (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6600000) {
					// Instruction: 15: 11110110011sssssPP-ttttt---ddddd | Rd = vadduh (Rs, Rt) :sat
					hi->instruction = HEX_INS_RD___VADDUH__RS__RT___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vadduh (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf600000) == 0x7000000) {
					// Instruction: 15: 11110111-00sssssPP-ttttt---ddddd | Rd = vavgh (Rs, Rt)
					hi->instruction = HEX_INS_RD___VAVGH__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vavgh (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf600000) == 0x7200000) {
					// Instruction: 15: 11110111-01sssssPP-ttttt---ddddd | Rd = vavgh (Rs, Rt) :rnd
					hi->instruction = HEX_INS_RD___VAVGH__RS__RT___RND;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_RND; // :rnd
					sprintf(hi->mnem, "R%d = vavgh (R%d, R%d) :rnd", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf600000) == 0x7600000) {
					// Instruction: 15: 11110111-11sssssPP-ttttt---ddddd | Rd = vnavgh (Rt, Rs)
					hi->instruction = HEX_INS_RD___VNAVGH__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vnavgh (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6800000) {
					// Instruction: 15: 11110110100sssssPP-ttttt---ddddd | Rd = vsubh (Rt, Rs)
					hi->instruction = HEX_INS_RD___VSUBH__RT__RS_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = vsubh (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6a00000) {
					// Instruction: 15: 11110110101sssssPP-ttttt---ddddd | Rd = vsubh (Rt, Rs) :sat
					hi->instruction = HEX_INS_RD___VSUBH__RT__RS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vsubh (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x6e00000) {
					// Instruction: 15: 11110110111sssssPP-ttttt---ddddd | Rd = vsubuh (Rt, Rs) :sat
					hi->instruction = HEX_INS_RD___VSUBUH__RT__RS___SAT;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					hi->pf |= HEX_PF_SAT; // :sat
					sprintf(hi->mnem, "R%d = vsubuh (R%d, R%d) :sat", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3800000) {
					// Instruction: 15: 11110011100sssssPP-ttttt---ddddd | Rd = combine (Rt.H, Rs.H)
					hi->instruction = HEX_INS_RD___COMBINE__RT_H__RS_H_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = combine (R%d.H, R%d.H)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3a00000) {
					// Instruction: 15: 11110011101sssssPP-ttttt---ddddd | Rd = combine (Rt.H, Rs.L)
					hi->instruction = HEX_INS_RD___COMBINE__RT_H__RS_L_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = combine (R%d.H, R%d.L)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3c00000) {
					// Instruction: 15: 11110011110sssssPP-ttttt---ddddd | Rd = combine (Rt.L, Rs.H)
					hi->instruction = HEX_INS_RD___COMBINE__RT_L__RS_H_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = combine (R%d.L, R%d.H)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3e00000) {
					// Instruction: 15: 11110011111sssssPP-ttttt---ddddd | Rd = combine (Rt.L, Rs.L)
					hi->instruction = HEX_INS_RD___COMBINE__RT_L__RS_L_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = combine (R%d.L, R%d.L)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x5000000) {
					// Instruction: 15: 111101010--sssssPP-ttttt---ddddd | Rdd = combine (Rs, Rt)
					hi->instruction = HEX_INS_RDD___COMBINE__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = combine (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf000000) == 0x4000000) {
					// Instruction: 15: 11110100---sssssPP-ttttt-uuddddd | Rd = mux (Pu, Rs, Rt)
					hi->instruction = HEX_INS_RD___MUX__PU__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[1].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = mux (P%d, R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.pred, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf800000) == 0x5800000) {
					// Instruction: 15: 111101011--sssssPP-ttttt---ddddd | Rdd = packhl (Rs, Rt)
					hi->instruction = HEX_INS_RDD___PACKHL__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].attr |= HEX_OP_REG_PAIR;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d:R%d = packhl (R%d, R%d)", hi->ops[0].op.reg + 1, hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb000000) {
					// Instruction: 15: 111110110-0sssssPP0ttttt0uuddddd | if (Pu) Rd = add (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU__RD___ADD__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = add (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb000080) {
					// Instruction: 15: 111110110-0sssssPP0ttttt1uuddddd | if !Pu Rd = add (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___ADD__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = add (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb002000) {
					// Instruction: 15: 111110110-0sssssPP1ttttt0uuddddd | if (Pu.new) Rd = add (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___ADD__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = add (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb002080) {
					// Instruction: 15: 111110110-0sssssPP1ttttt1uuddddd | if !Pu.new Rd = add (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___ADD__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = add (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf002080) == 0xd000000) {
					// Instruction: 15: 11111101---sssssPP0ttttt0uuddddd | if (Pu) Rdd = combine (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU__RDD___COMBINE__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d:R%d = combine (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf002080) == 0xd000080) {
					// Instruction: 15: 11111101---sssssPP0ttttt1uuddddd | if !Pu Rdd = combine (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_RDD___COMBINE__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d:R%d = combine (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf002080) == 0xd002000) {
					// Instruction: 15: 11111101---sssssPP1ttttt0uuddddd | if (Pu.new) Rdd = combine (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU_NEW__RDD___COMBINE__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d:R%d = combine (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf002080) == 0xd002080) {
					// Instruction: 15: 11111101---sssssPP1ttttt1uuddddd | if !Pu.new Rdd = combine (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RDD___COMBINE__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].attr |= HEX_OP_REG_PAIR;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0);
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d:R%d = combine (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg + 1, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9000000) {
					// Instruction: 15: 11111001-00sssssPP0ttttt0uuddddd | if (Pu) Rd = and (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU__RD___AND__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = and (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9000080) {
					// Instruction: 15: 11111001-00sssssPP0ttttt1uuddddd | if !Pu Rd = and (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___AND__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = and (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9002000) {
					// Instruction: 15: 11111001-00sssssPP1ttttt0uuddddd | if (Pu.new) Rd = and (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___AND__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = and (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9002080) {
					// Instruction: 15: 11111001-00sssssPP1ttttt1uuddddd | if !Pu.new Rd = and (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___AND__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = and (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9200000) {
					// Instruction: 15: 11111001-01sssssPP0ttttt0uuddddd | if (Pu) Rd = or (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU__RD___OR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = or (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9200080) {
					// Instruction: 15: 11111001-01sssssPP0ttttt1uuddddd | if !Pu Rd = or (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___OR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = or (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9202000) {
					// Instruction: 15: 11111001-01sssssPP1ttttt0uuddddd | if (Pu.new) Rd = or (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___OR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = or (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9202080) {
					// Instruction: 15: 11111001-01sssssPP1ttttt1uuddddd | if !Pu.new Rd = or (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___OR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = or (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9600000) {
					// Instruction: 15: 11111001-11sssssPP0ttttt0uuddddd | if (Pu) Rd = xor (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU__RD___XOR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = xor (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9600080) {
					// Instruction: 15: 11111001-11sssssPP0ttttt1uuddddd | if !Pu Rd = xor (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___XOR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = xor (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9602000) {
					// Instruction: 15: 11111001-11sssssPP1ttttt0uuddddd | if (Pu.new) Rd = xor (Rs, Rt)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___XOR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = xor (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf602080) == 0x9602080) {
					// Instruction: 15: 11111001-11sssssPP1ttttt1uuddddd | if !Pu.new Rd = xor (Rs, Rt)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___XOR__RS__RT_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = xor (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb200000) {
					// Instruction: 15: 111110110-1sssssPP0ttttt0uuddddd | if (Pu) Rd = sub (Rt, Rs)
					hi->instruction = HEX_INS_IF__PU__RD___SUB__RT__RS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE; // if (Pu)
					sprintf(hi->mnem, "if (P%d) R%d = sub (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb200080) {
					// Instruction: 15: 111110110-1sssssPP0ttttt1uuddddd | if !Pu Rd = sub (Rt, Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_RD___SUB__RT__RS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE; // if !Pu
					sprintf(hi->mnem, "if !P%d R%d = sub (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb202000) {
					// Instruction: 15: 111110110-1sssssPP1ttttt0uuddddd | if (Pu.new) Rd = sub (Rt, Rs)
					hi->instruction = HEX_INS_IF__PU_NEW__RD___SUB__RT__RS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_TRUE_NEW; // if (Pu.new)
					sprintf(hi->mnem, "if (P%d.new) R%d = sub (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xfa02080) == 0xb202080) {
					// Instruction: 15: 111110110-1sssssPP1ttttt1uuddddd | if !Pu.new Rd = sub (Rt, Rs)
					hi->instruction = HEX_INS_IF__NOT_PU_NEW_RD___SUB__RT__RS_;
					hi->op_count = 4;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x60) >> 5);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->ops[3].type = HEX_OP_TYPE_REG;
					hi->ops[3].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->predicate = HEX_PRED_FALSE_NEW; // if !Pu.new
					sprintf(hi->mnem, "if !P%d.new R%d = sub (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg, hi->ops[3].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2000000) {
					// Instruction: 15: 11110010-00sssssPP-ttttt---000dd | Pd = cmp.eq (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.eq (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2000010) {
					// Instruction: 15: 11110010-00sssssPP-ttttt---100dd | Pd = !cmp.eq (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_CMP_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !cmp.eq (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2400000) {
					// Instruction: 15: 11110010-10sssssPP-ttttt---000dd | Pd = cmp.gt (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_GT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gt (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2400010) {
					// Instruction: 15: 11110010-10sssssPP-ttttt---100dd | Pd = !cmp.gt (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_CMP_GT__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !cmp.gt (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2600000) {
					// Instruction: 15: 11110010-11sssssPP-ttttt---000dd | Pd = cmp.gtu (Rs, Rt)
					hi->instruction = HEX_INS_PD___CMP_GTU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = cmp.gtu (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xf60001c) == 0x2600010) {
					// Instruction: 15: 11110010-11sssssPP-ttttt---100dd | Pd = !cmp.gtu (Rs, Rt)
					hi->instruction = HEX_INS_PD____NOT_CMP_GTU__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_PREDICATE;
					hi->ops[0].op.pred = (((hi_u32) & 0x3) >> 0);
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "P%d = !cmp.gtu (R%d, R%d)", hi->ops[0].op.pred, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3400000) {
					// Instruction: 15: 11110011010sssssPP-ttttt---ddddd | Rd = cmp.eq (Rs, Rt)
					hi->instruction = HEX_INS_RD___CMP_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = cmp.eq (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				if ((hi_u32 & 0xfe00000) == 0x3600000) {
					// Instruction: 15: 11110011011sssssPP-ttttt---ddddd | Rd = !cmp.eq (Rs, Rt)
					hi->instruction = HEX_INS_RD____NOT_CMP_EQ__RS__RT_;
					hi->op_count = 3;
					hi->ops[0].type = HEX_OP_TYPE_REG;
					hi->ops[0].op.reg = (((hi_u32) & 0x1f) >> 0); // Rd
					hi->ops[1].type = HEX_OP_TYPE_REG;
					hi->ops[1].op.reg = (((hi_u32) & 0x1f0000) >> 16); // Rs
					hi->ops[2].type = HEX_OP_TYPE_REG;
					hi->ops[2].op.reg = (((hi_u32) & 0x1f00) >> 8); // Rt
					hi->predicate = HEX_NOPRED;
					sprintf(hi->mnem, "R%d = !cmp.eq (R%d, R%d)", hi->ops[0].op.reg, hi->ops[1].op.reg, hi->ops[2].op.reg);
					break;
				}
				break;
			}
		}
	}
	return 4;
}
