diff --git a/libr/anal/c2/kv.c b/libr/anal/c2/kv.c
index bb9de2f6e9..40e70cb6b5 100644
--- a/libr/anal/c2/kv.c
+++ b/libr/anal/c2/kv.c
@@ -8,8 +8,8 @@ typedef struct {
 } KVCToken;
 
 typedef struct {
-	KVCToken keys[10];
-	KVCToken values[10];
+	KVCToken keys[20];
+	KVCToken values[20];
 	size_t count;
 } AttrList;
 
@@ -94,7 +94,7 @@ static void massage_type(char **s) {
 			star--;
 		}
 		char *type = r_str_ndup (*s, star - *s);
-		char *res = r_str_newf ("%s %s", type, ostar);
+		char *res = r_str_newf ("%s%s", type, ostar);
 		free (*s);
 		free (type);
 		*s = res;
@@ -132,7 +132,7 @@ static const char *kvc_find_semicolon(KVCParser *kvc) {
 			return kvc->s.a;
 		}
 		if (!isalnum (c) && !isspace (c) && c != '_') {
-			if (c != '[' && c != ']' && c != '*') {
+			if (c != '[' && c != ']' && c != '*' && c != '(' && c != ')') {
 				return NULL;
 			}
 		}
@@ -327,11 +327,25 @@ static void apply_attributes(KVCParser *kvc, const char *type, const char *scope
 	for (i = 0; i < kvc->attrs.count; i++) {
 		KVCToken key = kvc->attrs.keys[i];
 		KVCToken val = kvc->attrs.values[i];
-		r_strbuf_appendf (kvc->sb, "%s.%s.@.", type, scope);
-		r_strbuf_append_n (kvc->sb, key.a, kvctoken_len (key));
-		r_strbuf_append (kvc->sb, "=");
-		r_strbuf_append_n (kvc->sb, val.a, kvctoken_len (val));
-		r_strbuf_append (kvc->sb, "\n");
+		
+		if (key.a && val.a) {
+			// Special handling for @aligned attributes - add .meta=2 to indicate alignment
+			if (key.a[0] == '@' && !strncmp(key.a + 1, "aligned", 7)) {
+				r_strbuf_appendf (kvc->sb, "%s.%s.meta=2\n", type, scope);
+			}
+			
+			// Output normal attribute format
+			r_strbuf_appendf (kvc->sb, "%s.%s.@.", type, scope);
+			// Skip @ prefix if it exists when outputting the key
+			if (key.a[0] == '@') {
+				r_strbuf_append_n (kvc->sb, key.a + 1, kvctoken_len (key) - 1);
+			} else {
+				r_strbuf_append_n (kvc->sb, key.a, kvctoken_len (key));
+			}
+			r_strbuf_append (kvc->sb, "=");
+			r_strbuf_append_n (kvc->sb, val.a, kvctoken_len (val));
+			r_strbuf_append (kvc->sb, "\n");
+		}
 	}
 	kvc->attrs.count = 0; // Reset after applying
 }
@@ -575,6 +589,192 @@ static bool parse_typedef(KVCParser *kvc, const char *unused) {
 	}
 }
 
+// Process function body for __attribute__ sections
+static bool process_attributes_in_body(KVCParser *kvc) {
+	// This is a simplified version focusing on finding the alignment value 
+	// Look for __attribute__
+	const char *token_str = r_str_ndup(kvc->s.a, kvctoken_len(kvc->s));
+	const char *attr_pos = strstr(token_str, "__attribute__");
+	if (!attr_pos) {
+		free((void*)token_str);
+		return false;
+	}
+	
+	// Parse the attribute specification
+	bool found_aligned = false;
+	const char *p = attr_pos;
+	
+	// Skip to opening double parentheses
+	while (*p && !(p[0] == '(' && p[1] == '(')) p++;
+	if (!*p) {
+		free((void*)token_str);
+		return false;
+	}
+	p += 2; // Skip ((
+	
+	// Find the attribute name
+	while (*p && isspace(*p)) p++;
+	while (*p && *p == '_') p++;
+	
+	if (!strncmp(p, "aligned", 7)) {
+		found_aligned = true;
+		p += 7;
+		
+		// Find the value
+		while (*p && *p != '(') p++;
+		if (*p == '(') {
+			p++;
+			
+			const char *value_start = p;
+			while (*p && *p != ')') p++;
+			
+			if (*p == ')') {
+				int value_len = p - value_start;
+				char *value = r_str_ndup(value_start, value_len);
+				
+				// Store the attribute in the attribute list
+				int atidx = kvc->attrs.count;
+				
+				// Create the key as '@aligned' to match /// @aligned format
+				char *key_str = strdup("aligned");
+				kvc->attrs.keys[atidx].a = key_str;
+				kvc->attrs.keys[atidx].b = key_str + strlen(key_str);
+				
+				kvc->attrs.values[atidx].a = value;
+				kvc->attrs.values[atidx].b = value + strlen(value);
+				kvc->attrs.count++;
+				
+				R_LOG_INFO("Found __attribute__((aligned(%s)))", value);
+				free((void*)token_str);
+				return true;
+			}
+		}
+	}
+	
+	free((void*)token_str);
+	return found_aligned;
+}
+
+// Parse attribute specifications like __attribute__((__aligned__(4)))
+static bool parse_attribute_spec(KVCParser *kvc) {
+	const char *attr = kvc_peekn(kvc, 13);
+	if (!attr || !r_str_startswith(attr, "__attribute__")) {
+		return false;
+	}
+
+	kvc_skipn(kvc, 13); // Skip "__attribute__"
+	skip_spaces(kvc);
+
+	// Expect opening double parentheses
+	if (kvc_peek(kvc, 0) != '(' || kvc_peek(kvc, 1) != '(') {
+		kvc_error(kvc, "Expected (( after __attribute__");
+		return false;
+	}
+	kvc_skipn(kvc, 2);
+	skip_spaces(kvc);
+
+	// Parse the attribute name with leading underscore(s)
+	const char *attr_name_start = kvc->s.a;
+	while (kvc_peek(kvc, 0) == '_') {
+		kvc_getch(kvc);
+	}
+	const char *attr_name = consume_word(kvc);
+	if (!attr_name) {
+		kvc_error(kvc, "Missing attribute name");
+		return false;
+	}
+
+	KVCToken attr_token = {
+		.a = attr_name,
+		.b = kvc->s.a
+	};
+
+	skip_spaces(kvc);
+
+	// Check for attribute value in parentheses
+	KVCToken attr_value = {0};
+	if (kvc_peek(kvc, 0) == '(') {
+		kvc_getch(kvc);
+		attr_value.a = kvc->s.a;
+
+		// Find closing parenthesis for the attribute value
+		int paren_depth = 1;
+		while (!kvctoken_eof(kvc->s) && paren_depth > 0) {
+			const char c = kvc_getch(kvc);
+			if (c == '(') {
+				paren_depth++;
+			} else if (c == ')') {
+				paren_depth--;
+			}
+		}
+
+		if (paren_depth != 0) {
+			kvc_error(kvc, "Unclosed parenthesis in attribute value");
+			return false;
+		}
+
+		attr_value.b = kvc->s.a - 1;
+	}
+
+	skip_spaces(kvc);
+
+	// Expect closing double parentheses
+	if (kvc_peek(kvc, 0) != ')' || kvc_peek(kvc, 1) != ')') {
+		kvc_error(kvc, "Expected )) to close attribute");
+		return false;
+	}
+	kvc_skipn(kvc, 2);
+
+	// Store the attribute in the attribute list
+	int atidx = kvc->attrs.count;
+	bool duppedkey = false;
+	
+	// Convert the attribute name to our internal format (without __)
+	char *attr_name_str = kvctoken_tostring(attr_token);
+	
+	// Create the key as if it was an @ annotation
+	KVCToken key = {0};
+	// Store it with @ prefix to match the format used by /// @aligned(4) comments
+	char *key_str = r_str_newf("@%s", attr_name_str);
+	key.a = key_str;
+	key.b = key_str + strlen(key_str);
+
+	// Check for duplicates
+	for (int i = 0; i < kvc->attrs.count; i++) {
+		if (kvctoken_equals(kvc->attrs.keys[i], key)) {
+			duppedkey = true;
+			atidx = i;
+			free(key_str);
+			break;
+		}
+	}
+
+	if (!duppedkey) {
+		kvc->attrs.count++;
+		kvc->attrs.keys[atidx] = key;
+	} else {
+		// If we're updating an existing attribute, we need to free the old value
+		if (kvc->attrs.values[atidx].a && kvc->attrs.values[atidx].a != "true") {
+			free((void*)kvc->attrs.values[atidx].a);
+		}
+	}
+
+	// Handle the attribute value
+	if (attr_value.a) {
+		char *value_str = kvctoken_tostring(attr_value);
+		kvc->attrs.values[atidx].a = value_str;
+		kvc->attrs.values[atidx].b = value_str + strlen(value_str);
+	} else {
+		// No value provided, default to "true"
+		kvc->attrs.values[atidx].a = "true";
+		kvc->attrs.values[atidx].b = kvc->attrs.values[atidx].a + 4;
+	}
+
+	free(attr_name_str); // Free the original name string
+	skip_spaces(kvc);
+	return true;
+}
+
 // works for unions and structs
 static bool parse_struct(KVCParser *kvc, const char *type) {
 	KVCToken struct_name = { .a = consume_word (kvc) };
@@ -628,6 +828,47 @@ static bool parse_struct(KVCParser *kvc, const char *type) {
 		}
 		memcpy (&member_name, &member_type, sizeof (member_name));
 		// eprintf ("ENTRY ((%s)))\n", kvctoken_tostring (member_type));
+		
+		// Extract entire member definition as a string to check for attributes
+		char *full_decl = r_str_ndup(member_type.a, member_type.b - member_type.a);
+		bool has_attribute = full_decl && strstr(full_decl, "__attribute__");
+		if (has_attribute) {
+			// Process the attribute before typename parsing
+			const char *attr_str = strstr(full_decl, "__attribute__");
+			if (attr_str) {
+				// Find the attribute value - between (( and ))
+				const char *aligned_str = strstr(attr_str, "aligned");
+				if (aligned_str) {
+					const char *value_start = strchr(aligned_str, '(');
+					if (value_start) {
+						value_start++; // Skip the opening parenthesis
+						const char *value_end = strchr(value_start, ')');
+						if (value_end) {
+							char *value = r_str_ndup(value_start, value_end - value_start);
+							// Store the attribute in the attribute list
+							int atidx = kvc->attrs.count;
+							char *key_str = strdup("@aligned"); // Add @ prefix to match comment format
+							kvc->attrs.keys[atidx].a = key_str;
+							kvc->attrs.keys[atidx].b = key_str + strlen(key_str);
+							kvc->attrs.values[atidx].a = value;
+							kvc->attrs.values[atidx].b = value + strlen(value);
+							kvc->attrs.count++;
+							R_LOG_INFO("Found __attribute__((aligned(%s)))", value);
+						}
+					}
+				}
+			}
+			
+			// Trim the attribute from the member declaration
+			const char *attr_start = strstr(full_decl, "__attribute__");
+			if (attr_start && attr_start > full_decl) {
+				// Trim the string at the attribute position
+				int pos = attr_start - full_decl;
+				member_type.b = member_type.a + pos;
+			}
+		}
+		free(full_decl);
+		
 		kvctoken_typename (&member_type, &member_name);
 		kvc_getch (kvc); // skip semicolon
 		kvctoken_trim (&member_type);
@@ -815,7 +1056,25 @@ static bool parse_function(KVCParser *kvc) {
 	}
 	fun_rtyp.b = kvc->s.a;
 	fun_name.a = fun_rtyp.a;
+	
+	// Check if this contains __attribute__ - don't treat as a function in this case
+	const char *token_str = r_str_ndup(fun_rtyp.a, kvctoken_len(fun_rtyp));
+	if (token_str && strstr(token_str, "__attribute__")) {
+		free((void*)token_str);
+		return false;
+	}
+	free((void*)token_str);
+	
 	if (!skip_until (kvc, '(', 0)) {
+		// We check if we have __attribute__ in the text because this might be part of a struct field
+		const char *remaining = r_str_ndup(kvc->s.a, kvctoken_len(kvc->s));
+		if (remaining && strstr(remaining, "__attribute__")) {
+			// This might be a struct field with attributes, not a function
+			free((void*)remaining);
+			return false;
+		}
+		free((void*)remaining);
+		
 		kvc_error (kvc, "Cannot find ( in function definition");
 		// r_sys_breakpoint();
 		return false;
