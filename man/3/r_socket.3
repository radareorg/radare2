.Dd September 21, 2025
.Dt R_SOCKET 3
.Os
.Sh NAME
.Nm r_socket
.Nd Network socket library for radare2
.Sh SYNOPSIS
.In r_socket.h
.Ft struct r_socket_t *
.Fn r_socket_new "bool is_ssl"
.Ft void
.Fn r_socket_free "struct r_socket_t *s"
.Ft bool
.Fn r_socket_connect "struct r_socket_t *s" "const char *host" "const char *port" "int proto" "unsigned int timeout"
.Ft bool
.Fn r_socket_listen "struct r_socket_t *s" "const char *port" "const char *certfile"
.Ft struct r_socket_t *
.Fn r_socket_accept "struct r_socket_t *s"
.Ft bool
.Fn r_socket_close "struct r_socket_t *s"
.Ft int
.Fn r_socket_read "struct r_socket_t *s" "ut8 *read" "int len"
.Ft int
.Fn r_socket_write "struct r_socket_t *s" "const void *buf" "int len"
.Ft int
.Fn r_socket_gets "struct r_socket_t *s" "char *buf" "int size"
.Ft void
.Fn r_socket_printf "struct r_socket_t *s" "const char *fmt" "..."
.Ft bool
.Fn r_socket_is_connected "struct r_socket_t *s"
.Ft int
.Fn r_socket_ready "struct r_socket_t *s" "int secs" "int usecs"
.Ft char *
.Fn r_socket_http_get "const char *url" "const char **headers" "int *code" "int *rlen"
.Ft char *
.Fn r_socket_http_post "const char *url" "const char **headers" "const char *data" "int *code" "int *rlen"
.Ft struct r_socket_rap_server_t *
.Fn r_socket_rap_server_new "bool is_ssl" "const char *port"
.Ft bool
.Fn r_socket_rap_server_listen "struct r_socket_rap_server_t *rap_s" "const char *certfile"
.Ft struct r2pipe_t *
.Fn r2pipe_open "const char *cmd"
.Ft char *
.Fn r2pipe_cmd "struct r2pipe_t *r2pipe" "const char *str"
.Ft int
.Fn r2pipe_close "struct r2pipe_t *r2pipe"
.Sh DESCRIPTION
The
.Nm r_socket
library provides network socket functionality for radare2, including
TCP/UDP connections, SSL/TLS support, HTTP client/server, RAP protocol,
and process communication pipes.
.Pp
The core structure is
.Vt struct r_socket_t ,
which represents a network socket with support for both plain and SSL connections.
.Sh INITIALIZATION
Create a new socket:
.Bd -literal -offset indent
RSocket *s = r_socket_new(false); // Plain socket
RSocket *ssl_s = r_socket_new(true); // SSL socket
.Ed
.Pp
Free when done:
.Bd -literal -offset indent
r_socket_free(s);
.Ed
.Sh CONNECTIONS
Connect to a host:
.Bd -literal -offset indent
if (r_socket_connect(s, "127.0.0.1", "8080", R_SOCKET_PROTO_TCP, 5000)) {
    // Connected successfully
}
.Ed
.Pp
Convenience macros:
.Bd -literal -offset indent
r_socket_connect_tcp(s, "example.com", "80", 5000);
r_socket_connect_udp(s, "127.0.0.1", "53", 1000);
.Ed
.Sh SERVERS
Listen for connections:
.Bd -literal -offset indent
if (r_socket_listen(s, "8080", NULL)) { // NULL for no SSL cert
    RSocket *client = r_socket_accept(s);
    if (client) {
        // Handle client connection
        r_socket_free(client);
    }
}
.Ed
.Sh DATA TRANSFER
Read data:
.Bd -literal -offset indent
ut8 buffer[1024];
int bytes = r_socket_read(s, buffer, sizeof(buffer));
.Ed
.Pp
Write data:
.Bd -literal -offset indent
const char *data = "Hello, World!";
int sent = r_socket_write(s, data, strlen(data));
.Ed
.Pp
Read line:
.Bd -literal -offset indent
char line[256];
if (r_socket_gets(s, line, sizeof(line)) > 0) {
    printf("Received: %s\\n", line);
}
.Ed
.Pp
Formatted output:
.Bd -literal -offset indent
r_socket_printf(s, "GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n", hostname);
.Ed
.Sh HTTP CLIENT
HTTP GET request:
.Bd -literal -offset indent
int code, rlen;
char *response = r_socket_http_get("http://example.com/api", NULL, &code, &rlen);
if (response) {
    printf("HTTP %d: %s\\n", code, response);
    free(response);
}
.Ed
.Pp
HTTP POST request:
.Bd -literal -offset indent
char *post_data = "key=value";
char *response = r_socket_http_post("http://example.com/api", NULL, post_data, &code, &rlen);
.Ed
.Sh RAP PROTOCOL
Create RAP server:
.Bd -literal -offset indent
RSocketRapServer *rap_s = r_socket_rap_server_new(false, "9080");
if (r_socket_rap_server_listen(rap_s, NULL)) {
    while (r_socket_rap_server_continue(rap_s)) {
        // Handle RAP commands
    }
}
r_socket_rap_server_free(rap_s);
.Ed
.Sh R2PIPE
Open radare2 pipe:
.Bd -literal -offset indent
R2Pipe *r2p = r2pipe_open("r2 -q /bin/ls");
if (r2p) {
    char *result = r2pipe_cmd(r2p, "i");
    if (result) {
        printf("Info: %s\\n", result);
        free(result);
    }
    r2pipe_close(r2p);
}
.Ed
.Sh PROTOCOLS
Supported protocols:
.Bl -tag -width "R_SOCKET_PROTO_UNIX"
.It Dv R_SOCKET_PROTO_TCP
TCP connections
.It Dv R_SOCKET_PROTO_UDP
UDP datagrams
.It Dv R_SOCKET_PROTO_UNIX
Unix domain sockets
.It Dv R_SOCKET_PROTO_SERIAL
Serial connections
.It Dv R_SOCKET_PROTO_CAN
CAN bus (Linux only)
.El
.Sh EXAMPLES
Simple TCP client:
.Bd -literal -offset indent
#include <r_socket.h>

int main() {
    RSocket *s = r_socket_new(false);
    if (!r_socket_connect_tcp(s, "127.0.0.1", "8080", 5000)) {
        fprintf(stderr, "Connection failed\\n");
        r_socket_free(s);
        return 1;
    }
    
    r_socket_printf(s, "Hello Server\\n");
    
    char response[256];
    int len = r_socket_gets(s, response, sizeof(response));
    if (len > 0) {
        printf("Server: %s\\n", response);
    }
    
    r_socket_close(s);
    r_socket_free(s);
    return 0;
}
.Ed
.Pp
Simple HTTP server:
.Bd -literal -offset indent
RSocket *server = r_socket_new(false);
if (r_socket_listen(server, "8080", NULL)) {
    printf("Server listening on port 8080\\n");
    RSocket *client = r_socket_accept(server);
    if (client) {
        r_socket_printf(client, "HTTP/1.0 200 OK\\r\\n\\r\\nHello World!");
        r_socket_close(client);
        r_socket_free(client);
    }
}
r_socket_close(server);
r_socket_free(server);
.Ed
.Sh SEE ALSO
.Xr r_core 3 ,
.Xr r_util 3