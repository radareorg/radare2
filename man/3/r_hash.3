.Dd September 21, 2025
.Dt R_HASH 3
.Os
.Sh NAME
.Nm r_hash
.Nd Hashing and checksum library for radare2
.Sh SYNOPSIS
.In r_hash.h
.Ft struct r_hash_t *
.Fn r_hash_new "bool rst" "ut64 flags"
.Ft void
.Fn r_hash_free "struct r_hash_t *ctx"
.Ft ut8 *
.Fn r_hash_do_md5 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_sha1 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_sha256 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_sha384 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_sha512 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_hmac_sha256 "struct r_hash_t *ctx" "const ut8 *input" "int len" "const ut8 *key" "int klen"
.Ft ut8 *
.Fn r_hash_do_md4 "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_sip "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_ssdeep "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft ut8 *
.Fn r_hash_do_elf "struct r_hash_t *ctx" "const ut8 *input" "int len"
.Ft int
.Fn r_hash_calculate "struct r_hash_t *ctx" "ut64 algobit" "const ut8 *input" "int len"
.Ft const char *
.Fn r_hash_name "ut64 bit"
.Ft ut64
.Fn r_hash_name_to_bits "const char *name"
.Ft int
.Fn r_hash_size "ut64 bit"
.Ft char *
.Fn r_hash_tostring "struct r_hash_t *ctx" "const char *name" "const ut8 *data" "int len"
.Ft ut32
.Fn r_hash_adler32 "const ut8 *buf" "int len"
.Ft ut32
.Fn r_hash_xxhash "const ut8 *buf" "ut64 len"
.Ft ut8
.Fn r_hash_xor "const ut8 *b" "ut64 len"
.Ft ut16
.Fn r_hash_xorpair "const ut8 *a" "ut64 len"
.Ft int
.Fn r_hash_parity "const ut8 *buf" "ut64 len"
.Ft ut8
.Fn r_hash_mod255 "const ut8 *b" "ut64 len"
.Ft ut64
.Fn r_hash_luhn "const ut8 *buf" "ut64 len"
.Ft char *
.Fn r_hash_ssdeep "const ut8 *buf" "size_t len"
.Ft utcrc
.Fn r_hash_crc_preset "const ut8 *data" "ut32 size" "enum CRC_PRESETS preset"
.Ft ut64
.Fn r_hash_sip "const ut8* buf" "ut64 len"
.Ft ut8
.Fn r_hash_hamdist "const ut8 *buf" "int len"
.Ft double
.Fn r_hash_entropy "const ut8 *data" "ut64 len"
.Ft double
.Fn r_hash_entropy_fraction "const ut8 *data" "ut64 len"
.Ft int
.Fn r_hash_pcprint "const ut8 *buffer" "ut64 len"
.Ft void
.Fn r_hash_do_begin "struct r_hash_t *ctx" "ut64 flags"
.Ft void
.Fn r_hash_do_end "struct r_hash_t *ctx" "ut64 flags"
.Ft void
.Fn r_hash_do_spice "struct r_hash_t *ctx" "ut64 algo" "int loops" "RHashSeed *seed"
.Sh DESCRIPTION
The
.Nm r_hash
library provides a comprehensive set of hashing and checksum algorithms for use within radare2.
It supports various cryptographic hash functions (MD4, MD5, SHA-1, SHA-256, SHA-384, SHA-512),
non-cryptographic hashes (Adler32, XXHash, SipHash), checksums (CRC variants, XOR, parity),
and analysis functions (entropy, hamming distance, printable character percentage).
.Pp
The core structure is
.Vt struct r_hash_t ,
which holds contexts for different hash algorithms and a digest buffer.
Hash algorithms are selected using bit flags defined as
.Dv R_HASH_* macros.
.Sh INITIALIZATION
To use the hash library, first create a new hash context:
.Bd -literal -offset indent
RHash *ctx = r_hash_new(true, R_HASH_MD5 | R_HASH_SHA256);
.Ed
.Pp
The first argument
.Fa rst
controls whether to reset the context after each operation.
The second argument
.Fa flags
specifies which hash algorithms to initialize.
.Pp
After use, free the context:
.Bd -literal -offset indent
r_hash_free(ctx);
.Ed
.Sh CORE OPERATIONS
Hash a buffer with a specific algorithm:
.Bd -literal -offset indent
ut8 *digest = r_hash_do_md5(ctx, data, data_len);
.Ed
.Pp
For multiple algorithms at once:
.Bd -literal -offset indent
r_hash_calculate(ctx, R_HASH_MD5 | R_HASH_SHA1, data, len);
.Ed
.Pp
Get hash name or size:
.Bd -literal -offset indent
const char *name = r_hash_name(R_HASH_SHA256);  // "sha256"
int size = r_hash_size(R_HASH_SHA256);  // 32
.Ed
.Pp
Convert hash bits to string:
.Bd -literal -offset indent
char *hex = r_hash_tostring(ctx, "md5", digest, 16);
.Ed
.Sh CHECKSUMS AND ANALYSIS
Compute simple checksums:
.Bd -literal -offset indent
ut32 adler = r_hash_adler32(data, len);
ut8 xor_sum = r_hash_xor(data, len);
.Ed
.Pp
Calculate entropy:
.Bd -literal -offset indent
double entropy = r_hash_entropy(data, len);
.Ed
.Pp
CRC with preset:
.Bd -literal -offset indent
utcrc crc = r_hash_crc_preset(data, size, CRC_PRESET_32);
.Ed
.Sh ADVANCED FEATURES
For incremental hashing, use begin/end:
.Bd -literal -offset indent
r_hash_do_begin(ctx, R_HASH_SHA256);
r_hash_do_sha256(ctx, chunk1, len1);
r_hash_do_sha256(ctx, chunk2, len2);
r_hash_do_end(ctx, R_HASH_SHA256);
.Ed
.Pp
HMAC-SHA256:
.Bd -literal -offset indent
ut8 *hmac = r_hash_do_hmac_sha256(ctx, msg, msg_len, key, key_len);
.Ed
.Sh EXAMPLES
Compute MD5 and SHA256 of a string:
.Bd -literal -offset indent
#include <r_hash.h>

int main() {
    const char *data = "Hello, World!";
    RHash *ctx = r_hash_new(true, R_HASH_MD5 | R_HASH_SHA256);
    
    r_hash_calculate(ctx, R_HASH_MD5 | R_HASH_SHA256, (ut8*)data, strlen(data));
    
    printf("MD5: ");
    for(int i=0; i<16; i++) printf("%02x", ctx->digest[i]);
    printf("\\nSHA256: ");
    for(int i=16; i<48; i++) printf("%02x", ctx->digest[i]);
    printf("\\n");
    
    r_hash_free(ctx);
    return 0;
}
.Ed
.Pp
Calculate file entropy:
.Bd -literal -offset indent
double entropy = r_hash_entropy(file_buffer, file_size);
printf("File entropy: %.2f\\n", entropy);
.Ed
.Sh SEE ALSO
.Xr r_bin 3 ,
.Xr r_core 3 ,
.Xr r_util 3