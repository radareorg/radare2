ad "tax" 0700000000000000
ad "txa" 8700000000000000

ad "ldb [0]" 3000000000000000
ad "ldb [x+0]" 5000000000000000
ad "ldb [x-3]" 50000000fdffffff
a "ldb [0x0]" 3000000000000000
ad "ldh [2]" 2800000002000000
ad "ldh [x+2]" 4800000002000000
ad "ld [x+2]" 4000000002000000

# a "jmp +0x1b" 05001b0000000000

ad "add 1" 0400000001000000
ad "sub 2" 1400000002000000
ad "mul 3" 2400000003000000
ad "div 4" 3400000004000000
ad "or 0x5" 4400000005000000
ad "and 0x6" 5400000006000000
ad "lsh 7" 6400000007000000
ad "rsh 8" 7400000008000000
ad "neg" 8400000000000000
ad "mod 10" 940000000a000000
ad "xor 0xb" a40000000b000000

ad "ret 0x3" 0600000003000000
ad "ret x" 0e00000000000000
ad "ret a" 1600000000000000

# Test jump offsets above INT8_MAX to make sure they are handled as unsigned.
ad "jgt 0x1234, 0x00000010, 0x00000560" 250001ab34120000
ad "jge 0xabcd0000, 0x00000788, 0x00000588" 3500f0b00000cdab
ad "jeq 0x800, 0x00000008, 0x000004b0" 1500009500080000
ad "jeq 0x86dd, 0x00000008, 0x00000038" 15000006dd860000
ad "jset 0x1fff, 0x00000440, 0x00000008" 45008700ff1f0000

# New assembler coverage for classical BPF memory and len forms
ad "st M[0]" 0200000000000000
ad "st M[7]" 0200000007000000
ad "stx M[1]" 0300000001000000
ad "ld M[2]" 6000000002000000
ad "ldx M[3]" 6100000003000000
ad "ld len" 8000000000000000
ad "ldx len" 8100000000000000
ad "ld 0xdeadbeef" 00000000efbeadde
ad "ldx 0x1337" 0100000037130000
ad "ldxb 4*([16]&0xf)" b100000010000000
ad "ja 32" 0500000003000000
