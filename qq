{"foo":"## Title\nFix r2r parallel output mixing on failures (portable, incl. Windows)\n\n## Repository / Scope\n- Repo: radareorg/radare2\n- Work only under: binr/r2r/\n\n## Problem Summary (for Codex)\nWhen tests run in parallel (e.g., -j > 1) and at least one test fails or times out, r2r sometimes mixes stdout/stderr from unrelated tests. This only happens on error paths; a fully green run is stable. The issue stems from fragile process handling and output capture: shared/leaked pipe handles/FDs, incomplete kill on timeout, non-atomic printing, and reuse of global/shared buffers. A previous patch attempt introduced non-portable UNIX-only APIs (pipe2/O_CLOEXEC/killpg/poll) and dead code on Windows.\n\n## Goal\nRefactor r2r’s child-process execution and output capture to be **robust and cross-platform** (Linux/macOS/Windows MSVC+MinGW), ensuring:\n1) No FD/handle leakage to grandchildren.\n2) Reliable cancellation/timeout that terminates the entire subprocess tree per test.\n3) Correct draining of stdout/stderr after termination so residual bytes don’t bleed into other tests.\n4) Atomic printing of failure diagnostics to avoid interleaving lines across threads.\n5) No nonportable calls in the Windows code path.\n\n## Constraints & Design Rules\n- Do **not** change the external CLI/UX of r2r.\n- Keep changes localized to binr/r2r/ (new helper source files allowed here).\n- Avoid UNIX-only APIs in shared code. Use #ifdef _WIN32 for Windows branches and POSIX otherwise.\n- No global shared FILE*/buffers for concurrent tests. Allocate per-test structures.\n- Ensure large-output tests never deadlock (reader threads on Windows; nonblocking + poll/select on POSIX are OK, but keep Windows path free of poll/select).\n\n## Deliverables (exact edits/files)\n1) **Create** binr/r2r/r2r_proc.h and binr/r2r/r2r_proc.c implementing a portable runner API:\n   - Types:\n     - struct R2RProc;  // opaque per-test process handle\n   - API:\n     - R2RProc *r2r_proc_spawn(const char **argv, bool merge_err, char **err_msg);\n       // Spawns the test in its own process group / job, with dedicated pipes for stdout and (optionally) stderr.\n     - bool r2r_proc_wait(R2RProc *p, int timeout_ms, int *exit_code, char **err_msg);\n       // Waits with timeout. On timeout, ensures full tree termination.\n     - bool r2r_proc_read_all(R2RProc *p, RStrBuf *out, RStrBuf *err);\n       // Drains both streams fully (until EOF). Safe to call after timeout/kill.\n     - void r2r_proc_free(R2RProc *p);\n       // Closes handles/FDs and frees.\n\n2) **Implement POSIX branch** (in r2r_proc.c under #ifndef _WIN32):\n   - Use pipe() + fcntl(FD_CLOEXEC) for both ends (avoid pipe2).\n   - After fork(): in child, setpgid(0,0) before exec; dup2 write ends; close all FDs.\n   - In parent, setpgid(child, child) (best-effort).\n   - For timeout, kill the *process group* via kill(-pgid, SIGKILL) or killpg(child, SIGKILL).\n   - Drain pipes using nonblocking reads with poll/select until EOF after the child exits/is killed.\n\n3) **Implement Windows branch** (in r2r_proc.c under #ifdef _WIN32):\n   - Use CreatePipe with SECURITY_ATTRIBUTES { bInheritHandle = TRUE } then call SetHandleInformation(..., HANDLE_FLAG_INHERIT, 0) on the **read ends** to keep them non-inheritable by the child.\n   - CreateProcessW with CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP.\n   - Create a Job Object; set JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE; AssignProcessToJobObject so all grandchildren die when the job is closed.\n   - For timeout, call TerminateJobObject (or close job handle) to kill the tree.\n   - Start **two reader threads** (one per pipe) using ReadFile in blocking mode and append to RStrBuf. Join them after process exit/kill to guarantee full drain and avoid pipe-buffer deadlocks.\n   - Avoid poll/select/killpg/Unix signals entirely in this branch.\n\n4) **Introduce atomic print** in binr/r2r/r2r.c (or a small helper):\n   - Add a cross-platform mutex wrapper:\n     - POSIX: pthread_mutex_t\n     - Windows: CRITICAL_SECTION\n   - Implement: void r2r_print_block_atomic(const char *s, size_t len);\n     - Locks, writes the entire failure block (expected/got/diff), unlocks.\n\n5) **Replace current per-test execution path** in r2r.c:\n   - Where a test command is spawned/executed with timeout and captured, replace with r2r_proc_* API.\n   - Ensure no shared/global capture buffers. Keep capture variables in a per-test struct that lives only on that worker thread.\n   - On any failure/timeout, always call r2r_proc_read_all() **after** termination to flush residual data, then print via r2r_print_block_atomic().\n\n6) **Build system updates** (binr/r2r/meson.build or Makefile):\n   - Add r2r_proc.c to the r2r target.\n   - Link against r_util as before. No new external dependencies.\n\n## Acceptance Criteria\n- Linux/macOS/Windows builds succeed (MSVC and MinGW). No UNIX-only calls in Windows path.\n- Running with parallelism (e.g., r2r -j 8) and introducing a forced failing test does **not** interleave outputs; failure blocks print atomically.\n- No orphan/lingering child processes remain after timeouts (verify via process list on all platforms).\n- No deadlocks with large outputs (e.g., tests that write > 1MB to stdout/stderr).\n\n## Test Hints (manual)\n- Intentionally add one failing test that writes many lines to stderr while others pass; run with -j 8 and a short -t timeout to stress the error path.\n- Repeat multiple times; output must stay stable and non-interleaved.\n\n## Notes for Codex\n- Do not use pipe2 or killpg in shared headers; keep them inside POSIX #ifdefs.\n- On Windows, prefer Job Objects over ad-hoc tree killing logic.\n- Ensure all handles/FDs are closed in both success and error paths.\n- Keep code clear and documented; remove any now-dead code from the previous attempt.\n\n## Commit Message (suggested)\nbinr/r2r: robust, portable child-process runner + atomic fail printing (fixes mixed output on failure)\n\n- Introduce r2r_proc.* with POSIX and Windows implementations\n- Use process-group / job-object tree termination on timeout\n- Drain stdout/stderr reliably; no FD/handle leakage\n- Atomic printing of failure blocks to avoid interleaving\n- Remove nonportable/dead code from previous attempt\n\"\n```"}
